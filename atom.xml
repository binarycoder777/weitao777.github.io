<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-08T12:46:11.557Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jedis和redission</title>
    <link href="http://example.com/2022/02/08/jedis%E5%92%8Credission/"/>
    <id>http://example.com/2022/02/08/jedis%E5%92%8Credission/</id>
    <published>2022-02-08T12:45:00.000Z</published>
    <updated>2022-02-08T12:46:11.557Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-57.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-57.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="框架实现" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash算法</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-08T12:33:00.000Z</published>
    <updated>2022-02-08T12:34:21.071Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-55.png" alt="upload successful"></p><p> <img src="/images/pasted-56.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-55.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-56.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Redis/"/>
    
    
    <category term="一致性哈希算法" scheme="http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群的主从复制模型</title>
    <link href="http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-02-08T12:27:00.000Z</published>
    <updated>2022-02-08T12:27:38.911Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-54.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-54.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="主从复制模型" scheme="http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存优化</title>
    <link href="http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-08T12:09:00.000Z</published>
    <updated>2022-02-08T12:10:03.147Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-52.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-52.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存优化" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis的回收进程如何工作</title>
    <link href="http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/"/>
    <id>http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</id>
    <published>2022-02-08T09:37:00.000Z</published>
    <updated>2022-02-08T11:59:38.055Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-51.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-51.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="回收进程" scheme="http://example.com/tags/%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个Redis实例能存放多少key？</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/</id>
    <published>2022-02-08T09:27:00.000Z</published>
    <updated>2022-02-08T09:28:21.147Z</updated>
    
    <content type="html"><![CDATA[<p>理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的<br>值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的&lt;br&gt;值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis异步队列</title>
    <link href="http://example.com/2022/02/08/Redis%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/02/08/Redis%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/</id>
    <published>2022-02-08T08:50:00.000Z</published>
    <updated>2022-02-08T09:02:41.782Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-49.png" alt="upload successful"></p><p> <img src="/images/pasted-50.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-49.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-50.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="异步队列" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="http://example.com/2022/02/08/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2022/02/08/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-02-08T08:29:00.000Z</published>
    <updated>2022-02-08T08:30:14.720Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-48.png" alt="upload successful"></p><p> 转载自：<a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html">https://www.cnblogs.com/wangyingshuo/p/14510524.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-48.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 转载自：&lt;a href=&quot;https://www.cnblogs.com/wangyingshuo/p/14510524.html&quot;&gt;htt</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="分布式锁" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如何保证Redis数据都是热点数据？</title>
    <link href="http://example.com/2022/02/07/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F/"/>
    <id>http://example.com/2022/02/07/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F/</id>
    <published>2022-02-07T10:06:00.000Z</published>
    <updated>2022-02-07T10:11:22.310Z</updated>
    
    <content type="html"><![CDATA[<p>1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。<br>所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p><p>2.问题是什么数据？</p><p>比如用户数据。数据库有2000w条。<br>活跃用户：<br>redis sortSet里 放两天内(为方便取一天内活跃用户)登录过的用户，登录一次ZADD一次，如set已存在则覆盖其分数（登录时间）。键：login:users，值：分数 时间戳、value userid。设置一个周期任务，比如每天03:00:00点删除sort set中前一天3点前的数据（保证set不无序增长、留近一天内活跃用户）。</p><p>取时，拿到当前时间戳（int 10位），再减1天就可按分数范围取过去24h活跃用户。</p><p>3.看你的提问,应该只是把Redis当缓存来用.<br>提供一种简单实现缓存失效的思路: LRU(最近少用的淘汰)<br>即redis的缓存每命中一次,就给命中的缓存增加一定ttl(过期时间)(根据具体情况来设定, 比如10分钟).<br>一段时间后, 热数据的ttl都会较大, 不会自动失效, 而冷数据基本上过了设定的ttl就马上失效了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。&lt;br&gt;所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。&lt;/p&gt;
&lt;p&gt;2.问题是什么数据？&lt;/p&gt;
&lt;p&gt;比如用户数据。数据库有2000w条。&lt;br</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="热点数据" scheme="http://example.com/tags/%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Redis共享整数字符串</title>
    <link href="http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-02-07T01:55:00.000Z</published>
    <updated>2022-02-07T01:55:23.165Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-47.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-47.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="共享" scheme="http://example.com/tags/%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象内存回收</title>
    <link href="http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</id>
    <published>2022-02-07T01:53:00.000Z</published>
    <updated>2022-02-07T01:53:31.910Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-46.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-46.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存回收" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之对象</title>
    <link href="http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-02-07T00:49:00.000Z</published>
    <updated>2022-02-07T01:52:21.525Z</updated>
    
    <content type="html"><![CDATA[<p>Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现。</p><p>在底层上，由一个type类型表明当前数据对象属于哪个类型，由encodeing表明底层具体的数据结构实现，然后由一个指针指向底层的数据结构实现。这样的好处的话主要就是在不同的应用场景选择不同的底层数据结构实现，会大大提高redis的存储性能。</p><p>1、具体的话，String类型底层实现有：int、raw、embstr三种数据结构的实现。其中int类型的底层数据结构实现主要是用于存放整数值，当我们的value是一个整数值，就可以选择用int类型的底层实现。而raw类型的底层实现则是一个动态字符串数据结构，一般当字符串大于32字节就会使用到。embstr则是当字符串小于32字节会使用到。两者的不同在于，embstr只会进行一次内存分配和释放，而raw则会进行两次内存分配和释放；而且embstr的内存时连续的，而raw不是。</p><p>需要注意的是：double这种浮点型的数据作为value存储的时候，底层使用的是str类型的数据结构实现。另外上述三种底层数据结构实现是可以相互转换的。</p><p>2、list类型底层编码可以使ziplist和linkedlist两种类型，当list满足每个节点小于64字节并且节点数小于512个就可以采用ziplist作为底层实现，否则采用linkedlist</p><p>3、hash对象底层编码可以使ziplist和hashtable两种类型<br> <img src="/images/pasted-38.png" alt="upload successful"></p><p> <img src="/images/pasted-39.png" alt="upload successful"></p><p> 4、set集合的编码实现可以使整数集合和hashtable</p><p>  <img src="/images/pasted-40.png" alt="upload successful"></p><p>  5、有序集合zset的编码实现：ziplist和skiplist。</p><p> <img src="/images/pasted-41.png" alt="upload successful"></p><p> <img src="/images/pasted-42.png" alt="upload successful"></p><p> <img src="/images/pasted-43.png" alt="upload successful"></p><p> <img src="/images/pasted-44.png" alt="upload successful"></p><p> <img src="/images/pasted-45.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="对象" scheme="http://example.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之整数集合</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</id>
    <published>2022-02-06T13:40:00.000Z</published>
    <updated>2022-02-06T13:49:01.981Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-37.png" alt="upload successful"></p><p> 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encoding决定保存是int16、32还是64.</p><p> 当将一个新元素加入整数集合时，而且这个元素类型长于当前集合类型，就会先对集合升级，然后在加入新元素。</p><p> 升级：</p><p> 1、根据新元素类型，开辟新的数组</p><p> 2、将原数组的元素转移到新数组的正确位置上，且转化为与新数组相同的类型</p><p> 3、将新元素加到新数组指定的位置</p><p> 好处：</p><p> 1、提升灵活性，C语言是静态类型语言，为了避免错误，不会将两种类型放在一个数据结构里面，通过底层数组升级操作，不必担心不同类型的整数出现类型错误</p><p> 2、节约内存，整数集合的升级操作，确保了只在需要的时候进行，尽量节约内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-37.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encodi</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="整数集合" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之跳表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/</id>
    <published>2022-02-06T13:13:00.000Z</published>
    <updated>2022-02-06T13:24:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p> <img src="/images/pasted-33.png" alt="upload successful"></p><p> <img src="/images/pasted-34.png" alt="upload successful"></p><p> <img src="/images/pasted-35.png" alt="upload successful"></p><p> <img src="/images/pasted-36.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-33.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/imag</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="跳表" scheme="http://example.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之字典</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/</id>
    <published>2022-02-06T12:37:00.000Z</published>
    <updated>2022-02-06T13:24:45.912Z</updated>
    
    <content type="html"><![CDATA[<p>字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。</p><p>1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下标上的链表进行比较（没有链表则直接加上去），看是否是同一个值，如果是，则覆盖，不是则加到链表尾。</p><p>2、字典则是一个包含两个hash表的结构体，一般情况只使用下标为0的hash表，当对0下标的hash表进行扩容时，会使用到1下标处的hash表。即当0下标处的hash表</p><p>a）满足服务器没有执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于1</p><p>b）或者满足服务器执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于5</p><p>（因为在执bgsave或者bgrewriteaof命令时，服务器在执行备份操作，为了尽可能提高其效率，避免在此期间进行hash表扩容操作）</p><p>c）负载因子小于0.1会收缩</p><p>就会发生扩容，此时会渐进的将0下标的hash表的数据转移到扩容后的1下标处。（这里之所以采取渐进式的转移，主要是考虑到当hash表里面存的数据量很大时，一次性转移会很消耗时间）</p><p> <img src="/images/pasted-30.png" alt="upload successful"></p><p> <img src="/images/pasted-31.png" alt="upload successful"></p><p> <img src="/images/pasted-29.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。&lt;/p&gt;
&lt;p&gt;1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之链表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-06T12:28:00.000Z</published>
    <updated>2022-02-06T12:35:31.761Z</updated>
    
    <content type="html"><![CDATA[<p>链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释放函数等。即最终是一个双端无环链表。</p><p> <img src="/images/pasted-25.png" alt="upload successful"></p><p> <img src="/images/pasted-26.png" alt="upload successful"></p><p> <img src="/images/pasted-24.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之SDS</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</id>
    <published>2022-02-06T12:13:00.000Z</published>
    <updated>2022-02-06T12:36:06.134Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：</p><p>1、可以通过len-free以常数阶获取字符串长度</p><p>2、可以通过free字段避免缓冲区出现溢出的情况</p><p>3、同时也减少字符串修改时，内存重新分配的次数，其具体实现是通过预先分配内存（即当追加字符串之后，字符串小于1MB，会多分配一倍的空间）和懒惰回收（即当字符串变短之后，不会立即回收那一部分空间，而是作为临时空间供后续字符串扩增做优化）</p><p>4、可以保存二进制安全的数据</p><p> <img src="/images/pasted-27.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：&lt;/p&gt;
&lt;p&gt;1</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>枚举单例模式如何防止反射和反序列化</title>
    <link href="http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-01-27T11:08:00.000Z</published>
    <updated>2022-01-27T11:16:11.794Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p><p>2、枚举单例在创建时不存在并发问题：</p><pre><code>枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的</code></pre><p>2、反序列化：</p><pre><code>Java对枚举的序列化作了规定，在序列化时，仅将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象。枚举在序列化和反序列化时，并不会调用构造方法，这就防止了反序列化导致的单例破坏的问题。</code></pre><p>3、反射：</p><pre><code>反射在通过newInstance创建对象时，会检查这个类是否是枚举类，如果是，会抛出异常java.lang.IllegalArgumentException: Cannot reflectively create enum objects，表示反射创建对象失败。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;2、枚举单例在创建时不存在并发问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的
&lt;/c</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单利模式防止反射创建新的实例</title>
    <link href="http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-01-27T09:47:00.000Z</published>
    <updated>2022-01-27T09:49:12.324Z</updated>
    
    <content type="html"><![CDATA[<p>方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类</p><p>方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类&lt;/p&gt;
&lt;p&gt;方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</title>
    <link href="http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/</id>
    <published>2022-01-27T09:40:00.000Z</published>
    <updated>2022-01-27T09:47:09.071Z</updated>
    
    <content type="html"><![CDATA[<p>在类中添加如下方法<br> <img src="/images/pasted-23.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在类中添加如下方法&lt;br&gt; &lt;img src=&quot;/images/pasted-23.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
</feed>
