<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-27T11:16:11.794Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>枚举单例模式如何防止反射和反序列化</title>
    <link href="http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-01-27T11:08:00.000Z</published>
    <updated>2022-01-27T11:16:11.794Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p><p>2、枚举单例在创建时不存在并发问题：</p><pre><code>枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的</code></pre><p>2、反序列化：</p><pre><code>Java对枚举的序列化作了规定，在序列化时，仅将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象。枚举在序列化和反序列化时，并不会调用构造方法，这就防止了反序列化导致的单例破坏的问题。</code></pre><p>3、反射：</p><pre><code>反射在通过newInstance创建对象时，会检查这个类是否是枚举类，如果是，会抛出异常java.lang.IllegalArgumentException: Cannot reflectively create enum objects，表示反射创建对象失败。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;2、枚举单例在创建时不存在并发问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的
&lt;/c</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单利模式防止反射创建新的实例</title>
    <link href="http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-01-27T09:47:00.000Z</published>
    <updated>2022-01-27T09:49:12.324Z</updated>
    
    <content type="html"><![CDATA[<p>方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类</p><p>方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类&lt;/p&gt;
&lt;p&gt;方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</title>
    <link href="http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/</id>
    <published>2022-01-27T09:40:00.000Z</published>
    <updated>2022-01-27T09:47:09.071Z</updated>
    
    <content type="html"><![CDATA[<p>在类中添加如下方法<br> <img src="/images/pasted-23.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在类中添加如下方法&lt;br&gt; &lt;img src=&quot;/images/pasted-23.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis开发运维实践指南笔记</title>
    <link href="http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-26T14:10:01.000Z</published>
    <updated>2022-01-26T14:25:32.547Z</updated>
    
    <content type="html"><![CDATA[<p>1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。</p><p>2、<img src="/images/pasted-17.png" alt="upload successful"></p><p> 3、列出key：</p><p> <img src="/images/pasted-18.png" alt="upload successful"></p><p> 渐进的遍历整个数据库：keys命令会一次性遍历整个数据库获取与之匹配的键，当数据库包含得键值越来越多，这个命令会愈来愈慢，因此，可以用scan命令渐进的，分多次遍历整个数据库</p><p> <img src="/images/pasted-19.png" alt="upload successful"></p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>4、<br> <img src="/images/pasted-21.png" alt="upload successful"></p><p>5、</p><p> <img src="/images/pasted-22.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。&lt;/p&gt;
&lt;p&gt;2、&lt;img src=&quot;/images/pasted-17.png&quot; alt=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>交替打印输出</title>
    <link href="http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/</id>
    <published>2022-01-26T12:59:00.000Z</published>
    <updated>2022-01-26T13:00:45.447Z</updated>
    
    <content type="html"><![CDATA[<p> 三个线程交替打印输出</p><pre><code>public class AlternateOutput &#123;    public static void main(String[] args) &#123;//        Test1 test1 = new Test1();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(1);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(2);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(3);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        Test2 test2 = new Test2();//        Thread t1 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;a&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        Thread t2 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;b&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        Thread t3 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;c&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        test2.setThreads(t1,t2,t3);//        test2.start();        Test3 test3 = new Test3();        Condition condition1 = test3.newCondition();        Condition condition2 = test3.newCondition();        Condition condition3 = test3.newCondition();        new Thread(()-&gt;&#123;            test3.print(&quot;a&quot;,condition1,condition2);        &#125;).start();        new Thread(()-&gt;&#123;            test3.print(&quot;b&quot;,condition2,condition3);        &#125;).start();        new Thread(()-&gt;&#123;            test3.print(&quot;c&quot;,condition3,condition1);        &#125;).start();        test3.start(condition1);    &#125;&#125;class Test1&#123;    private Integer flag = 1;    private Integer num = 10;    public void print(int curFlag) throws InterruptedException &#123;        for (int i=0; i&lt;num; ++i)&#123;            synchronized (this)&#123;                while (this.flag != curFlag)&#123;                    this.wait();                &#125;                System.out.println(curFlag);                this.flag = curFlag % 3 + 1;                this.notifyAll();            &#125;        &#125;    &#125;&#125;class Test2&#123;    private Thread[] threads;    private Integer num = 10;    public Test2(Thread... threads) &#123;        this.threads = threads;    &#125;    public void setThreads(Thread... threads) &#123;        this.threads = threads;    &#125;    public void print(String s) throws InterruptedException &#123;       for (int i=0;i&lt;num;++i)&#123;           LockSupport.park();           System.out.println(s);           LockSupport.unpark(getNextThread());       &#125;    &#125;    public Thread getNextThread()&#123;        int size = threads.length;        Thread cur = Thread.currentThread();        for (int i=0;i&lt;size;++i)&#123;            if (cur == threads[i])&#123;                return threads[(i + 1) % size];            &#125;        &#125;        return null;    &#125;    public void start() &#123;        for (Thread thread: threads)&#123;            thread.start();        &#125;        LockSupport.unpark(threads[0]);    &#125;&#125;class Test3 extends ReentrantLock&#123;    private int num = 10;    public void start(Condition condition)&#123;        this.lock();        try &#123;            condition.signal();        &#125;finally &#123;            this.unlock();        &#125;    &#125;    public void print(String s, Condition cur,Condition next)&#123;        for (int i=0;i&lt;num;++i)&#123;            this.lock();            try&#123;                cur.await();                System.out.println(s);                next.signal();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                this.unlock();            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 三个线程交替打印输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AlternateOutput &amp;#123;

    public static void main(String[] args) &amp;#123;
//        Test1 test1 =</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized锁静态变量Integer</title>
    <link href="http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/"/>
    <id>http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/</id>
    <published>2022-01-25T02:18:00.000Z</published>
    <updated>2022-01-25T02:22:28.673Z</updated>
    
    <content type="html"><![CDATA[<p>当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128~127之间是有效的，因为存在Integer缓存问题）。</p><pre><code>public class Main &#123;    private static Integer i = 0;    public static void main(String[] args) throws InterruptedException &#123;        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();        for (int j = 0; j &lt; 2; j++) &#123;            Thread thread = new Thread(() -&gt; &#123;                for (int k = 0; k &lt; 127; k++) &#123;                    synchronized (i) &#123;                        i++;                    &#125;                &#125;            &#125;, &quot;&quot; + j);            list.add(thread);        &#125;        list.stream().forEach(t -&gt; t.start());        list.stream().forEach(t -&gt; &#123;            try &#123;                t.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        System.out.println(i);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="synchronized" scheme="http://example.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>终止模式之两阶段终止模式（Interrupt）</title>
    <link href="http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-24T11:10:00.000Z</published>
    <updated>2022-01-24T11:20:45.418Z</updated>
    
    <content type="html"><![CDATA[<p>Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。<br>（如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛InterruptedException，并清除 打断标记如果打断的正在运行的线程，则会设置打断标记 ；park的线程被打断，也会设置 打断标记）</p><p> <img src="/images/pasted-16.png" alt="upload successful"></p><pre><code> public class TPTInterrupt &#123;public static void main(String[] args) throws InterruptedException &#123;    TPTInterrupt tptInterrupt = new TPTInterrupt();    tptInterrupt.start();    Thread.sleep(2000);    tptInterrupt.stop();&#125;private Thread thread;public void start()&#123;    thread = new Thread(()-&gt;&#123;        while (true)&#123;            Thread thread = Thread.currentThread();            if (thread.isInterrupted())&#123;                System.out.println(&quot;料理后事...&quot;);                break;            &#125;            try &#123;                Thread.sleep(1000);                System.out.println(&quot;运行中...&quot;);            &#125; catch (InterruptedException e) &#123;                // 标记打断                e.printStackTrace();                thread.interrupt();            &#125;        &#125;    &#125;);    thread.start();&#125;public void stop()&#123;    thread.interrupt();&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。&lt;br&gt;（如果被打断线程正在 sleep，wait，join 会导致</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/juc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="终止模式" scheme="http://example.com/tags/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>创建线程的方式</title>
    <link href="http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2022-01-24T11:02:00.000Z</published>
    <updated>2022-01-24T11:06:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>1、创建Thread对象</p><p> <img src="/images/pasted-13.png" alt="upload successful"></p><p> 2、使用Runnable配合Thread使用</p><p> <img src="/images/pasted-14.png" alt="upload successful"></p><p> 3、FutureTask配合Callable和Thread使用</p><p> <img src="/images/pasted-15.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、创建Thread对象&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-13.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 2、使用Runnable配合Thread使用&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/p</summary>
      
    
    
    
    
    <category term="创建线程" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么要自定义类型加载器？</title>
    <link href="http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/"/>
    <id>http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/</id>
    <published>2022-01-23T11:19:00.000Z</published>
    <updated>2022-01-23T11:20:52.309Z</updated>
    
    <content type="html"><![CDATA[<p>1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。(类的仲裁 –&gt; 类冲突)</p><p>2、修改类加载的方式：类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载</p><p>3、扩展加载源：比如从数据库、网络、甚至是电视机机顶盒进行加载</p><p>4、防止源码泄露：Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
  </entry>
  
  <entry>
    <title>沙箱安全机制</title>
    <link href="http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2022-01-23T11:16:00.000Z</published>
    <updated>2022-01-23T11:19:08.964Z</updated>
    
    <content type="html"><![CDATA[<p>沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
  </entry>
  
  <entry>
    <title>判定一个类型是否属于&quot;不再被使用的类&quot;的条件</title>
    <link href="http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/"/>
    <id>http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/</id>
    <published>2022-01-23T09:49:00.000Z</published>
    <updated>2022-01-23T09:50:58.551Z</updated>
    
    <content type="html"><![CDATA[<p>1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象</p><p>2、加载该类的类加载器被回收</p><p>3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象&lt;/p&gt;
&lt;p&gt;2、加载该类的类加载器被回收&lt;/p&gt;
&lt;p&gt;3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法&lt;/p&gt;
</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    <category term="jvm" scheme="http://example.com/categories/jv-m/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>类的初始化情况：主动使用vs被动使用</title>
    <link href="http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-23T09:31:00.000Z</published>
    <updated>2022-01-23T09:43:56.451Z</updated>
    
    <content type="html"><![CDATA[<p>主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。</p><p>以下使用被认为是主动使用：<br>1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化</p><p>2、当调用类的静态方法时，即当使用了字节码 invokestatic 指令</p><p>3、当使用类、接口的静态字段时(final 修饰特殊考虑)，比如，使用 getstatic 或者 putsttic 指令。(对应访问变量、赋值变量操作)</p><p>4、当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”)</p><p>5、当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</p><p>6、如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</p><p>7、当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类</p><p>8、当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。(涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类)</p><p>注意：<br>1、当Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口在初始化一个类时，并不会先初始化它所实现的接口<br>在初始化一个接口时，并不会先初始化它的父接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化<br>2、JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[]) 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化</p><p>被动使用：除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p><p>1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</p><p>2、当通过子类引用父类的静态变量，不会导致子类初始化</p><p>3、通过数组定义类引用，不会触发此类的初始化</p><p>4、引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</p><p>5、调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。&lt;/p&gt;
&lt;p&gt;以下使用被认为是主动使用：&lt;br&gt;1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化&lt;/p&gt;
&lt;p&gt;2、当调用类的静态方法时，即当使用了字节码 i</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
    <category term="类初始化：主动使用与被动使用" scheme="http://example.com/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>类的加载过程</title>
    <link href="http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2022-01-23T07:55:00.000Z</published>
    <updated>2022-01-23T08:54:30.085Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载，我的理解就是将类的二进制字节码文件加载到内存中，并通过解析字节码中的常量池、类字段、类方法等信息，在jvm方法区中构建出该类的模板，并在堆区创建一个对象实例作为方法区这个类的各种数据访问入口，在jvm运行期间能够通过这个类的模板信息来调用类的静态变量、方法等。<br>其加载过程的话，主要分为加载、链接（验证、准备、解析）、初始化三个步骤。</p><p>1、首先加载，就是查找类的全限定类名，将类的二进制字节码文件加载到jvm的内存中，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，并为之在堆区创建一个实例对象，作为方法区这个类的数据访问入口。当然，在加载前还需要进行验证操作，即检查字节码文件格式，看是否遵循jvm的规范。比如是否以魔数开头等。验证通过后，该类的二进制信息便会被加载到内存。</p><p>2、加载到方法区后需要验证，即检查类的语义、字节码验证、符号引用验证，看是否符合规范。</p><p>3、当验证完毕之后，就开始准备阶段，这一步主要是对类的静态变量分配内存并附上默认值。（注意：final修饰的静态变量在编译阶段就会分配，准备阶段是显示赋值，并且此阶段也不会为实例变量分配初始化）</p><p>4、然后便是解析阶段，即将符号引用转变为直接引用，得到类、字段、方法等在内存中的指针或者偏移量。</p><p>5、最后便是初始化，这个阶段主要是为类的静态变量进行显示赋值。即执行类构造器cinit方法。即执行类变量的赋值动作和静态语句块(static{}块)，虚期机会保证在子类的<clinit>()方法执行之前, 父类的<clinit>()方法已经执行完毕。如果一个类中没有静态语句块,也没有对变量的赋值操作, 那么编译器可以不为这个类生成<clinit>()方法。</p><p>需要注意的是：接口与类不同的是, 执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时, 父接口才会被初始化。 另外, 接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。另外，虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()法,其他线程部需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作, 那就可能造成多个进程阻塞, 在实际应用中这种阻塞往往是隐蔽的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;类的加载，我的理解就是将类的二进制字节码文件加载到内存中，并通过解析字节码中的常量池、类字段、类方法等信息，在jvm方法区中构建出该类的模板，并在堆区创建一个对象实例作为方法区这个类的各种数据访问入口，在jvm运行期间能够通过这个类的模板信息来调用类的静态变量、方法等。&lt;b</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
    <category term="类的加载过程" scheme="http://example.com/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于集合类中的modCount++</title>
    <link href="http://example.com/2022/01/21/%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%E7%9A%84modCount/"/>
    <id>http://example.com/2022/01/21/%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%E7%9A%84modCount/</id>
    <published>2022-01-21T06:45:00.000Z</published>
    <updated>2022-01-21T07:17:15.741Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，直接看源码注释讲解<br> <img src="/images/pasted-10.png" alt="upload successful"><br> 由上图可知，该字段目的在于记录集合结构被修改的次数（增、删、改），该字段被迭代器所使用，当对集合进行迭代遍历时，防止数据发生改变引起错误。因此，当我们使用迭代器时，如果该值被改了，就会触发fast-fail机制，抛出异常ConcurrentModificationExceptions。</p><p> <img src="/images/pasted-11.png" alt="upload successful"></p><p> <img src="/images/pasted-12.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;话不多说，直接看源码注释讲解&lt;br&gt; &lt;img src=&quot;/images/pasted-10.png&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt; 由上图可知，该字段目的在于记录集合结构被修改的次数（增、删、改），该字段被迭代器所使用，当对集合进行迭代遍历时，</summary>
      
    
    
    
    <category term="集合" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/"/>
    
    <category term="java" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/java/"/>
    
    
    <category term="ArrayList" scheme="http://example.com/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>HashMap1.7</title>
    <link href="http://example.com/2022/01/18/HashMap/"/>
    <id>http://example.com/2022/01/18/HashMap/</id>
    <published>2022-01-18T11:27:00.000Z</published>
    <updated>2022-01-18T11:53:34.793Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap1.7底层由数组+链表实现，提供的无参构造方法默认数组容量是16，加载因子是0.75，临界值为16 * 0.75 = 12，当到了临界值则进行扩容。</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>你也可以通过有参构造方法指定容量和加载因子。</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><p>注意，不管有参无参此时都还未初始化数组，只是定义了数组容量。当我们第一次put往hashmap的放数据的时候才会初始化</p><p> <img src="/images/pasted-6.png" alt="upload successful"></p><p>而此时初始化会根据我们最初的容量大小进行初始化，大小为大于等于当前容量的2的幂。<br> <img src="/images/pasted-7.png" alt="upload successful"></p><p> <img src="/images/pasted-8.png" alt="upload successful"></p><p> <img src="/images/pasted-9.png" alt="upload successful"></p><p> 然后便是计算hash值，根据hash值得到数组下标，根据下标到指定位置，如果发送hash冲突则通过拉链法，将冲突元素头插进链表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HashMap1.7底层由数组+链表实现，提供的无参构造方法默认数组容量是16，加载因子是0.75，临界值为16 * 0.75 = 12，当到了临界值则进行扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-4.png&quot; alt=&quot;upload succ</summary>
      
    
    
    
    <category term="java基础" scheme="http://example.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="HashMap" scheme="http://example.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList</title>
    <link href="http://example.com/2022/01/17/ArrayList/"/>
    <id>http://example.com/2022/01/17/ArrayList/</id>
    <published>2022-01-17T12:13:00.000Z</published>
    <updated>2022-01-17T12:20:04.535Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList</p><p>1、ArrayList底层默认是用object数组实现的，因此在增删元素上需要移动元素，效率较低，但支持随机访问元素</p><p>2、ArrayList是线层不安全的，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常或错误。</p><p>3、ArrayList的默认的大小是10。一开始是空数组，当第一次add的时候才会扩容到10，后续容器满了之后会按1.5倍进行扩容。如果一开始指定容器大小，后续则直接按1.5倍进行扩容。最大扩容不超过Integer.MAX_VALUE</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ArrayList&lt;/p&gt;
&lt;p&gt;1、ArrayList底层默认是用object数组实现的，因此在增删元素上需要移动元素，效率较低，但支持随机访问元素&lt;/p&gt;
&lt;p&gt;2、ArrayList是线层不安全的，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常</summary>
      
    
    
    
    <category term="java基础" scheme="http://example.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="List" scheme="http://example.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>成员变量与局部变量</title>
    <link href="http://example.com/2022/01/16/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/"/>
    <id>http://example.com/2022/01/16/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/</id>
    <published>2022-01-16T11:20:00.000Z</published>
    <updated>2022-01-16T11:22:59.161Z</updated>
    
    <content type="html"><![CDATA[<p>从语法形式上看:成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；<br>成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰<br>符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。<br>2. 从变量在内存中的存储⽅式来看:如果成员变量是使⽤ static 修饰的，那么这个成员变量是属<br>于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局<br>部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆<br>内存对象的引⽤或者是指向常量池中的地址。<br>3. 从变量在内存中的⽣存时间上看:成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局<br>部变量随着⽅法的调⽤⽽⾃动消失。<br>4. 成员变量如果没有被赋初值:则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰<br>的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从语法形式上看:成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；&lt;br&gt;成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰&lt;br&gt;符及 static 所修饰；但是，成员变量和局部变量都能被 fi</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>接口和抽象类的区别</title>
    <link href="http://example.com/2022/01/16/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/01/16/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-16T10:39:00.000Z</published>
    <updated>2022-01-16T11:17:43.700Z</updated>
    
    <content type="html"><![CDATA[<ol><li>接⼝的⽅法默认是 public ，所有⽅法在接⼝中不能有实现(Java 8 开始接⼝⽅法可以有默认<br>实现），⽽抽象类可以有⾮抽象的⽅法。</li><li>接⼝中除了 static 、 final 变量，不能有其他变量，⽽抽象类中则不⼀定。</li><li>⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 extends 关键<br>字扩展多个接⼝。</li><li>接⼝⽅法默认修饰符是 public ，抽象⽅法可以有 public 、 protected 和 default 这些修饰<br>符（抽象⽅法就是为了被重写所以不能使⽤ private 关键字修饰！）。</li><li>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏<br>为的规范。<br>备注：</li><li>在 JDK8 中，接⼝也可以定义静态⽅法，可以直接⽤接⼝名调⽤。实现类和实现是不<br>可以调⽤的。如果同时实现两个接⼝，接⼝中定义了⼀样的默认⽅法，则必须重写，不然会报错。</li><li>jdk9 的接⼝被允许定义私有⽅法 。<br>总结⼀下 jdk7~jdk9 Java 中接⼝概念的变化：</li><li>在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实<br>现接⼝的类实现。</li><li>jdk 8 的时候接⼝可以有默认⽅法和静态⽅法功能。</li><li>Jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;接⼝的⽅法默认是 public ，所有⽅法在接⼝中不能有实现(Java 8 开始接⼝⽅法可以有默认&lt;br&gt;实现），⽽抽象类可以有⾮抽象的⽅法。&lt;/li&gt;
&lt;li&gt;接⼝中除了 static 、 final 变量，不能有其他变量，⽽抽象类中则不⼀定。&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Java基础" scheme="http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="接口" scheme="http://example.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤</title>
    <link href="http://example.com/2022/01/16/%E5%9C%A8-Java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E2%BC%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E7%9A%84%E4%BD%9C%E2%BD%A4/"/>
    <id>http://example.com/2022/01/16/%E5%9C%A8-Java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E2%BC%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E7%9A%84%E4%BD%9C%E2%BD%A4/</id>
    <published>2022-01-16T10:34:00.000Z</published>
    <updated>2022-01-16T10:34:43.521Z</updated>
    
    <content type="html"><![CDATA[<p>Java 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ super() 来调⽤⽗类特定的构造⽅法，则会调<br>⽤⽗类中“没有参数的构造⽅法”。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构<br>造⽅法中⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程<br>序在⽗类中找不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参<br>数的构造⽅法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ super() 来调⽤⽗类特定的构造⽅法，则会调&lt;br&gt;⽤⽗类中“没有参数的构造⽅法”。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构&lt;br&gt;造⽅法中⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>重载和重写的区别</title>
    <link href="http://example.com/2022/01/16/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/01/16/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-16T10:05:00.000Z</published>
    <updated>2022-01-16T10:25:19.715Z</updated>
    
    <content type="html"><![CDATA[<pre><code>    重载：在一个java类中，有多个方法同名，签名不同（即不同的参数数量、顺序以及类型）的函数，就发生了重载。    重写：子类继承了父类然后重写了父类中的方法（保持和父类方法的返回值类型、函数名、签名等都不变，只是在函数体中的代码实现逻辑改变了）    注意：重写时，子类抛出的异常范围应小于等于父类，访问修饰变量范围应大于等于父类。如果父类方法被final、static、private修饰则子类不能重写父类方法，但被static修饰的方法可以再次声明。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code&gt;    重载：在一个java类中，有多个方法同名，签名不同（即不同的参数数量、顺序以及类型）的函数，就发生了重载。

    重写：子类继承了父类然后重写了父类中的方法（保持和父类方法的返回值类型、函数名、签名等都不变，只是在函数体中的代码实现逻辑改变了）
</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="重写" scheme="http://example.com/tags/%E9%87%8D%E5%86%99/"/>
    
    <category term="重载" scheme="http://example.com/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
</feed>
