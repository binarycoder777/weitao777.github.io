<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-11T13:38:00.109Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代理模式</title>
    <link href="http://example.com/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-11T13:22:00.000Z</published>
    <updated>2022-02-11T13:38:00.109Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。说直白一点就是在不修改目标对象的基础上，使用代理对象来增强目标对象的业务逻辑方法。</p><p>代理模式分为：静态代理和动态代理（jdk动态代理和cglib动态代理）</p><p>静态代理就是：代理类在程序运行前就确定好了和目标类的关系，在编译期就实现了。其中静态代理的缺点在于：</p><p>1、代码复杂，不便于管理：试想对于代理类，需要和目标类实现相同接口即每个代理类都要实现目标类的的方法，会出现代码重复，且考虑到如果接口增加一个方法，其所有实现类都要重写，维护也麻烦。</p><p>2、代理类依赖于目标类：当代理类考虑代理多个服务的时候，不便于实现</p><p>动态代理是在程序运行期间根据jvm反射机制动态生成的。</p><p>jdk动态代理：基于java反射机制实现的。具体通过使用java.lang.reflect 包提供三个类支持代理模式 Proxy, Method和 InovcationHandler。（要求：求目标对象必须实现接口）</p><pre><code>public interface UsbSell &#123;    Object sell(float amount);&#125;public class UsbFactory implements UsbSell &#123;public Object sell(float amount) &#123;    float price = 0;    if (amount &gt; 100)&#123;        price = (float) (amount * (1 + 0.2));    &#125;else &#123;        price = (float) (amount * (1 + 0.5));    &#125;    return price;    &#125;&#125;public class ProxySeller &#123;private Object target;public ProxySeller() &#123;&#125;public ProxySeller(Object target) &#123;    this.target = target;&#125;public Object getProxy()&#123;    return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123;        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;            float res = (Float) method.invoke(target,args);            System.out.println(&quot;==&quot;+res);            return proxy;        &#125;    &#125;);&#125;&#125;public class Main &#123;public static void main(String[] args) &#123;    UsbFactory factory = new UsbFactory();    ProxySeller seller = new ProxySeller(factory);    UsbSell proxy = (UsbSell)seller.getProxy();    UsbSell s = (UsbSell)proxy.sell(50);    s.sell(50);&#125;&#125;</code></pre><p> cglib动态代理：一个开源项目。对于无接口的类，要为其创建动态代理，就要使用 CGLIB 来实现。CGLIB 代理的生成原理是生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象。所以，使用CGLIB 生成动态代理，要求目标类必须能够被继承，即不能是 final 的类。</p><pre><code>     public class Saller &#123;public float sell(int amount)&#123;    float price = 100;    if (amount &gt; 100)&#123;        price = (float) (price * (1 + 0.2));    &#125;else &#123;        price = (float) (price * (1 + 0.5));    &#125;    return price;&#125;&#125;public class ProxySaller implements MethodInterceptor &#123;private Object target;public ProxySaller() &#123;&#125;public ProxySaller(Object target) &#123;    this.target = target;&#125;public Object getProxySaller()&#123;    Enhancer enhancer = new Enhancer();    enhancer.setSuperclass(target.getClass());    enhancer.setCallback(this);    Saller saller = (Saller) enhancer.create();    return saller;&#125;public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;    Float price = (Float) methodProxy.invoke(target,objects);    System.out.println(&quot;===&quot;+price);    return price;&#125;&#125;public class Main &#123;public static void main(String[] args) &#123;    Saller saller = new Saller();    ProxySaller proxySaller = new ProxySaller(saller);    Saller proxy = (Saller) proxySaller.getProxySaller();    proxy.sell(100);&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。说直白一点就是在不修改目标对象的基础上，使用代理对象来增强目标对象的业务逻辑方法。&lt;/p&gt;
&lt;p&gt;代理模式</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="代理模式" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>innoDB中的锁</title>
    <link href="http://example.com/2022/02/10/innoDB%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://example.com/2022/02/10/innoDB%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2022-02-10T05:38:00.000Z</published>
    <updated>2022-02-10T11:19:02.156Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB实现了共享锁（读锁）和排他锁（写锁）两种行级锁。意向共享锁和意向排他锁两种表级别的锁。</p><p> <img src="/images/pasted-97.png" alt="upload successful"></p><p> <img src="/images/pasted-98.png" alt="upload successful"></p><p> <img src="/images/pasted-99.png" alt="upload successful"></p><p> <img src="/images/pasted-100.png" alt="upload successful"></p><p> <img src="/images/pasted-101.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB实现了共享锁（读锁）和排他锁（写锁）两种行级锁。意向共享锁和意向排他锁两种表级别的锁。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-97.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/im</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>lock与latch</title>
    <link href="http://example.com/2022/02/10/lock%E4%B8%8Elatch/"/>
    <id>http://example.com/2022/02/10/lock%E4%B8%8Elatch/</id>
    <published>2022-02-10T05:36:00.000Z</published>
    <updated>2022-02-10T05:38:14.315Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-96.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-96.png&quot; alt=&quot;upload successful&quot;&gt;
 &lt;/p&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL分区</title>
    <link href="http://example.com/2022/02/09/MySQL%E5%88%86%E5%8C%BA/"/>
    <id>http://example.com/2022/02/09/MySQL%E5%88%86%E5%8C%BA/</id>
    <published>2022-02-09T12:14:49.000Z</published>
    <updated>2022-02-09T12:14:49.287Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL表</title>
    <link href="http://example.com/2022/02/09/MySQL%E8%A1%A8/"/>
    <id>http://example.com/2022/02/09/MySQL%E8%A1%A8/</id>
    <published>2022-02-09T10:47:00.000Z</published>
    <updated>2022-02-09T12:07:08.587Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB中，表根据主键顺序存放。每张表都有一个主键，在建表时没有显示定义主键，则innoDB会先判断表中是否有非空的唯一索引，如果有，则该索引即为主键（对于多个非空唯一索引，根据定义的顺序选择，而不是建表列的顺序选择），如果没有，则会自动创建一个6字节的指针。</p><p>innoDB中，数据被逻辑的放在一个表空间。表空间由段组成，段又由区组成，区又有页组成，页时最基本的单位。如下：<br> <img src="/images/pasted-83.png" alt="upload successful"></p><p>innoDB默认情况下有一个共享表空间，如果用户开启参数innodb_file_per_table则每张表的数据单独放到一个表空间。（需要注意的是：单独的表空间只是存放数据、索引和插入缓冲bitmap页，对于其他数据，如回滚信息、插入缓冲索引页等仍是存放在共享表空间）</p><p>对于段由innoDB管理，数据段即为B+tree的叶子节点，索引段即为B+tree的非叶子节点，回滚段较为特殊。</p><p>区则是连续页（默认16kb/页）组成的空间（大小1mb）。一个区默认有64个连续的页。为了保证区中页的连续性，innoDB会一次从磁盘申请4-5个区。值得注意的是：</p><p> <img src="/images/pasted-84.png" alt="upload successful"></p><p> innoDB常见页：</p><p> <img src="/images/pasted-85.png" alt="upload successful"></p><p> 页又由行组成最多允许7992（16kb/2-200）行记录。innoDB提供了Compact和Redundant格式的行数据格式。需要注意：除了下图的信息外，还存在事务ID列（6字节）和回滚指针列（7字节），如果innoDB没有定义主键还会有一个6字节的rowid列</p><p> Compact行记录：</p><p> <img src="/images/pasted-86.png" alt="upload successful"></p><p> <img src="/images/pasted-87.png" alt="upload successful"></p><p> Redundant行记录格式：</p><p> <img src="/images/pasted-88.png" alt="upload successful"></p><p> <img src="/images/pasted-89.png" alt="upload successful"></p><p>当然一般情况下innoDB的数据都是放在页类型为B+tree-node中，但是当发生行溢出，数据存放在Uncompress BLOB页中。<br> <img src="/images/pasted-90.png" alt="upload successful"></p><p> innoDB数据页结构：</p><p> <img src="/images/pasted-92.png" alt="upload successful"><br> <img src="/images/pasted-91.png" alt="upload successful"></p><p> <img src="/images/pasted-93.png" alt="upload successful"></p><p> <img src="/images/pasted-94.png" alt="upload successful"></p><p> <img src="/images/pasted-95.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB中，表根据主键顺序存放。每张表都有一个主键，在建表时没有显示定义主键，则innoDB会先判断表中是否有非空的唯一索引，如果有，则该索引即为主键（对于多个非空唯一索引，根据定义的顺序选择，而不是建表列的顺序选择），如果没有，则会自动创建一个6字节的指针。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="表" scheme="http://example.com/tags/%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL文件</title>
    <link href="http://example.com/2022/02/09/MySQL%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2022/02/09/MySQL%E6%96%87%E4%BB%B6/</id>
    <published>2022-02-09T08:05:00.000Z</published>
    <updated>2022-02-09T08:39:14.232Z</updated>
    
    <content type="html"><![CDATA[<p>1、参数文件：MySQL实例启动时会读取参数文件来初始化。</p><p>2、日志文件：</p><p>错误日志（记录了MySQL执行期间的错误信息）</p><p>二进制日志（记录了对MySQL执行的写操作，默认未开启。</p><p>作用：<br>1、恢复，可以通过binlog进行数据的恢复<br>2、复制：通过复制和执行binlog对远程的MySQL进行实时数据同步（主从复制）<br>3、审计：对binlog数据进行审计，看是否有对数据库进行注入的攻击</p><p> <img src="/images/pasted-81.png" alt="upload successful"></p><p> <img src="/images/pasted-82.png" alt="upload successful"><br>）</p><p>慢查询日志（可以从中得到一些SQL优化信息，默认未开启）</p><p>查询日志（记录了所有对MySQL的请求信息）</p><p>3、套接字文件</p><p>4、pid文件</p><p>5、表结构定义文件（以frm为后缀名）：记录了该表的表结构定义。除此之外还用于存放视图的定义。</p><p>6、innoDB存储引擎文件：</p><p>a）表空间文件（默认10mb，名为ibdata1）：可以设置基于innoDB存储的单独的。idb独立表空间文件（仅存储数据、索引等信息，其他信息还是存放于表空间文件）。</p><p> <img src="/images/pasted-78.png" alt="upload successful"></p><p> b）、redolog文件（默认会有两个名为ib_logfile0和ib_logfile1的文件）：每个innoDB至少有一个redolog组（每组至少有两个redolog文件），redolog冲缓冲区写入磁盘是按512字节，即一个扇区大小，可以保障写入必定成功（所有不需要doublewrite）</p><p> <img src="/images/pasted-79.png" alt="upload successful"></p><p> <img src="/images/pasted-80.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、参数文件：MySQL实例启动时会读取参数文件来初始化。&lt;/p&gt;
&lt;p&gt;2、日志文件：&lt;/p&gt;
&lt;p&gt;错误日志（记录了MySQL执行期间的错误信息）&lt;/p&gt;
&lt;p&gt;二进制日志（记录了对MySQL执行的写操作，默认未开启。&lt;/p&gt;
&lt;p&gt;作用：&lt;br&gt;1、恢复，可以通过bi</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="文件" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>innoDB存储引擎</title>
    <link href="http://example.com/2022/02/09/innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/2022/02/09/innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2022-02-09T03:04:00.000Z</published>
    <updated>2022-02-09T07:37:44.969Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB存储引擎是开源的第一个完整支持ACID事务的MySQL存储引擎（第一个支持事务的是BDB存储引擎），其特点是行锁设计、支持MVCC、支持外键、一致性非锁定读等。被广泛的应用。</p><p> <img src="/images/pasted-58.png" alt="upload successful"></p><p> innoDB存储引擎有多个内存块，组成了一个大的内存池，每个内存块有指定的后台线程来维护其运行。</p><p> 1、main线程主要负责将缓冲区的数据异步刷新到磁盘，保证数据的一致性（包括脏页的刷新、合并插入缓冲、undo页的回收等）</p><p> 2、IO线程主要是负责IO请求的回调，包括read、write、insert buffer、log等，其使用了AIO机制，保证了IO性能。</p><p> 3、Purge线程主要用于回收提交事务之后，undo页可能不再需要，需要对其进行回收。（1.2版本支持多个Purge线程，目的是进一步加快undo页的回收，提升性能）</p><p> 4、Page cleaner线程主要用于脏页的刷新操作，减轻main线程的压力。</p><p> innoDB是基于磁盘存储的，为了权衡磁盘速度和CPU速度的差异，提供了一块缓冲池技术来提升性能。（因此可以将缓冲池区域设置大一点来进行优化操作）innoDB1.0允许多个缓冲池实例，磁盘读取的页根据哈希值均匀分配到不同缓冲池中（目的：减少数据库资源竞争，增加数据库并发处理能力）</p><p> 在数据的读取中，会先去缓冲池中查看是否存在于缓冲池，如果存在直接读取，不存在则去磁盘读取，在同步到缓冲池中。而对于写操作则是先写到缓冲池，然后根据Checkpoint机制将脏数据刷新到磁盘，保证磁盘和内存数据的一致性。</p><p> 缓冲池具体的数据页有：</p><p> <img src="/images/pasted-59.png" alt="upload successful"></p><p> 为了管理这些数据页，innoDB使用了一个freeLIst链表来管理空闲的页内存，LRUList来管理已经分配的页内存，flushList来管理脏页。（脏页及存在于LRUList，又存在于flushList，是两者共享的）</p><p> 对于LRUList管理的页，采用了LRU（最近最少使用）算法来管理（缓冲池页大小默认16kb），在LRU列表中加入了一个midpoint位置（默认是5/8位置处），midpoint位置前面的是热点数据区域，后面的是冷数据区域（设置冷、热数据区域主要是为了保证一些经常被访问的数据存在于内存中，提示效率的一种考虑）。当一个新的页被分配到LRULIst上，会先加入到midpoint位置后面（这样做是为了防止当进行全表查询的时候，多个页会覆盖调热数据区域的页，而这些查的数据页又只使用一次，后续不再使用，当后面访问热区域的页时有会从磁盘中查找，浪费性能），同时也指定了一个从冷数据区域晋升到热数据区域的参数，当到了晋升时间后，冷数据区域的页就会晋升到热数据区域。</p><p>值得注意的是：空闲页的内存freeList+以分配的页内存LRUList并不等于缓冲池的内存，因为缓冲池中包含得其他部分页（自适应哈希索引、lock信息等）不需要LRU维护，不存在于LRUList中。</p><p> <img src="/images/pasted-60.png" alt="upload successful"></p><p> 另外，页是支持压缩的，16kb的页可以压缩成1kb、2kb、4kb、8kb。页的大小发生变化，所有对于压缩的页，会使用zipLRUList进行管理。（注意：LRUList包含zipLRUList中的页）</p><p> 对于zipLIRList的页的分配采用伙伴算法</p><p>例如压缩后的页为4kb</p><p>1、先检查4kb的zipLRUList是否有空闲页，存在即分配</p><p>2、否则，检查8kb的zipLRUList看是否存在空闲页，存在则将8kb分为两个4kb，将4kb的页放入4kbzipLRUList<br>，然后为其分配</p><p>3、在否则，检查16kb的freeList看是否存在空闲页，存在则将16kb分为两个4kb，一个8kb，分别放入对应zipLRUList，然后为其分配</p><p> <img src="/images/pasted-61.png" alt="upload successful"></p><p> 由上图可知，innoDB除了缓冲池，还存在redolog日志缓冲和额外内存池。</p><p> 其中redolog日志缓冲（默认8mb大小）是redolog文件的缓冲区（redolog文件记录了写请求的指令，对页的写指令都会记录到这个文件中，后续数据库恢复会使用到这个文件）当满足以下条件就会将缓冲区的数据刷新到文件中。</p><p> 1、每个事物提交会进行刷新</p><p> 2、当缓冲区小于一半，会进行刷新</p><p> 3、main线程每秒会进行一次刷新</p><p> 而额外的内存池则是在对于一些数据结构本身进行进行内存分配时会从额外内存储进行申请。</p><p>前面提到进行写操作入时，一般会先写到缓冲区，然后在根据checkpoint机制将脏页刷新到内存，保持内存和磁盘数据的一致性。但考虑到如果频繁发生写操作，而对脏数据刷新到磁盘不加以控制，每来一个写操作，都会进行一次刷新，那就会产生大量的io，导致整体性能下降；除此之外，在刷新的时候如果出现了宕机，数据也会丢失。因此采用提交事物前，先写redolog日志，然后在修改内存中的页，即使将脏页刷新到磁盘时出现宕机，也能够根据redolog日志进行恢复。而chenckpoint技术就是为了解决</p><p>1、缩短数据库的恢复时间（因为chenckpoint前的脏页都已经刷新到磁盘了，只需对chenckpoint之后的进行恢复）<br>2、缓冲池不够时将脏页刷新到磁盘。（当缓冲池不够用时，会根据LRU算法将最近最少用的页淘汰，而淘汰时会检测是否为脏页，如果是则执行checkpoint，将脏页刷新到磁盘）<br>3、redolog日志不够用时，刷新脏页（即redolog的大小是有限制的，chenckpont前的是可重用的，而chenckpoint之后的是需要的，如果redolog文件里面全部都是需要使用的，则必须进行checkpoint）</p><p>在innoDB中，使用LSN（八字节）标记版本，每个页都有自己的LSN，redolog日志中和checkpoint中也有。</p><p>在innoDB中存在两种checkpoint，即sharp checkpoint（默认）和fuzzy checkpoint。</p><p>sharp checkpoint发生在数据库关闭时，此时会将所有脏页刷新到磁盘（会发生迟钝）</p><p>fuzzy checkpoint则是每次只刷新部分脏页到磁盘。以下是几种发生fuzzy checkpoint的情况：</p><p> <img src="/images/pasted-62.png" alt="upload successful"></p><p> 1、main线程会每秒或10秒的速度从fulshList中刷新页到磁盘。</p><p> 2、当缓冲池没有多余空闲空间，会根据LRU算法冲LRUList淘汰页，对于淘汰的页会检测是否是脏页，是则会刷新到磁盘。</p><p> 3、当redolog不可用时会强制flushList中的脏页进行刷新</p><p> 4、当脏页太多，也会强制进行checkpoint刷新脏页到磁盘。</p><p> innoDB主要工作都是在main线程中完成的，其内部由多个循环组成（主循环、后台循环、刷新循环、暂停循环），在多个循环中切换进行工作。</p><p> innoDB1.0</p><p> 主循环：</p><p> <img src="/images/pasted-64.png" alt="upload successful"></p><p> <img src="/images/pasted-65.png" alt="upload successful"></p><p> 后台循环：</p><p> <img src="/images/pasted-66.png" alt="upload successful"></p><p> innoDB1.2基于上述IO限制，加入了innoDB_io_capacitiy用于表示IO（默认200），对于刷新的页用百分比来控制<br> <img src="/images/pasted-67.png" alt="upload successful"><br> 另外一个参数是innoDB_max_dirty_pct（默认75），当脏页小于innoDB_max_dirty_pct也会刷新一定量的脏页（之前是不会刷新的）。</p><p>  <img src="/images/pasted-61.png" alt="upload successful"><br>  接下来说一说innoDB的插入缓冲。insert buffer和数据页一样，是物理页的一部分。</p><p>  在innoDB中，主键是唯一标识，插入记录一般按主键递增顺序插入。因此，聚集索引一般是顺序的（比如自增id这种），对于顺序的一般插入操作速度很快，但对于主键是uuid之类则和辅助索引一样，是随机的。因此对于这种情况，按顺序插入则相对要慢得多。因此insert buffer的作用就是对于非聚集索引的插入或者更新操作先判断是否存在缓冲池，若存在则直接插入，不存在则放到insert buffer中，在以一定频率进行inser buffer和辅助索引子节点的合并，提高对于非聚集索引的插入性能。当然使用insert buffer需要满足<br> <img src="/images/pasted-69.png" alt="upload successful"></p><p> <img src="/images/pasted-70.png" alt="upload successful"></p><p> insert buffer数据实现是一颗b+树，<br> <img src="/images/pasted-72.png" alt="upload successful"></p><p><img src="/images/pasted-73.png" alt="upload successful"></p><p> <img src="/images/pasted-74.png" alt="upload successful"></p><p> change buffer：在1.0.x版本引入了channge buffer，可以对增删改都进行缓冲<br> <img src="/images/pasted-71.png" alt="upload successful"></p><p> 两次写：当innoDB刷新某个页到磁盘中，但只刷新了部分，数据库就宕机了（部分写失效）。double write就是为了解决这种情况产生的。</p><p> <img src="/images/pasted-75.png" alt="upload successful"></p><p> double write由两部分组成。一部分时内存double write buffer（大小2mb），一部分是磁盘上的共享表空间中连续的128页（即两个区，大小为2mb）。在对脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复杂到 doublewrite buffer，然后doubllewrite buffer再分两次顺序的写到共享表空间的物理磁盘上（每次写1mb）。完成之后，在将doublewrite buffer中的页写入各个表文件空间中。如果在写入表中磁盘时发生了宕机什么的。在恢复时，可以从共享表空间中找到一个备份页，将其复制到表空间。</p><p> <img src="/images/pasted-76.png" alt="upload successful"></p><p> 自适应哈希：innoDB会对表上各索引页的查询监控。如果建立哈希索引会提升性能，则建立哈希索引。而条件就是：对这个页的连续访问模式要一样。</p><p> 异步IO：innoDB采用AIO的方式处理磁盘操作，可以在发起一个IO请求后，立马发起另一个IO请求，当全部发送完后，等所有请求操作完。除此之外，还可以进行IO的合并操作。</p><p> 刷新邻接页：即刷新一个脏页时，会检测该页周围的页是否是脏页，是则一并刷新。</p><p> <img src="/images/pasted-77.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB存储引擎是开源的第一个完整支持ACID事务的MySQL存储引擎（第一个支持事务的是BDB存储引擎），其特点是行锁设计、支持MVCC、支持外键、一致性非锁定读等。被广泛的应用。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-58.png&quot; al</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="innoDB" scheme="http://example.com/tags/innoDB/"/>
    
  </entry>
  
  <entry>
    <title>jedis和redission</title>
    <link href="http://example.com/2022/02/08/jedis%E5%92%8Credission/"/>
    <id>http://example.com/2022/02/08/jedis%E5%92%8Credission/</id>
    <published>2022-02-08T12:45:00.000Z</published>
    <updated>2022-02-08T12:46:11.557Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-57.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-57.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="框架实现" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash算法</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-08T12:33:00.000Z</published>
    <updated>2022-02-08T12:34:21.071Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-55.png" alt="upload successful"></p><p> <img src="/images/pasted-56.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-55.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-56.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Redis/"/>
    
    
    <category term="一致性哈希算法" scheme="http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群的主从复制模型</title>
    <link href="http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-02-08T12:27:00.000Z</published>
    <updated>2022-02-08T12:27:38.911Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-54.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-54.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="主从复制模型" scheme="http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存优化</title>
    <link href="http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-08T12:09:00.000Z</published>
    <updated>2022-02-08T12:10:03.147Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-52.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-52.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存优化" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis的回收进程如何工作</title>
    <link href="http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/"/>
    <id>http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</id>
    <published>2022-02-08T09:37:00.000Z</published>
    <updated>2022-02-08T11:59:38.055Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-51.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-51.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="回收进程" scheme="http://example.com/tags/%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个Redis实例能存放多少key？</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/</id>
    <published>2022-02-08T09:27:00.000Z</published>
    <updated>2022-02-08T09:28:21.147Z</updated>
    
    <content type="html"><![CDATA[<p>理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的<br>值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的&lt;br&gt;值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis异步队列</title>
    <link href="http://example.com/2022/02/08/Redis%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/02/08/Redis%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/</id>
    <published>2022-02-08T08:50:00.000Z</published>
    <updated>2022-02-08T09:02:41.782Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-49.png" alt="upload successful"></p><p> <img src="/images/pasted-50.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-49.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-50.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="异步队列" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="http://example.com/2022/02/08/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2022/02/08/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-02-08T08:29:00.000Z</published>
    <updated>2022-02-08T08:30:14.720Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-48.png" alt="upload successful"></p><p> 转载自：<a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html">https://www.cnblogs.com/wangyingshuo/p/14510524.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-48.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 转载自：&lt;a href=&quot;https://www.cnblogs.com/wangyingshuo/p/14510524.html&quot;&gt;htt</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="分布式锁" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如何保证Redis数据都是热点数据？</title>
    <link href="http://example.com/2022/02/07/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F/"/>
    <id>http://example.com/2022/02/07/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F/</id>
    <published>2022-02-07T10:06:00.000Z</published>
    <updated>2022-02-07T10:11:22.310Z</updated>
    
    <content type="html"><![CDATA[<p>1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。<br>所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p><p>2.问题是什么数据？</p><p>比如用户数据。数据库有2000w条。<br>活跃用户：<br>redis sortSet里 放两天内(为方便取一天内活跃用户)登录过的用户，登录一次ZADD一次，如set已存在则覆盖其分数（登录时间）。键：login:users，值：分数 时间戳、value userid。设置一个周期任务，比如每天03:00:00点删除sort set中前一天3点前的数据（保证set不无序增长、留近一天内活跃用户）。</p><p>取时，拿到当前时间戳（int 10位），再减1天就可按分数范围取过去24h活跃用户。</p><p>3.看你的提问,应该只是把Redis当缓存来用.<br>提供一种简单实现缓存失效的思路: LRU(最近少用的淘汰)<br>即redis的缓存每命中一次,就给命中的缓存增加一定ttl(过期时间)(根据具体情况来设定, 比如10分钟).<br>一段时间后, 热数据的ttl都会较大, 不会自动失效, 而冷数据基本上过了设定的ttl就马上失效了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。&lt;br&gt;所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。&lt;/p&gt;
&lt;p&gt;2.问题是什么数据？&lt;/p&gt;
&lt;p&gt;比如用户数据。数据库有2000w条。&lt;br</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="热点数据" scheme="http://example.com/tags/%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Redis共享整数字符串</title>
    <link href="http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-02-07T01:55:00.000Z</published>
    <updated>2022-02-07T01:55:23.165Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-47.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-47.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="共享" scheme="http://example.com/tags/%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象内存回收</title>
    <link href="http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</id>
    <published>2022-02-07T01:53:00.000Z</published>
    <updated>2022-02-07T01:53:31.910Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-46.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-46.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存回收" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之对象</title>
    <link href="http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-02-07T00:49:00.000Z</published>
    <updated>2022-02-07T01:52:21.525Z</updated>
    
    <content type="html"><![CDATA[<p>Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现。</p><p>在底层上，由一个type类型表明当前数据对象属于哪个类型，由encodeing表明底层具体的数据结构实现，然后由一个指针指向底层的数据结构实现。这样的好处的话主要就是在不同的应用场景选择不同的底层数据结构实现，会大大提高redis的存储性能。</p><p>1、具体的话，String类型底层实现有：int、raw、embstr三种数据结构的实现。其中int类型的底层数据结构实现主要是用于存放整数值，当我们的value是一个整数值，就可以选择用int类型的底层实现。而raw类型的底层实现则是一个动态字符串数据结构，一般当字符串大于32字节就会使用到。embstr则是当字符串小于32字节会使用到。两者的不同在于，embstr只会进行一次内存分配和释放，而raw则会进行两次内存分配和释放；而且embstr的内存时连续的，而raw不是。</p><p>需要注意的是：double这种浮点型的数据作为value存储的时候，底层使用的是str类型的数据结构实现。另外上述三种底层数据结构实现是可以相互转换的。</p><p>2、list类型底层编码可以使ziplist和linkedlist两种类型，当list满足每个节点小于64字节并且节点数小于512个就可以采用ziplist作为底层实现，否则采用linkedlist</p><p>3、hash对象底层编码可以使ziplist和hashtable两种类型<br> <img src="/images/pasted-38.png" alt="upload successful"></p><p> <img src="/images/pasted-39.png" alt="upload successful"></p><p> 4、set集合的编码实现可以使整数集合和hashtable</p><p>  <img src="/images/pasted-40.png" alt="upload successful"></p><p>  5、有序集合zset的编码实现：ziplist和skiplist。</p><p> <img src="/images/pasted-41.png" alt="upload successful"></p><p> <img src="/images/pasted-42.png" alt="upload successful"></p><p> <img src="/images/pasted-43.png" alt="upload successful"></p><p> <img src="/images/pasted-44.png" alt="upload successful"></p><p> <img src="/images/pasted-45.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="对象" scheme="http://example.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之整数集合</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</id>
    <published>2022-02-06T13:40:00.000Z</published>
    <updated>2022-02-06T13:49:01.981Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-37.png" alt="upload successful"></p><p> 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encoding决定保存是int16、32还是64.</p><p> 当将一个新元素加入整数集合时，而且这个元素类型长于当前集合类型，就会先对集合升级，然后在加入新元素。</p><p> 升级：</p><p> 1、根据新元素类型，开辟新的数组</p><p> 2、将原数组的元素转移到新数组的正确位置上，且转化为与新数组相同的类型</p><p> 3、将新元素加到新数组指定的位置</p><p> 好处：</p><p> 1、提升灵活性，C语言是静态类型语言，为了避免错误，不会将两种类型放在一个数据结构里面，通过底层数组升级操作，不必担心不同类型的整数出现类型错误</p><p> 2、节约内存，整数集合的升级操作，确保了只在需要的时候进行，尽量节约内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-37.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encodi</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="整数集合" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
