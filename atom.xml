<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-06T13:49:01.981Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis底层数据结构之整数集合</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</id>
    <published>2022-02-06T13:40:00.000Z</published>
    <updated>2022-02-06T13:49:01.981Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-37.png" alt="upload successful"></p><p> 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encoding决定保存是int16、32还是64.</p><p> 当将一个新元素加入整数集合时，而且这个元素类型长于当前集合类型，就会先对集合升级，然后在加入新元素。</p><p> 升级：</p><p> 1、根据新元素类型，开辟新的数组</p><p> 2、将原数组的元素转移到新数组的正确位置上，且转化为与新数组相同的类型</p><p> 3、将新元素加到新数组指定的位置</p><p> 好处：</p><p> 1、提升灵活性，C语言是静态类型语言，为了避免错误，不会将两种类型放在一个数据结构里面，通过底层数组升级操作，不必担心不同类型的整数出现类型错误</p><p> 2、节约内存，整数集合的升级操作，确保了只在需要的时候进行，尽量节约内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-37.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encodi</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="整数集合" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之跳表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/</id>
    <published>2022-02-06T13:13:00.000Z</published>
    <updated>2022-02-06T13:24:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p> <img src="/images/pasted-33.png" alt="upload successful"></p><p> <img src="/images/pasted-34.png" alt="upload successful"></p><p> <img src="/images/pasted-35.png" alt="upload successful"></p><p> <img src="/images/pasted-36.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-33.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/imag</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="跳表" scheme="http://example.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之字典</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/</id>
    <published>2022-02-06T12:37:00.000Z</published>
    <updated>2022-02-06T13:24:45.912Z</updated>
    
    <content type="html"><![CDATA[<p>字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。</p><p>1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下标上的链表进行比较（没有链表则直接加上去），看是否是同一个值，如果是，则覆盖，不是则加到链表尾。</p><p>2、字典则是一个包含两个hash表的结构体，一般情况只使用下标为0的hash表，当对0下标的hash表进行扩容时，会使用到1下标处的hash表。即当0下标处的hash表</p><p>a）满足服务器没有执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于1</p><p>b）或者满足服务器执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于5</p><p>（因为在执bgsave或者bgrewriteaof命令时，服务器在执行备份操作，为了尽可能提高其效率，避免在此期间进行hash表扩容操作）</p><p>c）负载因子小于0.1会收缩</p><p>就会发生扩容，此时会渐进的将0下标的hash表的数据转移到扩容后的1下标处。（这里之所以采取渐进式的转移，主要是考虑到当hash表里面存的数据量很大时，一次性转移会很消耗时间）</p><p> <img src="/images/pasted-30.png" alt="upload successful"></p><p> <img src="/images/pasted-31.png" alt="upload successful"></p><p> <img src="/images/pasted-29.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。&lt;/p&gt;
&lt;p&gt;1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之链表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-06T12:28:00.000Z</published>
    <updated>2022-02-06T12:35:31.761Z</updated>
    
    <content type="html"><![CDATA[<p>链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释放函数等。即最终是一个双端无环链表。</p><p> <img src="/images/pasted-25.png" alt="upload successful"></p><p> <img src="/images/pasted-26.png" alt="upload successful"></p><p> <img src="/images/pasted-24.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之SDS</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</id>
    <published>2022-02-06T12:13:00.000Z</published>
    <updated>2022-02-06T12:36:06.134Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：</p><p>1、可以通过len-free以常数阶获取字符串长度</p><p>2、可以通过free字段避免缓冲区出现溢出的情况</p><p>3、同时也减少字符串修改时，内存重新分配的次数，其具体实现是通过预先分配内存（即当追加字符串之后，字符串小于1MB，会多分配一倍的空间）和懒惰回收（即当字符串变短之后，不会立即回收那一部分空间，而是作为临时空间供后续字符串扩增做优化）</p><p>4、可以保存二进制安全的数据</p><p> <img src="/images/pasted-27.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：&lt;/p&gt;
&lt;p&gt;1</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>枚举单例模式如何防止反射和反序列化</title>
    <link href="http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-01-27T11:08:00.000Z</published>
    <updated>2022-01-27T11:16:11.794Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p><p>2、枚举单例在创建时不存在并发问题：</p><pre><code>枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的</code></pre><p>2、反序列化：</p><pre><code>Java对枚举的序列化作了规定，在序列化时，仅将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象。枚举在序列化和反序列化时，并不会调用构造方法，这就防止了反序列化导致的单例破坏的问题。</code></pre><p>3、反射：</p><pre><code>反射在通过newInstance创建对象时，会检查这个类是否是枚举类，如果是，会抛出异常java.lang.IllegalArgumentException: Cannot reflectively create enum objects，表示反射创建对象失败。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;2、枚举单例在创建时不存在并发问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的
&lt;/c</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单利模式防止反射创建新的实例</title>
    <link href="http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-01-27T09:47:00.000Z</published>
    <updated>2022-01-27T09:49:12.324Z</updated>
    
    <content type="html"><![CDATA[<p>方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类</p><p>方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类&lt;/p&gt;
&lt;p&gt;方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</title>
    <link href="http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/</id>
    <published>2022-01-27T09:40:00.000Z</published>
    <updated>2022-01-27T09:47:09.071Z</updated>
    
    <content type="html"><![CDATA[<p>在类中添加如下方法<br> <img src="/images/pasted-23.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在类中添加如下方法&lt;br&gt; &lt;img src=&quot;/images/pasted-23.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis开发运维实践指南笔记</title>
    <link href="http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-26T14:10:01.000Z</published>
    <updated>2022-01-26T14:25:32.547Z</updated>
    
    <content type="html"><![CDATA[<p>1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。</p><p>2、<img src="/images/pasted-17.png" alt="upload successful"></p><p> 3、列出key：</p><p> <img src="/images/pasted-18.png" alt="upload successful"></p><p> 渐进的遍历整个数据库：keys命令会一次性遍历整个数据库获取与之匹配的键，当数据库包含得键值越来越多，这个命令会愈来愈慢，因此，可以用scan命令渐进的，分多次遍历整个数据库</p><p> <img src="/images/pasted-19.png" alt="upload successful"></p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>4、<br> <img src="/images/pasted-21.png" alt="upload successful"></p><p>5、</p><p> <img src="/images/pasted-22.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。&lt;/p&gt;
&lt;p&gt;2、&lt;img src=&quot;/images/pasted-17.png&quot; alt=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>交替打印输出</title>
    <link href="http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/</id>
    <published>2022-01-26T12:59:00.000Z</published>
    <updated>2022-01-26T13:00:45.447Z</updated>
    
    <content type="html"><![CDATA[<p> 三个线程交替打印输出</p><pre><code>public class AlternateOutput &#123;    public static void main(String[] args) &#123;//        Test1 test1 = new Test1();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(1);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(2);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(3);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        Test2 test2 = new Test2();//        Thread t1 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;a&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        Thread t2 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;b&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        Thread t3 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;c&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        test2.setThreads(t1,t2,t3);//        test2.start();        Test3 test3 = new Test3();        Condition condition1 = test3.newCondition();        Condition condition2 = test3.newCondition();        Condition condition3 = test3.newCondition();        new Thread(()-&gt;&#123;            test3.print(&quot;a&quot;,condition1,condition2);        &#125;).start();        new Thread(()-&gt;&#123;            test3.print(&quot;b&quot;,condition2,condition3);        &#125;).start();        new Thread(()-&gt;&#123;            test3.print(&quot;c&quot;,condition3,condition1);        &#125;).start();        test3.start(condition1);    &#125;&#125;class Test1&#123;    private Integer flag = 1;    private Integer num = 10;    public void print(int curFlag) throws InterruptedException &#123;        for (int i=0; i&lt;num; ++i)&#123;            synchronized (this)&#123;                while (this.flag != curFlag)&#123;                    this.wait();                &#125;                System.out.println(curFlag);                this.flag = curFlag % 3 + 1;                this.notifyAll();            &#125;        &#125;    &#125;&#125;class Test2&#123;    private Thread[] threads;    private Integer num = 10;    public Test2(Thread... threads) &#123;        this.threads = threads;    &#125;    public void setThreads(Thread... threads) &#123;        this.threads = threads;    &#125;    public void print(String s) throws InterruptedException &#123;       for (int i=0;i&lt;num;++i)&#123;           LockSupport.park();           System.out.println(s);           LockSupport.unpark(getNextThread());       &#125;    &#125;    public Thread getNextThread()&#123;        int size = threads.length;        Thread cur = Thread.currentThread();        for (int i=0;i&lt;size;++i)&#123;            if (cur == threads[i])&#123;                return threads[(i + 1) % size];            &#125;        &#125;        return null;    &#125;    public void start() &#123;        for (Thread thread: threads)&#123;            thread.start();        &#125;        LockSupport.unpark(threads[0]);    &#125;&#125;class Test3 extends ReentrantLock&#123;    private int num = 10;    public void start(Condition condition)&#123;        this.lock();        try &#123;            condition.signal();        &#125;finally &#123;            this.unlock();        &#125;    &#125;    public void print(String s, Condition cur,Condition next)&#123;        for (int i=0;i&lt;num;++i)&#123;            this.lock();            try&#123;                cur.await();                System.out.println(s);                next.signal();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                this.unlock();            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 三个线程交替打印输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AlternateOutput &amp;#123;

    public static void main(String[] args) &amp;#123;
//        Test1 test1 =</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized锁静态变量Integer</title>
    <link href="http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/"/>
    <id>http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/</id>
    <published>2022-01-25T02:18:00.000Z</published>
    <updated>2022-01-25T02:22:28.673Z</updated>
    
    <content type="html"><![CDATA[<p>当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128~127之间是有效的，因为存在Integer缓存问题）。</p><pre><code>public class Main &#123;    private static Integer i = 0;    public static void main(String[] args) throws InterruptedException &#123;        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();        for (int j = 0; j &lt; 2; j++) &#123;            Thread thread = new Thread(() -&gt; &#123;                for (int k = 0; k &lt; 127; k++) &#123;                    synchronized (i) &#123;                        i++;                    &#125;                &#125;            &#125;, &quot;&quot; + j);            list.add(thread);        &#125;        list.stream().forEach(t -&gt; t.start());        list.stream().forEach(t -&gt; &#123;            try &#123;                t.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        System.out.println(i);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="synchronized" scheme="http://example.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>终止模式之两阶段终止模式（Interrupt）</title>
    <link href="http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-24T11:10:00.000Z</published>
    <updated>2022-01-24T11:20:45.418Z</updated>
    
    <content type="html"><![CDATA[<p>Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。<br>（如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛InterruptedException，并清除 打断标记如果打断的正在运行的线程，则会设置打断标记 ；park的线程被打断，也会设置 打断标记）</p><p> <img src="/images/pasted-16.png" alt="upload successful"></p><pre><code> public class TPTInterrupt &#123;public static void main(String[] args) throws InterruptedException &#123;    TPTInterrupt tptInterrupt = new TPTInterrupt();    tptInterrupt.start();    Thread.sleep(2000);    tptInterrupt.stop();&#125;private Thread thread;public void start()&#123;    thread = new Thread(()-&gt;&#123;        while (true)&#123;            Thread thread = Thread.currentThread();            if (thread.isInterrupted())&#123;                System.out.println(&quot;料理后事...&quot;);                break;            &#125;            try &#123;                Thread.sleep(1000);                System.out.println(&quot;运行中...&quot;);            &#125; catch (InterruptedException e) &#123;                // 标记打断                e.printStackTrace();                thread.interrupt();            &#125;        &#125;    &#125;);    thread.start();&#125;public void stop()&#123;    thread.interrupt();&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。&lt;br&gt;（如果被打断线程正在 sleep，wait，join 会导致</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/juc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="终止模式" scheme="http://example.com/tags/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>创建线程的方式</title>
    <link href="http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2022-01-24T11:02:00.000Z</published>
    <updated>2022-01-24T11:06:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>1、创建Thread对象</p><p> <img src="/images/pasted-13.png" alt="upload successful"></p><p> 2、使用Runnable配合Thread使用</p><p> <img src="/images/pasted-14.png" alt="upload successful"></p><p> 3、FutureTask配合Callable和Thread使用</p><p> <img src="/images/pasted-15.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、创建Thread对象&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-13.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 2、使用Runnable配合Thread使用&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/p</summary>
      
    
    
    
    
    <category term="创建线程" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么要自定义类型加载器？</title>
    <link href="http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/"/>
    <id>http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/</id>
    <published>2022-01-23T11:19:00.000Z</published>
    <updated>2022-01-23T11:20:52.309Z</updated>
    
    <content type="html"><![CDATA[<p>1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。(类的仲裁 –&gt; 类冲突)</p><p>2、修改类加载的方式：类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载</p><p>3、扩展加载源：比如从数据库、网络、甚至是电视机机顶盒进行加载</p><p>4、防止源码泄露：Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
  </entry>
  
  <entry>
    <title>沙箱安全机制</title>
    <link href="http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2022-01-23T11:16:00.000Z</published>
    <updated>2022-01-23T11:19:08.964Z</updated>
    
    <content type="html"><![CDATA[<p>沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
  </entry>
  
  <entry>
    <title>判定一个类型是否属于&quot;不再被使用的类&quot;的条件</title>
    <link href="http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/"/>
    <id>http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/</id>
    <published>2022-01-23T09:49:00.000Z</published>
    <updated>2022-01-23T09:50:58.551Z</updated>
    
    <content type="html"><![CDATA[<p>1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象</p><p>2、加载该类的类加载器被回收</p><p>3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象&lt;/p&gt;
&lt;p&gt;2、加载该类的类加载器被回收&lt;/p&gt;
&lt;p&gt;3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法&lt;/p&gt;
</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    <category term="jvm" scheme="http://example.com/categories/jv-m/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>类的初始化情况：主动使用vs被动使用</title>
    <link href="http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-23T09:31:00.000Z</published>
    <updated>2022-01-23T09:43:56.451Z</updated>
    
    <content type="html"><![CDATA[<p>主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。</p><p>以下使用被认为是主动使用：<br>1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化</p><p>2、当调用类的静态方法时，即当使用了字节码 invokestatic 指令</p><p>3、当使用类、接口的静态字段时(final 修饰特殊考虑)，比如，使用 getstatic 或者 putsttic 指令。(对应访问变量、赋值变量操作)</p><p>4、当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”)</p><p>5、当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</p><p>6、如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</p><p>7、当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类</p><p>8、当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。(涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类)</p><p>注意：<br>1、当Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口在初始化一个类时，并不会先初始化它所实现的接口<br>在初始化一个接口时，并不会先初始化它的父接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化<br>2、JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[]) 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化</p><p>被动使用：除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p><p>1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</p><p>2、当通过子类引用父类的静态变量，不会导致子类初始化</p><p>3、通过数组定义类引用，不会触发此类的初始化</p><p>4、引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</p><p>5、调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。&lt;/p&gt;
&lt;p&gt;以下使用被认为是主动使用：&lt;br&gt;1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化&lt;/p&gt;
&lt;p&gt;2、当调用类的静态方法时，即当使用了字节码 i</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
    <category term="类初始化：主动使用与被动使用" scheme="http://example.com/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>类的加载过程</title>
    <link href="http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2022-01-23T07:55:00.000Z</published>
    <updated>2022-01-23T08:54:30.085Z</updated>
    
    <content type="html"><![CDATA[<p>类的加载，我的理解就是将类的二进制字节码文件加载到内存中，并通过解析字节码中的常量池、类字段、类方法等信息，在jvm方法区中构建出该类的模板，并在堆区创建一个对象实例作为方法区这个类的各种数据访问入口，在jvm运行期间能够通过这个类的模板信息来调用类的静态变量、方法等。<br>其加载过程的话，主要分为加载、链接（验证、准备、解析）、初始化三个步骤。</p><p>1、首先加载，就是查找类的全限定类名，将类的二进制字节码文件加载到jvm的内存中，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，并为之在堆区创建一个实例对象，作为方法区这个类的数据访问入口。当然，在加载前还需要进行验证操作，即检查字节码文件格式，看是否遵循jvm的规范。比如是否以魔数开头等。验证通过后，该类的二进制信息便会被加载到内存。</p><p>2、加载到方法区后需要验证，即检查类的语义、字节码验证、符号引用验证，看是否符合规范。</p><p>3、当验证完毕之后，就开始准备阶段，这一步主要是对类的静态变量分配内存并附上默认值。（注意：final修饰的静态变量在编译阶段就会分配，准备阶段是显示赋值，并且此阶段也不会为实例变量分配初始化）</p><p>4、然后便是解析阶段，即将符号引用转变为直接引用，得到类、字段、方法等在内存中的指针或者偏移量。</p><p>5、最后便是初始化，这个阶段主要是为类的静态变量进行显示赋值。即执行类构造器cinit方法。即执行类变量的赋值动作和静态语句块(static{}块)，虚期机会保证在子类的<clinit>()方法执行之前, 父类的<clinit>()方法已经执行完毕。如果一个类中没有静态语句块,也没有对变量的赋值操作, 那么编译器可以不为这个类生成<clinit>()方法。</p><p>需要注意的是：接口与类不同的是, 执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时, 父接口才会被初始化。 另外, 接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。另外，虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()法,其他线程部需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作, 那就可能造成多个进程阻塞, 在实际应用中这种阻塞往往是隐蔽的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;类的加载，我的理解就是将类的二进制字节码文件加载到内存中，并通过解析字节码中的常量池、类字段、类方法等信息，在jvm方法区中构建出该类的模板，并在堆区创建一个对象实例作为方法区这个类的各种数据访问入口，在jvm运行期间能够通过这个类的模板信息来调用类的静态变量、方法等。&lt;b</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
    <category term="类的加载过程" scheme="http://example.com/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于集合类中的modCount++</title>
    <link href="http://example.com/2022/01/21/%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%E7%9A%84modCount/"/>
    <id>http://example.com/2022/01/21/%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%E7%9A%84modCount/</id>
    <published>2022-01-21T06:45:00.000Z</published>
    <updated>2022-01-21T07:17:15.741Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，直接看源码注释讲解<br> <img src="/images/pasted-10.png" alt="upload successful"><br> 由上图可知，该字段目的在于记录集合结构被修改的次数（增、删、改），该字段被迭代器所使用，当对集合进行迭代遍历时，防止数据发生改变引起错误。因此，当我们使用迭代器时，如果该值被改了，就会触发fast-fail机制，抛出异常ConcurrentModificationExceptions。</p><p> <img src="/images/pasted-11.png" alt="upload successful"></p><p> <img src="/images/pasted-12.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;话不多说，直接看源码注释讲解&lt;br&gt; &lt;img src=&quot;/images/pasted-10.png&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt; 由上图可知，该字段目的在于记录集合结构被修改的次数（增、删、改），该字段被迭代器所使用，当对集合进行迭代遍历时，</summary>
      
    
    
    
    <category term="集合" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/"/>
    
    <category term="java" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/java/"/>
    
    
    <category term="ArrayList" scheme="http://example.com/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>HashMap1.7</title>
    <link href="http://example.com/2022/01/18/HashMap/"/>
    <id>http://example.com/2022/01/18/HashMap/</id>
    <published>2022-01-18T11:27:00.000Z</published>
    <updated>2022-01-18T11:53:34.793Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap1.7底层由数组+链表实现，提供的无参构造方法默认数组容量是16，加载因子是0.75，临界值为16 * 0.75 = 12，当到了临界值则进行扩容。</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>你也可以通过有参构造方法指定容量和加载因子。</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><p>注意，不管有参无参此时都还未初始化数组，只是定义了数组容量。当我们第一次put往hashmap的放数据的时候才会初始化</p><p> <img src="/images/pasted-6.png" alt="upload successful"></p><p>而此时初始化会根据我们最初的容量大小进行初始化，大小为大于等于当前容量的2的幂。<br> <img src="/images/pasted-7.png" alt="upload successful"></p><p> <img src="/images/pasted-8.png" alt="upload successful"></p><p> <img src="/images/pasted-9.png" alt="upload successful"></p><p> 然后便是计算hash值，根据hash值得到数组下标，根据下标到指定位置，如果发送hash冲突则通过拉链法，将冲突元素头插进链表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HashMap1.7底层由数组+链表实现，提供的无参构造方法默认数组容量是16，加载因子是0.75，临界值为16 * 0.75 = 12，当到了临界值则进行扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/pasted-4.png&quot; alt=&quot;upload succ</summary>
      
    
    
    
    <category term="java基础" scheme="http://example.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
    <category term="HashMap" scheme="http://example.com/tags/HashMap/"/>
    
  </entry>
  
</feed>
