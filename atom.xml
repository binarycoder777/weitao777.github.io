<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-11T14:09:54.174Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Security认证过程</title>
    <link href="http://example.com/2022/03/11/Spring-Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2022/03/11/Spring-Security%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</id>
    <published>2022-03-11T13:54:00.000Z</published>
    <updated>2022-03-11T14:09:54.174Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Spring Security的核心就是认证和授权，但是具体它是如何进行认证和授权的呢？下面让我们来聊聊Spring Security的认证过程，具体步骤如下图所示：</p><p> <img src="/images/pasted-146.png" alt="upload successful"></p><p> 在开始之前，我们需要了解一下如下类：</p><p>AuthenticationManager核心验证器，该对象提供了认证方法的入口，接收一个Authentiation对象作为参数。</p><pre><code>      public interface AuthenticationManager &#123;        Authentication authenticate(Authentication authentication)                throws AuthenticationException;    &#125;    </code></pre><p>ProviderManager：它是 AuthenticationManager 的一个实现类，提供了基本的认证逻辑和方法；它包含了一个 List<AuthenticationProvider> 对象，通过 AuthenticationProvider 接口来扩展出不同的认证提供者(当Spring Security默认提供的实现类不能满足需求的时候可以扩展AuthenticationProvider 覆盖supports(Class&lt;?&gt; authentication)方法)；</p><p>具体验证逻辑：</p><p>AuthenticationManager 接收 Authentication 对象作为参数，并通过 authenticate(Authentication) 方法对其进行验证；AuthenticationProvider实现类用来支撑对 Authentication 对象的验证动作；UsernamePasswordAuthenticationToken实现了 Authentication主要是将用户输入的用户名和密码进行封装，并供给 AuthenticationManager 进行验证；验证完成以后将返回一个认证成功的 Authentication 对象；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道Spring Security的核心就是认证和授权，但是具体它是如何进行认证和授权的呢？下面让我们来聊聊Spring Security的认证过程，具体步骤如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-146.png&quot; alt=&quot;up</summary>
      
    
    
    
    <category term="Spring Security" scheme="http://example.com/categories/Spring-Security/"/>
    
    
    <category term="认证" scheme="http://example.com/tags/%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Spring的AOP是在哪个阶段创建的动态代理？</title>
    <link href="http://example.com/2022/03/10/Spring%E7%9A%84AOP%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F/"/>
    <id>http://example.com/2022/03/10/Spring%E7%9A%84AOP%E6%98%AF%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F/</id>
    <published>2022-03-10T00:44:00.000Z</published>
    <updated>2022-03-10T00:47:08.519Z</updated>
    
    <content type="html"><![CDATA[<p>1、正常情况下会在bean的生命周期“初始化”后，通过BeanPostProcessor.postProcessAfterInitialization创建AOP的动态代理</p><p>2、特殊情况下，即存在循环依赖的时候，Bean会在生命周期的“属性注入”时，通过MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition创建aop动态代理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、正常情况下会在bean的生命周期“初始化”后，通过BeanPostProcessor.postProcessAfterInitialization创建AOP的动态代理&lt;/p&gt;
&lt;p&gt;2、特殊情况下，即存在循环依赖的时候，Bean会在生命周期的“属性注入”时，通过Merg</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>什么情况下AOP会失效,怎么解决？</title>
    <link href="http://example.com/2022/03/10/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8BAOP%E4%BC%9A%E5%A4%B1%E6%95%88-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/"/>
    <id>http://example.com/2022/03/10/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8BAOP%E4%BC%9A%E5%A4%B1%E6%95%88-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</id>
    <published>2022-03-10T00:37:00.000Z</published>
    <updated>2022-03-10T00:42:55.549Z</updated>
    
    <content type="html"><![CDATA[<p>1、方法是private</p><p>2、目标类没有配置为Bean</p><p>3、切点表达式没有写正确</p><p>4、jdk动态代理下内部调用不会触发AOP（</p><p>原因：</p><p>内部进行自调用，是走的实例对象，而不是代理对象。</p><p>解决：</p><p>1、在本类中自动注入当前的bean</p><p>2、@EnableAspectJAutoProxy(exposProxy = true)</p><p>设置暴露当前代理对象到本地线程，可以通过AopContent.currentProxy()拿到当前的动态代理对象。<br>）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、方法是private&lt;/p&gt;
&lt;p&gt;2、目标类没有配置为Bean&lt;/p&gt;
&lt;p&gt;3、切点表达式没有写正确&lt;/p&gt;
&lt;p&gt;4、jdk动态代理下内部调用不会触发AOP（&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;内部进行自调用，是走的实例对象，而不是代理对象。&lt;/p&gt;
&lt;p&gt;解决</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>AOP有几种实现方式 </title>
    <link href="http://example.com/2022/03/10/AOP%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/03/10/AOP%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2022-03-10T00:34:00.000Z</published>
    <updated>2022-03-10T00:36:27.821Z</updated>
    
    <content type="html"><![CDATA[<p>1、Spring 1.2 基于接口的配置：最早的 Spring AOP 是完全基于几个接口的，想看源码的同学可以从这里起步。</p><p>2、Spring 2.0 schema-based 配置：Spring 2.0 以后使用 XML 的方式来配置，使用 命名空间 <aop ></aop></p><p>3、Spring 2.0 @AspectJ 配置：使用注解的方式来配置，这种方式感觉是最方便的，还有，这里虽然叫<br>做 @AspectJ，但是这个和 AspectJ 其实没啥关系。</p><p>4、AspectJ  方式，这种方式其实和Spring没有关系，采用AspectJ 进行动态织入的方式实现AOP，需要用<br>AspectJ 单独编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、Spring 1.2 基于接口的配置：最早的 Spring AOP 是完全基于几个接口的，想看源码的同学可以从这里起步。&lt;/p&gt;
&lt;p&gt;2、Spring 2.0 schema-based 配置：Spring 2.0 以后使用 XML 的方式来配置，使用 命名空间 &lt;ao</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring的AOP通知执行顺序</title>
    <link href="http://example.com/2022/03/09/Spring%E7%9A%84AOP%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2022/03/09/Spring%E7%9A%84AOP%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-03-09T13:25:00.000Z</published>
    <updated>2022-03-09T13:28:17.294Z</updated>
    
    <content type="html"><![CDATA[<p>执行顺序：</p><pre><code>5.2.7之前：1、正常执行：@Before­­­&gt;方法­­­­&gt;@After­­­&gt;@AfterReturning2、异常执行：@Before­­­&gt;方法­­­­&gt;@After­­­&gt;@AfterThrowing5.2.7之后：1、正常执行：@Before­­­&gt;方法­­­­&gt;@AfterReturning­­­&gt;@After2、异常执行：@Before­­­&gt;方法­­­­&gt;@AfterThrowing­­­&gt;@After</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;执行顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.2.7之前：

1、正常执行：@Before­­­&amp;gt;方法­­­­&amp;gt;@After­­­&amp;gt;@AfterReturning
2、异常执行：@Before­­­&amp;gt;方法­­­­&amp;gt;@After­­­&amp;gt;@A</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>说说@Import可以有几种用法？</title>
    <link href="http://example.com/2022/03/09/%E8%AF%B4%E8%AF%B4-Import%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E8%AF%B4%E8%AF%B4-Import%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/</id>
    <published>2022-03-09T10:41:00.000Z</published>
    <updated>2022-03-09T10:43:33.973Z</updated>
    
    <content type="html"><![CDATA[<p>1、 直接指定类 （如果配置类会按配置类正常解析、  如果是个普通类就会解析成Bean)</p><p>2、 通过ImportSelector 可以一次性注册多个，返回一个string[]  每一个值就是类的完整类路径</p><p>3、 通过DeferredImportSelector可以一次性注册多个，返回一个string[]  每一个值就是类的完整类路径</p><pre><code>区别：DeferredImportSelector 顺序靠后</code></pre><p>4、 通过ImportBeanDefinitionRegistrar 可以一次性注册多个，通过BeanDefinitionRegistry来动态注册BeanDefintion</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、 直接指定类 （如果配置类会按配置类正常解析、  如果是个普通类就会解析成Bean)&lt;/p&gt;
&lt;p&gt;2、 通过ImportSelector 可以一次性注册多个，返回一个string[]  每一个值就是类的完整类路径&lt;/p&gt;
&lt;p&gt;3、 通过DeferredImportS</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>如何让自动注入找到多个依赖Bean时不报错</title>
    <link href="http://example.com/2022/03/09/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E6%89%BE%E5%88%B0%E5%A4%9A%E4%B8%AA%E4%BE%9D%E8%B5%96Bean%E6%97%B6%E4%B8%8D%E6%8A%A5%E9%94%99/"/>
    <id>http://example.com/2022/03/09/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E6%89%BE%E5%88%B0%E5%A4%9A%E4%B8%AA%E4%BE%9D%E8%B5%96Bean%E6%97%B6%E4%B8%8D%E6%8A%A5%E9%94%99/</id>
    <published>2022-03-09T10:36:00.000Z</published>
    <updated>2022-03-09T10:39:06.070Z</updated>
    
    <content type="html"><![CDATA[<p>自动注入找到多个依赖Bean时，@primary可以指定注入哪一个。</p><p>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</p><p>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用</p><p>@Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动注入找到多个依赖Bean时，@primary可以指定注入哪一个。&lt;/p&gt;
&lt;p&gt;@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常&lt;/p&gt;
&lt;p&gt;@Autowired 默认按类型装配，如果我们想使用按名</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>说一说@Autowired和@Resource之间的区别</title>
    <link href="http://example.com/2022/03/09/%E8%AF%B4%E4%B8%80%E8%AF%B4-Autowired%E5%92%8C-Resource%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/09/%E8%AF%B4%E4%B8%80%E8%AF%B4-Autowired%E5%92%8C-Resource%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-09T10:31:00.000Z</published>
    <updated>2022-03-09T10:35:41.053Z</updated>
    
    <content type="html"><![CDATA[<p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><p>@Autowired默认是按照类型装配注入的（按照名称匹配需要@Qualifier），默认情况下它要求依赖对象必须存在（可以设置它required属性为<br>false）。</p><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@Autowired可用于：构造函数、成员变量、Setter方法&lt;/p&gt;
&lt;p&gt;@Autowired和@Resource之间的区别&lt;/p&gt;
&lt;p&gt;@Autowired默认是按照类型装配注入的（按照名称匹配需要@Qualifier），默认情况下它要求依赖对象必须存在（可以设置</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使用@Autowired注解自动装配的过程是怎样的？</title>
    <link href="http://example.com/2022/03/09/%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/</id>
    <published>2022-03-09T10:11:00.000Z</published>
    <updated>2022-03-09T10:20:50.684Z</updated>
    
    <content type="html"><![CDATA[<p>记住：@Autowired 通过Bean的后置处理器进行解析的</p><p>1、 在创建一个Spring上下文的时候再构造函数中进行注册AutowiredAnnotationBeanPostProcessor</p><p>2、 在Bean的创建过程中进行解析</p><pre><code>2.1、 在实例化后预解析（解析@Autowired标注的属性、方法   比如：把属性的类型、名称、属性所在的类..... 元数据缓存起）2.2、 在属性注入真正的解析（拿到上一步缓存的元数据 去ioc容器帮进行查找，并且返回注入）</code></pre><p>a. 首先根据预解析的元数据拿到 类型去容器中进行查找 <br>（如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；<br>如果查询的结果不止一个，那么@Autowired会根据名称来查找；<br>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。）</p><p> <img src="/images/pasted-144.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记住：@Autowired 通过Bean的后置处理器进行解析的&lt;/p&gt;
&lt;p&gt;1、 在创建一个Spring上下文的时候再构造函数中进行注册AutowiredAnnotationBeanPostProcessor&lt;/p&gt;
&lt;p&gt;2、 在Bean的创建过程中进行解析&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>配置类@Configuration的作用解析原理</title>
    <link href="http://example.com/2022/03/09/%E9%85%8D%E7%BD%AE%E7%B1%BB-Configuration%E7%9A%84%E4%BD%9C%E7%94%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/03/09/%E9%85%8D%E7%BD%AE%E7%B1%BB-Configuration%E7%9A%84%E4%BD%9C%E7%94%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-09T09:00:00.000Z</published>
    <updated>2022-03-09T10:09:42.110Z</updated>
    
    <content type="html"><![CDATA[<p>1、@Configuration用来代替xml配置方式spring.xml配置文件 <bean></p><p>2、没有@Configuration也是可以配置@Bean</p><p>3、 加了@Configuration会为配置类创建cglib动态代理（保证配置类@Bean方法调用Bean的单例），@Bean方法的调用就会通过容器.getBean进行获取</p><p>原理：</p><p>1、创建Spring上下文的时候会注册一个解析配置的处理器ConfigurationClassPostProcessor（实现BeanFactoryPostProcessor和<br>BeanDefinitionRegistryPostProcessor)</p><p>2、在调用invokeBeanFactoryPostProcessor，就会去调用<br>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry进行解析配置（解析配置类说白就是去解析各种注解<br>(@Bean @Configuration@Import @Component …  就是注册BeanDefinition)</p><p>3、ConfigurationClassPostProcessor.postProcessBeanFactory去创建cglib动态代理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、@Configuration用来代替xml配置方式spring.xml配置文件 &lt;bean&gt;&lt;/p&gt;
&lt;p&gt;2、没有@Configuration也是可以配置@Bean&lt;/p&gt;
&lt;p&gt;3、 加了@Configuration会为配置类创建cglib动态代理（保证配置类@Be</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>对于@Bean之间的方法调用是怎么保证单例的？</title>
    <link href="http://example.com/2022/03/09/%E5%AF%B9%E4%BA%8E@Bean%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8D%95%E4%BE%8B%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E5%AF%B9%E4%BA%8E@Bean%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8D%95%E4%BE%8B%E7%9A%84%EF%BC%9F/</id>
    <published>2022-03-09T08:44:00.000Z</published>
    <updated>2022-03-09T08:57:45.869Z</updated>
    
    <content type="html"><![CDATA[<p>如果希望@bean方法返回的对象是单例，需要在类上加上@Configuration注解。</p><p>原因：Spring会使用invokeBeanFactoryPostProcessor 在内置BeanFactoryPostProcessor中使用CGLib生成动态代理，当@Bean方法进行互调时， 则会通过CGLIB进行增强，通过调用的方法名作为bean的名称去ioc容器中获取，进而保证了@Bean方法的单例 。</p><p>换句话说：被@Configuration修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被@Bean 修饰的方法，默认情况（bean为单例）下确保这些方法只被调用一次，从而确保这些bean是同一个bean，即单例的<br>。@Configuration修饰的类有cglib代理效果，默认添加的bean都为单例</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果希望@bean方法返回的对象是单例，需要在类上加上@Configuration注解。&lt;/p&gt;
&lt;p&gt;原因：Spring会使用invokeBeanFactoryPostProcessor 在内置BeanFactoryPostProcessor中使用CGLib生成动态代理，</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>要将一个第三方的类配成为Bean有哪些方式？</title>
    <link href="http://example.com/2022/03/09/%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E7%B1%BB%E9%85%8D%E6%88%90%E4%B8%BABean%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E7%B1%BB%E9%85%8D%E6%88%90%E4%B8%BABean%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F/</id>
    <published>2022-03-09T08:39:00.000Z</published>
    <updated>2022-03-09T08:42:14.407Z</updated>
    
    <content type="html"><![CDATA[<p>1、通过@bean注解（搭配@Configurtion）</p><p>2、通过@import注解</p><p>3、通过Spring的拓展接口BeanDefinitionRegistryPostProcessor</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、通过@bean注解（搭配@Configurtion）&lt;/p&gt;
&lt;p&gt;2、通过@import注解&lt;/p&gt;
&lt;p&gt;3、通过Spring的拓展接口BeanDefinitionRegistryPostProcessor&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>为什么@ComponentScan 不设置basePackage也会扫描？</title>
    <link href="http://example.com/2022/03/09/%E4%B8%BA%E4%BB%80%E4%B9%88-ComponentScan-%E4%B8%8D%E8%AE%BE%E7%BD%AEbasePackage%E4%B9%9F%E4%BC%9A%E6%89%AB%E6%8F%8F%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E4%B8%BA%E4%BB%80%E4%B9%88-ComponentScan-%E4%B8%8D%E8%AE%BE%E7%BD%AEbasePackage%E4%B9%9F%E4%BC%9A%E6%89%AB%E6%8F%8F%EF%BC%9F/</id>
    <published>2022-03-09T08:36:00.000Z</published>
    <updated>2022-03-09T08:38:51.082Z</updated>
    
    <content type="html"><![CDATA[<p>@componentScan注解不设置basePackage默认会将你的类所在的包的地址作为扫描包的地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@componentScan注解不设置basePackage默认会将你的类所在的包的地址作为扫描包的地址&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring是如何解决循环依赖问题的？</title>
    <link href="http://example.com/2022/03/09/Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F/</id>
    <published>2022-03-09T02:54:00.000Z</published>
    <updated>2022-03-09T03:11:12.718Z</updated>
    
    <content type="html"><![CDATA[<p>什么是循环依赖问题？</p><p>类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。（比如A类依赖了B类，B类依赖了C类，而最后C类又依赖了A类，这样就形成了循环依赖问题。）</p><p>循环依赖问题在Spring中主要有三种情况：</p><p>1、通过构造方法进行依赖注入时产生的循环依赖问题。</p><p>2、通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</p><p>3、通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</p><p>注意：在Spring中，只有【第三种方式】的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。</p><p>因为第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。</p><p>第二种setter方法&amp;&amp;多例的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。</p><p>如何解决循环依赖问题？</p><p> <img src="/images/pasted-138.png" alt="upload successful"></p><p> Spring中有三个缓存，用于存储单例的Bean实例，这三个缓存是彼此互斥的，不会针对同一个Bean的实例同时存储。</p><p> 如果调用getBean，则需要从三个缓存中依次获取指定的Bean实例。读取顺序依次是一级缓存–&gt;二级缓存–&gt;三级缓存</p><p> <img src="/images/pasted-139.png" alt="upload successful"></p><p> 一级缓存：Map&lt;String, Object&gt; singletonObjects<br>第一级缓存的作用？</p><p>用于存储单例模式下创建的Bean实例（已经创建完毕）。<br>该缓存是对外使用的，指的就是使用Spring框架的程序员。</p><p>存储什么数据？</p><p>K：bean的名称</p><p>V：bean的实例对象（有代理对象则指的是代理对象，已经创建完毕）</p><p>第二级缓存：Map&lt;String, Object&gt; earlySingletonObjects第二级缓存的作用？</p><p>用于存储单例模式下创建的Bean实例（该Bean被提前暴露的引用,该Bean还在创建中）。<br>该缓存是对内使用的，指的就是Spring框架内部逻辑使用该缓存。<br>为了解决第一个classA引用最终如何替换为代理对象的问题（如果有代理对象）</p><p>存储什么数据？</p><p>K：bean的名称</p><p>V：bean的实例对象（有代理对象则指的是代理对象，该Bean还在创建中）</p><p>第三级缓存：Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories第三级缓存的作用？</p><p>通过ObjectFactory对象来存储单例模式下提前暴露的Bean实例的引用（正在创建中）。<br>该缓存是对内使用的，指的就是Spring框架内部逻辑使用该缓存。<br>此缓存是解决循环依赖最大的功臣</p><p>存储什么数据？</p><p>K：bean的名称</p><p>V：ObjectFactory，该对象持有提前暴露的bean的引用</p><p> <img src="/images/pasted-140.png" alt="upload successful"></p><p>为什么第三级缓存要使用ObjectFactory？需要提前产生代理对象。</p><p> <img src="/images/pasted-141.png" alt="upload successful"><br>什么时候将Bean的引用提前暴露给第三级缓存的ObjectFactory持有？时机就是在第一步实例化之后，第二步依赖注入之前，完成此操作。</p><p> <img src="/images/pasted-142.png" alt="upload successful"></p><p>总结<br>以上就是Spring解决循环依赖的关键点！总结来说，就是要搞清楚以下几点：</p><p>搞清楚Spring三级缓存的作用？<br>搞清楚第三级缓存中ObjectFactory的作用？<br>搞清楚为什么需要第二级缓存？<br>搞清楚什么时候使用三级缓存（添加和查询操作）？<br>搞清楚什么时候使用二级缓存（添加和查询操作）？<br>当目标对象产生代理对象时，Spring容器中（第一级缓存）到底存储的是谁？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是循环依赖问题？&lt;/p&gt;
&lt;p&gt;类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。（比如A类依赖了B类，B类依赖了C类，而最后C类又依赖了A类，这样就形成了循环依赖问题。）&lt;/p&gt;
&lt;p&gt;循环依赖问题在Spring中主要有三种情况：&lt;/p&gt;
&lt;p&gt;1、通过构造</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="循环依赖" scheme="http://example.com/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP实现机制的一个小小陷阱</title>
    <link href="http://example.com/2022/03/08/Spring%20AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%99%B7%E9%98%B1/"/>
    <id>http://example.com/2022/03/08/Spring%20AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%99%B7%E9%98%B1/</id>
    <published>2022-03-08T12:36:00.000Z</published>
    <updated>2022-03-08T12:48:29.130Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Spring AOP采用代理模式实现，具体的横切逻辑会被添加到动态生成的代理对象中，只要调用的是目标对象的代理对象上的方法就可以保证目标对象的方法执行可以被拦截。</p><p>不过遗憾的是，代理模式的实现机制在处理方法调用的时序方面会给使用这种机制实现的AOP产品造成一个缺憾。在处理对象方法中，不管你如何添加横切逻辑，也不管添加多少横切逻辑，有一点是确定的，你最终需要调用目标对象的同一方法来执行最初所应以的方法逻辑。如果目标对象中原始方法调用依赖于其他对象，那没问题。我们可以为目标对象注入所依赖对象的代理，并且可以保证相应的Joinpoint被拦截并且织入相应横切逻辑。但是如果目标对象中的原始方法调用直接调用自身方法时，会导致出现问题</p><p> <img src="/images/pasted-133.png" alt="upload successful"></p><p> 在代理对象的method1执行经历了层层拦截后，最终会将调用转向目标对象上的method1，之后调用流程全部在走targetobject之上，当method1调用method2时，它调用targetobject的method2，而不是代理对象的method2，而针对method2的横切逻辑是织入到代理对象上的，因此method1中调用的method2没有被成功拦截。</p><p> 好在Spring AOP提供了AopContent来公开当前目标对象的代理对象，我们只要在目标对象中使用AopContent.currentProxy()就可以获取当前目标对象所对应的代理对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道Spring AOP采用代理模式实现，具体的横切逻辑会被添加到动态生成的代理对象中，只要调用的是目标对象的代理对象上的方法就可以保证目标对象的方法执行可以被拦截。&lt;/p&gt;
&lt;p&gt;不过遗憾的是，代理模式的实现机制在处理方法调用的时序方面会给使用这种机制实现的AOP产品</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP的常见应用案例</title>
    <link href="http://example.com/2022/03/08/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2022/03/08/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2022-03-08T11:26:00.000Z</published>
    <updated>2022-03-08T12:33:39.435Z</updated>
    
    <content type="html"><![CDATA[<p>1、异常处理：</p><p>通常将Error和RuntimeException及其子类称作非受检异常。（编译器不会对这些类型的异常进行编译期检查），而其他的则为受检异常（编写程序期间就应进行处理）。Fault Barrier即为对非受检异常的处理。</p><p>对于这些非受检异常的处理可以归并于溢出进行处理，而不是让他们散落到系统的各处。介于此，我们可以通过实现一个Aspect来处理，让其对系统中所有可能的falut情况进行统一的处理。而这个专职于处理Falut的Aspect即为Falut Barrier。</p><p>2、安全检查：</p><p>Filter是Servlet规范为我们提供的一种AOP支持。通过它我们可以为基于servlet的web应用添加相应的资源访问控制等等。但是，基于filter的web应用的资源访问控制仅仅是特定领域安全检查需求。而通过AOP，我们可以为任何类型的应用添加安全支持。（Spring Security则是基于Spring的一款强大的安全框架）</p><p>3、缓存：</p><p>AOP应用的另一个主要场景则是为系统透明地添加缓存支持。缓存可以在很大程度上提升系统性能。为了避免需要添加的缓存实现逻辑影响业务逻辑的实现，我们可以让缓存的实现独立于业务对象的实现外，将系统中的缓存需求通过AOP的Aspect进行封装，只在系统中某个点确切需要缓存的情况下才进行织入。（现在已经有许多现成的Caching产品实现，入EhCache、Redis等）</p><p>Spring Modules项目提供了对现有Caching产品的集成，这样可以通过外部声明的方式为系统中的Joinpoint加Caching支持。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、异常处理：&lt;/p&gt;
&lt;p&gt;通常将Error和RuntimeException及其子类称作非受检异常。（编译器不会对这些类型的异常进行编译期检查），而其他的则为受检异常（编写程序期间就应进行处理）。Fault Barrier即为对非受检异常的处理。&lt;/p&gt;
&lt;p&gt;对于这些</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="应用" scheme="http://example.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言程序经过预处理、编译、汇编和链接等各个阶段的变化情况</title>
    <link href="http://example.com/2022/03/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BB%8F%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AD%89%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5/"/>
    <id>http://example.com/2022/03/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BB%8F%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AD%89%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5/</id>
    <published>2022-03-08T07:59:00.000Z</published>
    <updated>2022-03-08T11:26:01.536Z</updated>
    
    <content type="html"><![CDATA[<p>编译过程概述：通常编译程序的过程分为词法分析、语法分析、语义分析、目目标代码生成4个阶段（如果编译器支持优化，还可以有中间代码生成和代码优化两个阶段）。</p><p> <img src="/images/pasted-132.png" alt="upload successful"></p><p>1、词法分析</p><p>此阶段的任务是从左到右一个字符一个字符地读入源程序，对构成源程序的字符进行扫描和分解，从而识别出一个个单词（逻辑上紧密相连的一组有集体含义的字符）。</p><p>2、语法分析</p><p>此阶段的任务是在词法分析的基础上将单词序列分解成各类语法短语（也称语法单位）可表示成语法树。</p><p>注：词法分析和语法分析本质上都是对源程序的结构进行分析。</p><p>3、语义分析</p><p>语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。</p><p>4、中间代码生成</p><p>“中间代码”是一种结构简单，含义明确的记号系统，这种记号系统可以设计为多种多样的形式，重要的设计原则为两点：一是容易生成；二是容易将它翻译成目标代码。很多编译程序采用了一种近似“三地址指令”的“四元式”中间代码。这种四元式的形式为：（运算符，运算对象1，运算对象2，结果）</p><p>5、代码优化</p><p>将中间代码进行变换或进行改造，目的：使生成的目标代码更为高效，即省时间和空间</p><p>6、目标代码生成</p><p>任务是把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译过程概述：通常编译程序的过程分为词法分析、语法分析、语义分析、目目标代码生成4个阶段（如果编译器支持优化，还可以有中间代码生成和代码优化两个阶段）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-132.png&quot; alt=&quot;upload succes</summary>
      
    
    
    
    <category term="编译原理" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="基础概念" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 一世</title>
    <link href="http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/"/>
    <id>http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/</id>
    <published>2022-03-07T12:03:00.000Z</published>
    <updated>2022-03-07T13:01:58.232Z</updated>
    
    <content type="html"><![CDATA[<p>AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint</p><p>Spring中以接口定义Pointcut作为其AOP框架中所有Pointcut的最顶级抽象，该接口定义了两个方法来捕获系统中相应的Joinpoint，并提供了一个TruePointcut类型实例。如果Pointcut类型为TruePointcut，默认会对系统中的所有对象，以及对象上所有被支持的Joinpoint进行匹配。</p><p> <img src="/images/pasted-129.png" alt="upload successful"></p><p> ClassFileter和MethodMatcher分别用于匹配将被执行织入操作的对象以及相应的方法。（重用不同级别的匹配定义，并且可以在不同或相同的级别上进行组合操作，或者强制让某个子类只覆写相应的方法）</p><p> <img src="/images/pasted-130.png" alt="upload successful"></p><p> Spring中各种advice实现全部遵循AOP ALLiance规定的接口。</p><p> <img src="/images/pasted-131.png" alt="upload successful"><br> advice实现了将被织入到Pointcut规定的Joinpoint处的横切逻辑。在Spring中，advice按照其自身实例能否在目标对象类的所有实例中共享这一标准，可以划分为两大类（per-class和per-instance）</p><p> per-class类型的advice：该类型可以在目标对象类的所有实例之间共享。这种类型的advice通常只提供方法拦截的功能。不会为目标对象类保存任何状态或添加新特性。除了上图没有列出的intriuduction类型的advice外，其余都属于pre-class。（如：BeforeAdvice、ThrowsAdvic、AfterReturningAdvice、AroundAdvice等）</p><p> per-instance类型的advice：introduction是唯一的一种per-instance型advice。其可以在不改目标类定义的情况下，为目标类添加新的属性和行为。</p><p> 当所有的Pointcut和advice准备好之后，就可以将其装入Aspect。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint&lt;/p&gt;
&lt;p&gt;Spring中以接口定义Pointcut作为其AOP框</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP的实现机制</title>
    <link href="http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-07T11:43:00.000Z</published>
    <updated>2022-03-07T11:57:38.005Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）。与最初AspectJ采用编译器将横切逻辑织入到目标对象不同，动态代理和字节码生成都是在运行期间为目标对象生成一个代理对象，而将横切逻辑织入到这个代理对象中，系统最终使用的是织入横切逻辑的代理对象而不是真正的目标对象。</p><p> <img src="/images/pasted-128.png" alt="upload successful"><br>注意：动态代理需要实现统一接口，而cglib生成字节码需要方法可以重写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP国家的公民</title>
    <link href="http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/"/>
    <id>http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/</id>
    <published>2022-03-07T10:33:00.000Z</published>
    <updated>2022-03-07T11:39:52.542Z</updated>
    
    <content type="html"><![CDATA[<p>Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。</p><p>Pointcut：Pointcut是Joinpoint的表达方式。将横切逻辑编织入当前系统的过程中，需要参考Pointcut规定的Joinpoint信息，才可以指定应该往系统的哪些Joinpoint上编织横切逻辑。即声明了一个Pointcut就指定了系统中符合条件的一组Joinpoint。</p><p>advice：advice是单一横切关注点逻辑的载体，它代表将会编织到Joinpoint的横切逻辑。如果将Aspect比作OOP中的class，那么advice就相当于class中的method。（常见的如before advice、after advice、after returning advice、after throwing advice，after advice、around advice等）</p><p>Aspect：Aspect是对系统中横切关注点进行模块化封装的AOP概念实体。通常情况下，Aspect可以含有多个Pointcut以及相关Advice定义。</p><p>织入和织入器：织入过程就是“飞架”AOP和OOP的那座桥，只有经过织入过程后，以Aspect模块化的横切关注点才会集成到OOP的现存系统中。而完成织入过程的那个人就是织入器。AspectJ有专门的编译器来完成织入操作，即ajc，所有ajc就是AspectJ完成织入的织入器；JBossAOP采用自定义的类加载器完成最终织入，那么这个类加载器就是他的织入器。SpringAOP使用一组自定义的类来完成最终的织入操作，proxyFactory类则是SpringAOP中最通用的织入器。</p><p>目标对象：符合Pointcut所指定的条件，将在织入过程中被织入横切逻辑的对象，称为目标对象。</p><p>当把所有这些概念组织到一个场景后，就有如下一副场景图：</p><p>   <img src="/images/pasted-127.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。&lt;/p&gt;
&lt;p&gt;Pointcut：Pointcut是Joinpoint的表达方</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
</feed>
