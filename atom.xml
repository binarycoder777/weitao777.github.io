<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-09T08:39:14.232Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL文件</title>
    <link href="http://example.com/2022/02/09/MySQL%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2022/02/09/MySQL%E6%96%87%E4%BB%B6/</id>
    <published>2022-02-09T08:05:00.000Z</published>
    <updated>2022-02-09T08:39:14.232Z</updated>
    
    <content type="html"><![CDATA[<p>1、参数文件：MySQL实例启动时会读取参数文件来初始化。</p><p>2、日志文件：</p><p>错误日志（记录了MySQL执行期间的错误信息）</p><p>二进制日志（记录了对MySQL执行的写操作，默认未开启。</p><p>作用：<br>1、恢复，可以通过binlog进行数据的恢复<br>2、复制：通过复制和执行binlog对远程的MySQL进行实时数据同步（主从复制）<br>3、审计：对binlog数据进行审计，看是否有对数据库进行注入的攻击</p><p> <img src="/images/pasted-81.png" alt="upload successful"></p><p> <img src="/images/pasted-82.png" alt="upload successful"><br>）</p><p>慢查询日志（可以从中得到一些SQL优化信息，默认未开启）</p><p>查询日志（记录了所有对MySQL的请求信息）</p><p>3、套接字文件</p><p>4、pid文件</p><p>5、表结构定义文件（以frm为后缀名）：记录了该表的表结构定义。除此之外还用于存放视图的定义。</p><p>6、innoDB存储引擎文件：</p><p>a）表空间文件（默认10mb，名为ibdata1）：可以设置基于innoDB存储的单独的。idb独立表空间文件（仅存储数据、索引等信息，其他信息还是存放于表空间文件）。</p><p> <img src="/images/pasted-78.png" alt="upload successful"></p><p> b）、redolog文件（默认会有两个名为ib_logfile0和ib_logfile1的文件）：每个innoDB至少有一个redolog组（每组至少有两个redolog文件），redolog冲缓冲区写入磁盘是按512字节，即一个扇区大小，可以保障写入必定成功（所有不需要doublewrite）</p><p> <img src="/images/pasted-79.png" alt="upload successful"></p><p> <img src="/images/pasted-80.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、参数文件：MySQL实例启动时会读取参数文件来初始化。&lt;/p&gt;
&lt;p&gt;2、日志文件：&lt;/p&gt;
&lt;p&gt;错误日志（记录了MySQL执行期间的错误信息）&lt;/p&gt;
&lt;p&gt;二进制日志（记录了对MySQL执行的写操作，默认未开启。&lt;/p&gt;
&lt;p&gt;作用：&lt;br&gt;1、恢复，可以通过bi</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="文件" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>innoDB存储引擎</title>
    <link href="http://example.com/2022/02/09/innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/2022/02/09/innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2022-02-09T03:04:00.000Z</published>
    <updated>2022-02-09T07:37:44.969Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB存储引擎是开源的第一个完整支持ACID事务的MySQL存储引擎（第一个支持事务的是BDB存储引擎），其特点是行锁设计、支持MVCC、支持外键、一致性非锁定读等。被广泛的应用。</p><p> <img src="/images/pasted-58.png" alt="upload successful"></p><p> innoDB存储引擎有多个内存块，组成了一个大的内存池，每个内存块有指定的后台线程来维护其运行。</p><p> 1、main线程主要负责将缓冲区的数据异步刷新到磁盘，保证数据的一致性（包括脏页的刷新、合并插入缓冲、undo页的回收等）</p><p> 2、IO线程主要是负责IO请求的回调，包括read、write、insert buffer、log等，其使用了AIO机制，保证了IO性能。</p><p> 3、Purge线程主要用于回收提交事务之后，undo页可能不再需要，需要对其进行回收。（1.2版本支持多个Purge线程，目的是进一步加快undo页的回收，提升性能）</p><p> 4、Page cleaner线程主要用于脏页的刷新操作，减轻main线程的压力。</p><p> innoDB是基于磁盘存储的，为了权衡磁盘速度和CPU速度的差异，提供了一块缓冲池技术来提升性能。（因此可以将缓冲池区域设置大一点来进行优化操作）innoDB1.0允许多个缓冲池实例，磁盘读取的页根据哈希值均匀分配到不同缓冲池中（目的：减少数据库资源竞争，增加数据库并发处理能力）</p><p> 在数据的读取中，会先去缓冲池中查看是否存在于缓冲池，如果存在直接读取，不存在则去磁盘读取，在同步到缓冲池中。而对于写操作则是先写到缓冲池，然后根据Checkpoint机制将脏数据刷新到磁盘，保证磁盘和内存数据的一致性。</p><p> 缓冲池具体的数据页有：</p><p> <img src="/images/pasted-59.png" alt="upload successful"></p><p> 为了管理这些数据页，innoDB使用了一个freeLIst链表来管理空闲的页内存，LRUList来管理已经分配的页内存，flushList来管理脏页。（脏页及存在于LRUList，又存在于flushList，是两者共享的）</p><p> 对于LRUList管理的页，采用了LRU（最近最少使用）算法来管理（缓冲池页大小默认16kb），在LRU列表中加入了一个midpoint位置（默认是5/8位置处），midpoint位置前面的是热点数据区域，后面的是冷数据区域（设置冷、热数据区域主要是为了保证一些经常被访问的数据存在于内存中，提示效率的一种考虑）。当一个新的页被分配到LRULIst上，会先加入到midpoint位置后面（这样做是为了防止当进行全表查询的时候，多个页会覆盖调热数据区域的页，而这些查的数据页又只使用一次，后续不再使用，当后面访问热区域的页时有会从磁盘中查找，浪费性能），同时也指定了一个从冷数据区域晋升到热数据区域的参数，当到了晋升时间后，冷数据区域的页就会晋升到热数据区域。</p><p>值得注意的是：空闲页的内存freeList+以分配的页内存LRUList并不等于缓冲池的内存，因为缓冲池中包含得其他部分页（自适应哈希索引、lock信息等）不需要LRU维护，不存在于LRUList中。</p><p> <img src="/images/pasted-60.png" alt="upload successful"></p><p> 另外，页是支持压缩的，16kb的页可以压缩成1kb、2kb、4kb、8kb。页的大小发生变化，所有对于压缩的页，会使用zipLRUList进行管理。（注意：LRUList包含zipLRUList中的页）</p><p> 对于zipLIRList的页的分配采用伙伴算法</p><p>例如压缩后的页为4kb</p><p>1、先检查4kb的zipLRUList是否有空闲页，存在即分配</p><p>2、否则，检查8kb的zipLRUList看是否存在空闲页，存在则将8kb分为两个4kb，将4kb的页放入4kbzipLRUList<br>，然后为其分配</p><p>3、在否则，检查16kb的freeList看是否存在空闲页，存在则将16kb分为两个4kb，一个8kb，分别放入对应zipLRUList，然后为其分配</p><p> <img src="/images/pasted-61.png" alt="upload successful"></p><p> 由上图可知，innoDB除了缓冲池，还存在redolog日志缓冲和额外内存池。</p><p> 其中redolog日志缓冲（默认8mb大小）是redolog文件的缓冲区（redolog文件记录了写请求的指令，对页的写指令都会记录到这个文件中，后续数据库恢复会使用到这个文件）当满足以下条件就会将缓冲区的数据刷新到文件中。</p><p> 1、每个事物提交会进行刷新</p><p> 2、当缓冲区小于一半，会进行刷新</p><p> 3、main线程每秒会进行一次刷新</p><p> 而额外的内存池则是在对于一些数据结构本身进行进行内存分配时会从额外内存储进行申请。</p><p>前面提到进行写操作入时，一般会先写到缓冲区，然后在根据checkpoint机制将脏页刷新到内存，保持内存和磁盘数据的一致性。但考虑到如果频繁发生写操作，而对脏数据刷新到磁盘不加以控制，每来一个写操作，都会进行一次刷新，那就会产生大量的io，导致整体性能下降；除此之外，在刷新的时候如果出现了宕机，数据也会丢失。因此采用提交事物前，先写redolog日志，然后在修改内存中的页，即使将脏页刷新到磁盘时出现宕机，也能够根据redolog日志进行恢复。而chenckpoint技术就是为了解决</p><p>1、缩短数据库的恢复时间（因为chenckpoint前的脏页都已经刷新到磁盘了，只需对chenckpoint之后的进行恢复）<br>2、缓冲池不够时将脏页刷新到磁盘。（当缓冲池不够用时，会根据LRU算法将最近最少用的页淘汰，而淘汰时会检测是否为脏页，如果是则执行checkpoint，将脏页刷新到磁盘）<br>3、redolog日志不够用时，刷新脏页（即redolog的大小是有限制的，chenckpont前的是可重用的，而chenckpoint之后的是需要的，如果redolog文件里面全部都是需要使用的，则必须进行checkpoint）</p><p>在innoDB中，使用LSN（八字节）标记版本，每个页都有自己的LSN，redolog日志中和checkpoint中也有。</p><p>在innoDB中存在两种checkpoint，即sharp checkpoint（默认）和fuzzy checkpoint。</p><p>sharp checkpoint发生在数据库关闭时，此时会将所有脏页刷新到磁盘（会发生迟钝）</p><p>fuzzy checkpoint则是每次只刷新部分脏页到磁盘。以下是几种发生fuzzy checkpoint的情况：</p><p> <img src="/images/pasted-62.png" alt="upload successful"></p><p> 1、main线程会每秒或10秒的速度从fulshList中刷新页到磁盘。</p><p> 2、当缓冲池没有多余空闲空间，会根据LRU算法冲LRUList淘汰页，对于淘汰的页会检测是否是脏页，是则会刷新到磁盘。</p><p> 3、当redolog不可用时会强制flushList中的脏页进行刷新</p><p> 4、当脏页太多，也会强制进行checkpoint刷新脏页到磁盘。</p><p> innoDB主要工作都是在main线程中完成的，其内部由多个循环组成（主循环、后台循环、刷新循环、暂停循环），在多个循环中切换进行工作。</p><p> innoDB1.0</p><p> 主循环：</p><p> <img src="/images/pasted-64.png" alt="upload successful"></p><p> <img src="/images/pasted-65.png" alt="upload successful"></p><p> 后台循环：</p><p> <img src="/images/pasted-66.png" alt="upload successful"></p><p> innoDB1.2基于上述IO限制，加入了innoDB_io_capacitiy用于表示IO（默认200），对于刷新的页用百分比来控制<br> <img src="/images/pasted-67.png" alt="upload successful"><br> 另外一个参数是innoDB_max_dirty_pct（默认75），当脏页小于innoDB_max_dirty_pct也会刷新一定量的脏页（之前是不会刷新的）。</p><p>  <img src="/images/pasted-61.png" alt="upload successful"><br>  接下来说一说innoDB的插入缓冲。insert buffer和数据页一样，是物理页的一部分。</p><p>  在innoDB中，主键是唯一标识，插入记录一般按主键递增顺序插入。因此，聚集索引一般是顺序的（比如自增id这种），对于顺序的一般插入操作速度很快，但对于主键是uuid之类则和辅助索引一样，是随机的。因此对于这种情况，按顺序插入则相对要慢得多。因此insert buffer的作用就是对于非聚集索引的插入或者更新操作先判断是否存在缓冲池，若存在则直接插入，不存在则放到insert buffer中，在以一定频率进行inser buffer和辅助索引子节点的合并，提高对于非聚集索引的插入性能。当然使用insert buffer需要满足<br> <img src="/images/pasted-69.png" alt="upload successful"></p><p> <img src="/images/pasted-70.png" alt="upload successful"></p><p> insert buffer数据实现是一颗b+树，<br> <img src="/images/pasted-72.png" alt="upload successful"></p><p><img src="/images/pasted-73.png" alt="upload successful"></p><p> <img src="/images/pasted-74.png" alt="upload successful"></p><p> change buffer：在1.0.x版本引入了channge buffer，可以对增删改都进行缓冲<br> <img src="/images/pasted-71.png" alt="upload successful"></p><p> 两次写：当innoDB刷新某个页到磁盘中，但只刷新了部分，数据库就宕机了（部分写失效）。double write就是为了解决这种情况产生的。</p><p> <img src="/images/pasted-75.png" alt="upload successful"></p><p> double write由两部分组成。一部分时内存double write buffer（大小2mb），一部分是磁盘上的共享表空间中连续的128页（即两个区，大小为2mb）。在对脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复杂到 doublewrite buffer，然后doubllewrite buffer再分两次顺序的写到共享表空间的物理磁盘上（每次写1mb）。完成之后，在将doublewrite buffer中的页写入各个表文件空间中。如果在写入表中磁盘时发生了宕机什么的。在恢复时，可以从共享表空间中找到一个备份页，将其复制到表空间。</p><p> <img src="/images/pasted-76.png" alt="upload successful"></p><p> 自适应哈希：innoDB会对表上各索引页的查询监控。如果建立哈希索引会提升性能，则建立哈希索引。而条件就是：对这个页的连续访问模式要一样。</p><p> 异步IO：innoDB采用AIO的方式处理磁盘操作，可以在发起一个IO请求后，立马发起另一个IO请求，当全部发送完后，等所有请求操作完。除此之外，还可以进行IO的合并操作。</p><p> 刷新邻接页：即刷新一个脏页时，会检测该页周围的页是否是脏页，是则一并刷新。</p><p> <img src="/images/pasted-77.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB存储引擎是开源的第一个完整支持ACID事务的MySQL存储引擎（第一个支持事务的是BDB存储引擎），其特点是行锁设计、支持MVCC、支持外键、一致性非锁定读等。被广泛的应用。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-58.png&quot; al</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="innoDB" scheme="http://example.com/tags/innoDB/"/>
    
  </entry>
  
  <entry>
    <title>jedis和redission</title>
    <link href="http://example.com/2022/02/08/jedis%E5%92%8Credission/"/>
    <id>http://example.com/2022/02/08/jedis%E5%92%8Credission/</id>
    <published>2022-02-08T12:45:00.000Z</published>
    <updated>2022-02-08T12:46:11.557Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-57.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-57.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="框架实现" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash算法</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-08T12:33:00.000Z</published>
    <updated>2022-02-08T12:34:21.071Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-55.png" alt="upload successful"></p><p> <img src="/images/pasted-56.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-55.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-56.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Redis/"/>
    
    
    <category term="一致性哈希算法" scheme="http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群的主从复制模型</title>
    <link href="http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-02-08T12:27:00.000Z</published>
    <updated>2022-02-08T12:27:38.911Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-54.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-54.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="主从复制模型" scheme="http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存优化</title>
    <link href="http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-08T12:09:00.000Z</published>
    <updated>2022-02-08T12:10:03.147Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-52.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-52.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存优化" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis的回收进程如何工作</title>
    <link href="http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/"/>
    <id>http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</id>
    <published>2022-02-08T09:37:00.000Z</published>
    <updated>2022-02-08T11:59:38.055Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-51.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-51.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="回收进程" scheme="http://example.com/tags/%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个Redis实例能存放多少key？</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/</id>
    <published>2022-02-08T09:27:00.000Z</published>
    <updated>2022-02-08T09:28:21.147Z</updated>
    
    <content type="html"><![CDATA[<p>理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的<br>值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的&lt;br&gt;值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis异步队列</title>
    <link href="http://example.com/2022/02/08/Redis%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/02/08/Redis%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/</id>
    <published>2022-02-08T08:50:00.000Z</published>
    <updated>2022-02-08T09:02:41.782Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-49.png" alt="upload successful"></p><p> <img src="/images/pasted-50.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-49.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-50.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="异步队列" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="http://example.com/2022/02/08/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2022/02/08/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-02-08T08:29:00.000Z</published>
    <updated>2022-02-08T08:30:14.720Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-48.png" alt="upload successful"></p><p> 转载自：<a href="https://www.cnblogs.com/wangyingshuo/p/14510524.html">https://www.cnblogs.com/wangyingshuo/p/14510524.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-48.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 转载自：&lt;a href=&quot;https://www.cnblogs.com/wangyingshuo/p/14510524.html&quot;&gt;htt</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="分布式锁" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如何保证Redis数据都是热点数据？</title>
    <link href="http://example.com/2022/02/07/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F/"/>
    <id>http://example.com/2022/02/07/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F/</id>
    <published>2022-02-07T10:06:00.000Z</published>
    <updated>2022-02-07T10:11:22.310Z</updated>
    
    <content type="html"><![CDATA[<p>1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。<br>所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。</p><p>2.问题是什么数据？</p><p>比如用户数据。数据库有2000w条。<br>活跃用户：<br>redis sortSet里 放两天内(为方便取一天内活跃用户)登录过的用户，登录一次ZADD一次，如set已存在则覆盖其分数（登录时间）。键：login:users，值：分数 时间戳、value userid。设置一个周期任务，比如每天03:00:00点删除sort set中前一天3点前的数据（保证set不无序增长、留近一天内活跃用户）。</p><p>取时，拿到当前时间戳（int 10位），再减1天就可按分数范围取过去24h活跃用户。</p><p>3.看你的提问,应该只是把Redis当缓存来用.<br>提供一种简单实现缓存失效的思路: LRU(最近少用的淘汰)<br>即redis的缓存每命中一次,就给命中的缓存增加一定ttl(过期时间)(根据具体情况来设定, 比如10分钟).<br>一段时间后, 热数据的ttl都会较大, 不会自动失效, 而冷数据基本上过了设定的ttl就马上失效了.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。&lt;br&gt;所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。&lt;/p&gt;
&lt;p&gt;2.问题是什么数据？&lt;/p&gt;
&lt;p&gt;比如用户数据。数据库有2000w条。&lt;br</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="热点数据" scheme="http://example.com/tags/%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Redis共享整数字符串</title>
    <link href="http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-02-07T01:55:00.000Z</published>
    <updated>2022-02-07T01:55:23.165Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-47.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-47.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="共享" scheme="http://example.com/tags/%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象内存回收</title>
    <link href="http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</id>
    <published>2022-02-07T01:53:00.000Z</published>
    <updated>2022-02-07T01:53:31.910Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-46.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-46.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存回收" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之对象</title>
    <link href="http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-02-07T00:49:00.000Z</published>
    <updated>2022-02-07T01:52:21.525Z</updated>
    
    <content type="html"><![CDATA[<p>Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现。</p><p>在底层上，由一个type类型表明当前数据对象属于哪个类型，由encodeing表明底层具体的数据结构实现，然后由一个指针指向底层的数据结构实现。这样的好处的话主要就是在不同的应用场景选择不同的底层数据结构实现，会大大提高redis的存储性能。</p><p>1、具体的话，String类型底层实现有：int、raw、embstr三种数据结构的实现。其中int类型的底层数据结构实现主要是用于存放整数值，当我们的value是一个整数值，就可以选择用int类型的底层实现。而raw类型的底层实现则是一个动态字符串数据结构，一般当字符串大于32字节就会使用到。embstr则是当字符串小于32字节会使用到。两者的不同在于，embstr只会进行一次内存分配和释放，而raw则会进行两次内存分配和释放；而且embstr的内存时连续的，而raw不是。</p><p>需要注意的是：double这种浮点型的数据作为value存储的时候，底层使用的是str类型的数据结构实现。另外上述三种底层数据结构实现是可以相互转换的。</p><p>2、list类型底层编码可以使ziplist和linkedlist两种类型，当list满足每个节点小于64字节并且节点数小于512个就可以采用ziplist作为底层实现，否则采用linkedlist</p><p>3、hash对象底层编码可以使ziplist和hashtable两种类型<br> <img src="/images/pasted-38.png" alt="upload successful"></p><p> <img src="/images/pasted-39.png" alt="upload successful"></p><p> 4、set集合的编码实现可以使整数集合和hashtable</p><p>  <img src="/images/pasted-40.png" alt="upload successful"></p><p>  5、有序集合zset的编码实现：ziplist和skiplist。</p><p> <img src="/images/pasted-41.png" alt="upload successful"></p><p> <img src="/images/pasted-42.png" alt="upload successful"></p><p> <img src="/images/pasted-43.png" alt="upload successful"></p><p> <img src="/images/pasted-44.png" alt="upload successful"></p><p> <img src="/images/pasted-45.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="对象" scheme="http://example.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之整数集合</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</id>
    <published>2022-02-06T13:40:00.000Z</published>
    <updated>2022-02-06T13:49:01.981Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-37.png" alt="upload successful"></p><p> 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encoding决定保存是int16、32还是64.</p><p> 当将一个新元素加入整数集合时，而且这个元素类型长于当前集合类型，就会先对集合升级，然后在加入新元素。</p><p> 升级：</p><p> 1、根据新元素类型，开辟新的数组</p><p> 2、将原数组的元素转移到新数组的正确位置上，且转化为与新数组相同的类型</p><p> 3、将新元素加到新数组指定的位置</p><p> 好处：</p><p> 1、提升灵活性，C语言是静态类型语言，为了避免错误，不会将两种类型放在一个数据结构里面，通过底层数组升级操作，不必担心不同类型的整数出现类型错误</p><p> 2、节约内存，整数集合的升级操作，确保了只在需要的时候进行，尽量节约内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-37.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encodi</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="整数集合" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之跳表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/</id>
    <published>2022-02-06T13:13:00.000Z</published>
    <updated>2022-02-06T13:24:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p> <img src="/images/pasted-33.png" alt="upload successful"></p><p> <img src="/images/pasted-34.png" alt="upload successful"></p><p> <img src="/images/pasted-35.png" alt="upload successful"></p><p> <img src="/images/pasted-36.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-33.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/imag</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="跳表" scheme="http://example.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之字典</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/</id>
    <published>2022-02-06T12:37:00.000Z</published>
    <updated>2022-02-06T13:24:45.912Z</updated>
    
    <content type="html"><![CDATA[<p>字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。</p><p>1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下标上的链表进行比较（没有链表则直接加上去），看是否是同一个值，如果是，则覆盖，不是则加到链表尾。</p><p>2、字典则是一个包含两个hash表的结构体，一般情况只使用下标为0的hash表，当对0下标的hash表进行扩容时，会使用到1下标处的hash表。即当0下标处的hash表</p><p>a）满足服务器没有执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于1</p><p>b）或者满足服务器执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于5</p><p>（因为在执bgsave或者bgrewriteaof命令时，服务器在执行备份操作，为了尽可能提高其效率，避免在此期间进行hash表扩容操作）</p><p>c）负载因子小于0.1会收缩</p><p>就会发生扩容，此时会渐进的将0下标的hash表的数据转移到扩容后的1下标处。（这里之所以采取渐进式的转移，主要是考虑到当hash表里面存的数据量很大时，一次性转移会很消耗时间）</p><p> <img src="/images/pasted-30.png" alt="upload successful"></p><p> <img src="/images/pasted-31.png" alt="upload successful"></p><p> <img src="/images/pasted-29.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。&lt;/p&gt;
&lt;p&gt;1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之链表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-06T12:28:00.000Z</published>
    <updated>2022-02-06T12:35:31.761Z</updated>
    
    <content type="html"><![CDATA[<p>链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释放函数等。即最终是一个双端无环链表。</p><p> <img src="/images/pasted-25.png" alt="upload successful"></p><p> <img src="/images/pasted-26.png" alt="upload successful"></p><p> <img src="/images/pasted-24.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之SDS</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</id>
    <published>2022-02-06T12:13:00.000Z</published>
    <updated>2022-02-06T12:36:06.134Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：</p><p>1、可以通过len-free以常数阶获取字符串长度</p><p>2、可以通过free字段避免缓冲区出现溢出的情况</p><p>3、同时也减少字符串修改时，内存重新分配的次数，其具体实现是通过预先分配内存（即当追加字符串之后，字符串小于1MB，会多分配一倍的空间）和懒惰回收（即当字符串变短之后，不会立即回收那一部分空间，而是作为临时空间供后续字符串扩增做优化）</p><p>4、可以保存二进制安全的数据</p><p> <img src="/images/pasted-27.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：&lt;/p&gt;
&lt;p&gt;1</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>枚举单例模式如何防止反射和反序列化</title>
    <link href="http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-01-27T11:08:00.000Z</published>
    <updated>2022-01-27T11:16:11.794Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p><p>2、枚举单例在创建时不存在并发问题：</p><pre><code>枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的</code></pre><p>2、反序列化：</p><pre><code>Java对枚举的序列化作了规定，在序列化时，仅将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象。枚举在序列化和反序列化时，并不会调用构造方法，这就防止了反序列化导致的单例破坏的问题。</code></pre><p>3、反射：</p><pre><code>反射在通过newInstance创建对象时，会检查这个类是否是枚举类，如果是，会抛出异常java.lang.IllegalArgumentException: Cannot reflectively create enum objects，表示反射创建对象失败。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;2、枚举单例在创建时不存在并发问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的
&lt;/c</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
