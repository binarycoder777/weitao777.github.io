<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-09T13:28:17.294Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring的AOP通知执行顺序</title>
    <link href="http://example.com/2022/03/09/Spring%E7%9A%84AOP%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2022/03/09/Spring%E7%9A%84AOP%E9%80%9A%E7%9F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2022-03-09T13:25:00.000Z</published>
    <updated>2022-03-09T13:28:17.294Z</updated>
    
    <content type="html"><![CDATA[<p>执行顺序：</p><pre><code>5.2.7之前：1、正常执行：@Before­­­&gt;方法­­­­&gt;@After­­­&gt;@AfterReturning2、异常执行：@Before­­­&gt;方法­­­­&gt;@After­­­&gt;@AfterThrowing5.2.7之后：1、正常执行：@Before­­­&gt;方法­­­­&gt;@AfterReturning­­­&gt;@After2、异常执行：@Before­­­&gt;方法­­­­&gt;@AfterThrowing­­­&gt;@After</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;执行顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;5.2.7之前：

1、正常执行：@Before­­­&amp;gt;方法­­­­&amp;gt;@After­­­&amp;gt;@AfterReturning
2、异常执行：@Before­­­&amp;gt;方法­­­­&amp;gt;@After­­­&amp;gt;@A</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>说说@Import可以有几种用法？</title>
    <link href="http://example.com/2022/03/09/%E8%AF%B4%E8%AF%B4-Import%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E8%AF%B4%E8%AF%B4-Import%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95%EF%BC%9F/</id>
    <published>2022-03-09T10:41:00.000Z</published>
    <updated>2022-03-09T10:43:33.973Z</updated>
    
    <content type="html"><![CDATA[<p>1、 直接指定类 （如果配置类会按配置类正常解析、  如果是个普通类就会解析成Bean)</p><p>2、 通过ImportSelector 可以一次性注册多个，返回一个string[]  每一个值就是类的完整类路径</p><p>3、 通过DeferredImportSelector可以一次性注册多个，返回一个string[]  每一个值就是类的完整类路径</p><pre><code>区别：DeferredImportSelector 顺序靠后</code></pre><p>4、 通过ImportBeanDefinitionRegistrar 可以一次性注册多个，通过BeanDefinitionRegistry来动态注册BeanDefintion</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、 直接指定类 （如果配置类会按配置类正常解析、  如果是个普通类就会解析成Bean)&lt;/p&gt;
&lt;p&gt;2、 通过ImportSelector 可以一次性注册多个，返回一个string[]  每一个值就是类的完整类路径&lt;/p&gt;
&lt;p&gt;3、 通过DeferredImportS</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>如何让自动注入找到多个依赖Bean时不报错</title>
    <link href="http://example.com/2022/03/09/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E6%89%BE%E5%88%B0%E5%A4%9A%E4%B8%AA%E4%BE%9D%E8%B5%96Bean%E6%97%B6%E4%B8%8D%E6%8A%A5%E9%94%99/"/>
    <id>http://example.com/2022/03/09/%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E6%89%BE%E5%88%B0%E5%A4%9A%E4%B8%AA%E4%BE%9D%E8%B5%96Bean%E6%97%B6%E4%B8%8D%E6%8A%A5%E9%94%99/</id>
    <published>2022-03-09T10:36:00.000Z</published>
    <updated>2022-03-09T10:39:06.070Z</updated>
    
    <content type="html"><![CDATA[<p>自动注入找到多个依赖Bean时，@primary可以指定注入哪一个。</p><p>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</p><p>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用</p><p>@Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自动注入找到多个依赖Bean时，@primary可以指定注入哪一个。&lt;/p&gt;
&lt;p&gt;@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常&lt;/p&gt;
&lt;p&gt;@Autowired 默认按类型装配，如果我们想使用按名</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>说一说@Autowired和@Resource之间的区别</title>
    <link href="http://example.com/2022/03/09/%E8%AF%B4%E4%B8%80%E8%AF%B4-Autowired%E5%92%8C-Resource%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/09/%E8%AF%B4%E4%B8%80%E8%AF%B4-Autowired%E5%92%8C-Resource%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-09T10:31:00.000Z</published>
    <updated>2022-03-09T10:35:41.053Z</updated>
    
    <content type="html"><![CDATA[<p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><p>@Autowired默认是按照类型装配注入的（按照名称匹配需要@Qualifier），默认情况下它要求依赖对象必须存在（可以设置它required属性为<br>false）。</p><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@Autowired可用于：构造函数、成员变量、Setter方法&lt;/p&gt;
&lt;p&gt;@Autowired和@Resource之间的区别&lt;/p&gt;
&lt;p&gt;@Autowired默认是按照类型装配注入的（按照名称匹配需要@Qualifier），默认情况下它要求依赖对象必须存在（可以设置</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>使用@Autowired注解自动装配的过程是怎样的？</title>
    <link href="http://example.com/2022/03/09/%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/</id>
    <published>2022-03-09T10:11:00.000Z</published>
    <updated>2022-03-09T10:20:50.684Z</updated>
    
    <content type="html"><![CDATA[<p>记住：@Autowired 通过Bean的后置处理器进行解析的</p><p>1、 在创建一个Spring上下文的时候再构造函数中进行注册AutowiredAnnotationBeanPostProcessor</p><p>2、 在Bean的创建过程中进行解析</p><pre><code>2.1、 在实例化后预解析（解析@Autowired标注的属性、方法   比如：把属性的类型、名称、属性所在的类..... 元数据缓存起）2.2、 在属性注入真正的解析（拿到上一步缓存的元数据 去ioc容器帮进行查找，并且返回注入）</code></pre><p>a. 首先根据预解析的元数据拿到 类型去容器中进行查找 <br>（如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；<br>如果查询的结果不止一个，那么@Autowired会根据名称来查找；<br>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。）</p><p> <img src="/images/pasted-144.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记住：@Autowired 通过Bean的后置处理器进行解析的&lt;/p&gt;
&lt;p&gt;1、 在创建一个Spring上下文的时候再构造函数中进行注册AutowiredAnnotationBeanPostProcessor&lt;/p&gt;
&lt;p&gt;2、 在Bean的创建过程中进行解析&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>配置类@Configuration的作用解析原理</title>
    <link href="http://example.com/2022/03/09/%E9%85%8D%E7%BD%AE%E7%B1%BB-Configuration%E7%9A%84%E4%BD%9C%E7%94%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/03/09/%E9%85%8D%E7%BD%AE%E7%B1%BB-Configuration%E7%9A%84%E4%BD%9C%E7%94%A8%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/</id>
    <published>2022-03-09T09:00:00.000Z</published>
    <updated>2022-03-09T10:09:42.110Z</updated>
    
    <content type="html"><![CDATA[<p>1、@Configuration用来代替xml配置方式spring.xml配置文件 <bean></p><p>2、没有@Configuration也是可以配置@Bean</p><p>3、 加了@Configuration会为配置类创建cglib动态代理（保证配置类@Bean方法调用Bean的单例），@Bean方法的调用就会通过容器.getBean进行获取</p><p>原理：</p><p>1、创建Spring上下文的时候会注册一个解析配置的处理器ConfigurationClassPostProcessor（实现BeanFactoryPostProcessor和<br>BeanDefinitionRegistryPostProcessor)</p><p>2、在调用invokeBeanFactoryPostProcessor，就会去调用<br>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry进行解析配置（解析配置类说白就是去解析各种注解<br>(@Bean @Configuration@Import @Component …  就是注册BeanDefinition)</p><p>3、ConfigurationClassPostProcessor.postProcessBeanFactory去创建cglib动态代理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、@Configuration用来代替xml配置方式spring.xml配置文件 &lt;bean&gt;&lt;/p&gt;
&lt;p&gt;2、没有@Configuration也是可以配置@Bean&lt;/p&gt;
&lt;p&gt;3、 加了@Configuration会为配置类创建cglib动态代理（保证配置类@Be</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>对于@Bean之间的方法调用是怎么保证单例的？</title>
    <link href="http://example.com/2022/03/09/%E5%AF%B9%E4%BA%8E@Bean%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8D%95%E4%BE%8B%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E5%AF%B9%E4%BA%8E@Bean%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8D%95%E4%BE%8B%E7%9A%84%EF%BC%9F/</id>
    <published>2022-03-09T08:44:00.000Z</published>
    <updated>2022-03-09T08:57:45.869Z</updated>
    
    <content type="html"><![CDATA[<p>如果希望@bean方法返回的对象是单例，需要在类上加上@Configuration注解。</p><p>原因：Spring会使用invokeBeanFactoryPostProcessor 在内置BeanFactoryPostProcessor中使用CGLib生成动态代理，当@Bean方法进行互调时， 则会通过CGLIB进行增强，通过调用的方法名作为bean的名称去ioc容器中获取，进而保证了@Bean方法的单例 。</p><p>换句话说：被@Configuration修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被@Bean 修饰的方法，默认情况（bean为单例）下确保这些方法只被调用一次，从而确保这些bean是同一个bean，即单例的<br>。@Configuration修饰的类有cglib代理效果，默认添加的bean都为单例</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果希望@bean方法返回的对象是单例，需要在类上加上@Configuration注解。&lt;/p&gt;
&lt;p&gt;原因：Spring会使用invokeBeanFactoryPostProcessor 在内置BeanFactoryPostProcessor中使用CGLib生成动态代理，</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>要将一个第三方的类配成为Bean有哪些方式？</title>
    <link href="http://example.com/2022/03/09/%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E7%B1%BB%E9%85%8D%E6%88%90%E4%B8%BABean%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E7%B1%BB%E9%85%8D%E6%88%90%E4%B8%BABean%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F/</id>
    <published>2022-03-09T08:39:00.000Z</published>
    <updated>2022-03-09T08:42:14.407Z</updated>
    
    <content type="html"><![CDATA[<p>1、通过@bean注解（搭配@Configurtion）</p><p>2、通过@import注解</p><p>3、通过Spring的拓展接口BeanDefinitionRegistryPostProcessor</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、通过@bean注解（搭配@Configurtion）&lt;/p&gt;
&lt;p&gt;2、通过@import注解&lt;/p&gt;
&lt;p&gt;3、通过Spring的拓展接口BeanDefinitionRegistryPostProcessor&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>为什么@ComponentScan 不设置basePackage也会扫描？</title>
    <link href="http://example.com/2022/03/09/%E4%B8%BA%E4%BB%80%E4%B9%88-ComponentScan-%E4%B8%8D%E8%AE%BE%E7%BD%AEbasePackage%E4%B9%9F%E4%BC%9A%E6%89%AB%E6%8F%8F%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/%E4%B8%BA%E4%BB%80%E4%B9%88-ComponentScan-%E4%B8%8D%E8%AE%BE%E7%BD%AEbasePackage%E4%B9%9F%E4%BC%9A%E6%89%AB%E6%8F%8F%EF%BC%9F/</id>
    <published>2022-03-09T08:36:00.000Z</published>
    <updated>2022-03-09T08:38:51.082Z</updated>
    
    <content type="html"><![CDATA[<p>@componentScan注解不设置basePackage默认会将你的类所在的包的地址作为扫描包的地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@componentScan注解不设置basePackage默认会将你的类所在的包的地址作为扫描包的地址&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring是如何解决循环依赖问题的？</title>
    <link href="http://example.com/2022/03/09/Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F/"/>
    <id>http://example.com/2022/03/09/Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F/</id>
    <published>2022-03-09T02:54:00.000Z</published>
    <updated>2022-03-09T03:11:12.718Z</updated>
    
    <content type="html"><![CDATA[<p>什么是循环依赖问题？</p><p>类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。（比如A类依赖了B类，B类依赖了C类，而最后C类又依赖了A类，这样就形成了循环依赖问题。）</p><p>循环依赖问题在Spring中主要有三种情况：</p><p>1、通过构造方法进行依赖注入时产生的循环依赖问题。</p><p>2、通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</p><p>3、通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</p><p>注意：在Spring中，只有【第三种方式】的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。</p><p>因为第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。</p><p>第二种setter方法&amp;&amp;多例的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。</p><p>如何解决循环依赖问题？</p><p> <img src="/images/pasted-138.png" alt="upload successful"></p><p> Spring中有三个缓存，用于存储单例的Bean实例，这三个缓存是彼此互斥的，不会针对同一个Bean的实例同时存储。</p><p> 如果调用getBean，则需要从三个缓存中依次获取指定的Bean实例。读取顺序依次是一级缓存–&gt;二级缓存–&gt;三级缓存</p><p> <img src="/images/pasted-139.png" alt="upload successful"></p><p> 一级缓存：Map&lt;String, Object&gt; singletonObjects<br>第一级缓存的作用？</p><p>用于存储单例模式下创建的Bean实例（已经创建完毕）。<br>该缓存是对外使用的，指的就是使用Spring框架的程序员。</p><p>存储什么数据？</p><p>K：bean的名称</p><p>V：bean的实例对象（有代理对象则指的是代理对象，已经创建完毕）</p><p>第二级缓存：Map&lt;String, Object&gt; earlySingletonObjects第二级缓存的作用？</p><p>用于存储单例模式下创建的Bean实例（该Bean被提前暴露的引用,该Bean还在创建中）。<br>该缓存是对内使用的，指的就是Spring框架内部逻辑使用该缓存。<br>为了解决第一个classA引用最终如何替换为代理对象的问题（如果有代理对象）</p><p>存储什么数据？</p><p>K：bean的名称</p><p>V：bean的实例对象（有代理对象则指的是代理对象，该Bean还在创建中）</p><p>第三级缓存：Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories第三级缓存的作用？</p><p>通过ObjectFactory对象来存储单例模式下提前暴露的Bean实例的引用（正在创建中）。<br>该缓存是对内使用的，指的就是Spring框架内部逻辑使用该缓存。<br>此缓存是解决循环依赖最大的功臣</p><p>存储什么数据？</p><p>K：bean的名称</p><p>V：ObjectFactory，该对象持有提前暴露的bean的引用</p><p> <img src="/images/pasted-140.png" alt="upload successful"></p><p>为什么第三级缓存要使用ObjectFactory？需要提前产生代理对象。</p><p> <img src="/images/pasted-141.png" alt="upload successful"><br>什么时候将Bean的引用提前暴露给第三级缓存的ObjectFactory持有？时机就是在第一步实例化之后，第二步依赖注入之前，完成此操作。</p><p> <img src="/images/pasted-142.png" alt="upload successful"></p><p>总结<br>以上就是Spring解决循环依赖的关键点！总结来说，就是要搞清楚以下几点：</p><p>搞清楚Spring三级缓存的作用？<br>搞清楚第三级缓存中ObjectFactory的作用？<br>搞清楚为什么需要第二级缓存？<br>搞清楚什么时候使用三级缓存（添加和查询操作）？<br>搞清楚什么时候使用二级缓存（添加和查询操作）？<br>当目标对象产生代理对象时，Spring容器中（第一级缓存）到底存储的是谁？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;什么是循环依赖问题？&lt;/p&gt;
&lt;p&gt;类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。（比如A类依赖了B类，B类依赖了C类，而最后C类又依赖了A类，这样就形成了循环依赖问题。）&lt;/p&gt;
&lt;p&gt;循环依赖问题在Spring中主要有三种情况：&lt;/p&gt;
&lt;p&gt;1、通过构造</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="循环依赖" scheme="http://example.com/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP实现机制的一个小小陷阱</title>
    <link href="http://example.com/2022/03/08/Spring%20AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%99%B7%E9%98%B1/"/>
    <id>http://example.com/2022/03/08/Spring%20AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%99%B7%E9%98%B1/</id>
    <published>2022-03-08T12:36:00.000Z</published>
    <updated>2022-03-08T12:48:29.130Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Spring AOP采用代理模式实现，具体的横切逻辑会被添加到动态生成的代理对象中，只要调用的是目标对象的代理对象上的方法就可以保证目标对象的方法执行可以被拦截。</p><p>不过遗憾的是，代理模式的实现机制在处理方法调用的时序方面会给使用这种机制实现的AOP产品造成一个缺憾。在处理对象方法中，不管你如何添加横切逻辑，也不管添加多少横切逻辑，有一点是确定的，你最终需要调用目标对象的同一方法来执行最初所应以的方法逻辑。如果目标对象中原始方法调用依赖于其他对象，那没问题。我们可以为目标对象注入所依赖对象的代理，并且可以保证相应的Joinpoint被拦截并且织入相应横切逻辑。但是如果目标对象中的原始方法调用直接调用自身方法时，会导致出现问题</p><p> <img src="/images/pasted-133.png" alt="upload successful"></p><p> 在代理对象的method1执行经历了层层拦截后，最终会将调用转向目标对象上的method1，之后调用流程全部在走targetobject之上，当method1调用method2时，它调用targetobject的method2，而不是代理对象的method2，而针对method2的横切逻辑是织入到代理对象上的，因此method1中调用的method2没有被成功拦截。</p><p> 好在Spring AOP提供了AopContent来公开当前目标对象的代理对象，我们只要在目标对象中使用AopContent.currentProxy()就可以获取当前目标对象所对应的代理对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道Spring AOP采用代理模式实现，具体的横切逻辑会被添加到动态生成的代理对象中，只要调用的是目标对象的代理对象上的方法就可以保证目标对象的方法执行可以被拦截。&lt;/p&gt;
&lt;p&gt;不过遗憾的是，代理模式的实现机制在处理方法调用的时序方面会给使用这种机制实现的AOP产品</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP的常见应用案例</title>
    <link href="http://example.com/2022/03/08/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2022/03/08/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2022-03-08T11:26:00.000Z</published>
    <updated>2022-03-08T12:33:39.435Z</updated>
    
    <content type="html"><![CDATA[<p>1、异常处理：</p><p>通常将Error和RuntimeException及其子类称作非受检异常。（编译器不会对这些类型的异常进行编译期检查），而其他的则为受检异常（编写程序期间就应进行处理）。Fault Barrier即为对非受检异常的处理。</p><p>对于这些非受检异常的处理可以归并于溢出进行处理，而不是让他们散落到系统的各处。介于此，我们可以通过实现一个Aspect来处理，让其对系统中所有可能的falut情况进行统一的处理。而这个专职于处理Falut的Aspect即为Falut Barrier。</p><p>2、安全检查：</p><p>Filter是Servlet规范为我们提供的一种AOP支持。通过它我们可以为基于servlet的web应用添加相应的资源访问控制等等。但是，基于filter的web应用的资源访问控制仅仅是特定领域安全检查需求。而通过AOP，我们可以为任何类型的应用添加安全支持。（Spring Security则是基于Spring的一款强大的安全框架）</p><p>3、缓存：</p><p>AOP应用的另一个主要场景则是为系统透明地添加缓存支持。缓存可以在很大程度上提升系统性能。为了避免需要添加的缓存实现逻辑影响业务逻辑的实现，我们可以让缓存的实现独立于业务对象的实现外，将系统中的缓存需求通过AOP的Aspect进行封装，只在系统中某个点确切需要缓存的情况下才进行织入。（现在已经有许多现成的Caching产品实现，入EhCache、Redis等）</p><p>Spring Modules项目提供了对现有Caching产品的集成，这样可以通过外部声明的方式为系统中的Joinpoint加Caching支持。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、异常处理：&lt;/p&gt;
&lt;p&gt;通常将Error和RuntimeException及其子类称作非受检异常。（编译器不会对这些类型的异常进行编译期检查），而其他的则为受检异常（编写程序期间就应进行处理）。Fault Barrier即为对非受检异常的处理。&lt;/p&gt;
&lt;p&gt;对于这些</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="应用" scheme="http://example.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言程序经过预处理、编译、汇编和链接等各个阶段的变化情况</title>
    <link href="http://example.com/2022/03/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BB%8F%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AD%89%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5/"/>
    <id>http://example.com/2022/03/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BB%8F%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AD%89%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5/</id>
    <published>2022-03-08T07:59:00.000Z</published>
    <updated>2022-03-08T11:26:01.536Z</updated>
    
    <content type="html"><![CDATA[<p>编译过程概述：通常编译程序的过程分为词法分析、语法分析、语义分析、目目标代码生成4个阶段（如果编译器支持优化，还可以有中间代码生成和代码优化两个阶段）。</p><p> <img src="/images/pasted-132.png" alt="upload successful"></p><p>1、词法分析</p><p>此阶段的任务是从左到右一个字符一个字符地读入源程序，对构成源程序的字符进行扫描和分解，从而识别出一个个单词（逻辑上紧密相连的一组有集体含义的字符）。</p><p>2、语法分析</p><p>此阶段的任务是在词法分析的基础上将单词序列分解成各类语法短语（也称语法单位）可表示成语法树。</p><p>注：词法分析和语法分析本质上都是对源程序的结构进行分析。</p><p>3、语义分析</p><p>语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。</p><p>4、中间代码生成</p><p>“中间代码”是一种结构简单，含义明确的记号系统，这种记号系统可以设计为多种多样的形式，重要的设计原则为两点：一是容易生成；二是容易将它翻译成目标代码。很多编译程序采用了一种近似“三地址指令”的“四元式”中间代码。这种四元式的形式为：（运算符，运算对象1，运算对象2，结果）</p><p>5、代码优化</p><p>将中间代码进行变换或进行改造，目的：使生成的目标代码更为高效，即省时间和空间</p><p>6、目标代码生成</p><p>任务是把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译过程概述：通常编译程序的过程分为词法分析、语法分析、语义分析、目目标代码生成4个阶段（如果编译器支持优化，还可以有中间代码生成和代码优化两个阶段）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-132.png&quot; alt=&quot;upload succes</summary>
      
    
    
    
    <category term="编译原理" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="基础概念" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 一世</title>
    <link href="http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/"/>
    <id>http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/</id>
    <published>2022-03-07T12:03:00.000Z</published>
    <updated>2022-03-07T13:01:58.232Z</updated>
    
    <content type="html"><![CDATA[<p>AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint</p><p>Spring中以接口定义Pointcut作为其AOP框架中所有Pointcut的最顶级抽象，该接口定义了两个方法来捕获系统中相应的Joinpoint，并提供了一个TruePointcut类型实例。如果Pointcut类型为TruePointcut，默认会对系统中的所有对象，以及对象上所有被支持的Joinpoint进行匹配。</p><p> <img src="/images/pasted-129.png" alt="upload successful"></p><p> ClassFileter和MethodMatcher分别用于匹配将被执行织入操作的对象以及相应的方法。（重用不同级别的匹配定义，并且可以在不同或相同的级别上进行组合操作，或者强制让某个子类只覆写相应的方法）</p><p> <img src="/images/pasted-130.png" alt="upload successful"></p><p> Spring中各种advice实现全部遵循AOP ALLiance规定的接口。</p><p> <img src="/images/pasted-131.png" alt="upload successful"><br> advice实现了将被织入到Pointcut规定的Joinpoint处的横切逻辑。在Spring中，advice按照其自身实例能否在目标对象类的所有实例中共享这一标准，可以划分为两大类（per-class和per-instance）</p><p> per-class类型的advice：该类型可以在目标对象类的所有实例之间共享。这种类型的advice通常只提供方法拦截的功能。不会为目标对象类保存任何状态或添加新特性。除了上图没有列出的intriuduction类型的advice外，其余都属于pre-class。（如：BeforeAdvice、ThrowsAdvic、AfterReturningAdvice、AroundAdvice等）</p><p> per-instance类型的advice：introduction是唯一的一种per-instance型advice。其可以在不改目标类定义的情况下，为目标类添加新的属性和行为。</p><p> 当所有的Pointcut和advice准备好之后，就可以将其装入Aspect。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint&lt;/p&gt;
&lt;p&gt;Spring中以接口定义Pointcut作为其AOP框</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP的实现机制</title>
    <link href="http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-07T11:43:00.000Z</published>
    <updated>2022-03-07T11:57:38.005Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）。与最初AspectJ采用编译器将横切逻辑织入到目标对象不同，动态代理和字节码生成都是在运行期间为目标对象生成一个代理对象，而将横切逻辑织入到这个代理对象中，系统最终使用的是织入横切逻辑的代理对象而不是真正的目标对象。</p><p> <img src="/images/pasted-128.png" alt="upload successful"><br>注意：动态代理需要实现统一接口，而cglib生成字节码需要方法可以重写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP国家的公民</title>
    <link href="http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/"/>
    <id>http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/</id>
    <published>2022-03-07T10:33:00.000Z</published>
    <updated>2022-03-07T11:39:52.542Z</updated>
    
    <content type="html"><![CDATA[<p>Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。</p><p>Pointcut：Pointcut是Joinpoint的表达方式。将横切逻辑编织入当前系统的过程中，需要参考Pointcut规定的Joinpoint信息，才可以指定应该往系统的哪些Joinpoint上编织横切逻辑。即声明了一个Pointcut就指定了系统中符合条件的一组Joinpoint。</p><p>advice：advice是单一横切关注点逻辑的载体，它代表将会编织到Joinpoint的横切逻辑。如果将Aspect比作OOP中的class，那么advice就相当于class中的method。（常见的如before advice、after advice、after returning advice、after throwing advice，after advice、around advice等）</p><p>Aspect：Aspect是对系统中横切关注点进行模块化封装的AOP概念实体。通常情况下，Aspect可以含有多个Pointcut以及相关Advice定义。</p><p>织入和织入器：织入过程就是“飞架”AOP和OOP的那座桥，只有经过织入过程后，以Aspect模块化的横切关注点才会集成到OOP的现存系统中。而完成织入过程的那个人就是织入器。AspectJ有专门的编译器来完成织入操作，即ajc，所有ajc就是AspectJ完成织入的织入器；JBossAOP采用自定义的类加载器完成最终织入，那么这个类加载器就是他的织入器。SpringAOP使用一组自定义的类来完成最终的织入操作，proxyFactory类则是SpringAOP中最通用的织入器。</p><p>目标对象：符合Pointcut所指定的条件，将在织入过程中被织入横切逻辑的对象，称为目标对象。</p><p>当把所有这些概念组织到一个场景后，就有如下一副场景图：</p><p>   <img src="/images/pasted-127.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。&lt;/p&gt;
&lt;p&gt;Pointcut：Pointcut是Joinpoint的表达方</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>为什么需要AOP？</title>
    <link href="http://example.com/2022/03/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F/"/>
    <id>http://example.com/2022/03/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F/</id>
    <published>2022-03-07T08:29:00.000Z</published>
    <updated>2022-03-07T08:46:14.426Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发的目的最终是为了解决各种需求，包括业务需求和系统需求。使用面向对象的思想，我们可以对业务需求等普通关注点进行很好的抽象和封装，并且使之模块化。但对于系统需求一类的关注点来说，情况有所不同。</p><p>对于业务需求而言，需求与具体实现直接的关系基本上是一对一的。我们可以在系统中某一个确定的点找到针对这种需求的实现。</p><p>但是在开发测试中或者进入生产环境后需要对系统进行监控，我们需要添加日志功能，除此之外，业务方法的执行可能需要一定的权限限制。那么方法执行前需要有相应的安全检查功能。对于这些系统需求，想要以面向对象的方式实现并集成待整个系统中，不仅仅是一个需求对应一个实现那么简单。可能遍布所有的业务对象。</p><p>因此，提出了AOP（面向切面编程），我们可以对类似于logging和security等系统需求进行模块化组织，简化系统需求和实现的对比关系，进而使得整个系统的实现更具模块化。</p><p>AOP是一种理念，其实现需要一种方式。就好似OOP需要对应的语言支撑一样。AOP也需要某种语言帮助实现相应的概念实体（AOL）。</p><p>静态AOP：相应的横切关注点以Aspect形式实现后，会通过特定的编译器，将实现后的Aspect编织到系统的静态类中。</p><p>静态AOP的优点：Aspect直接以java字节码的形式编译到java类。jvm可以想运行类一样运行，不会对系统造成任何性能损失。</p><p>静态AOP的缺点：灵活性不够，如果横切关注点需要改变织入位置，需要重新修改Aspect，编织进系统。</p><p>动态AOP：AOP的各种概念实体全部都是put的java类，所有容易开发和基础。Aspect和class一样以类的身份作为系统的一员。其织入过程在运行时进行，而不是预先编译织入。而且信息可以采用外部xml等形式保存，在调制编织点时不必变更系统其他模块，甚至在系统运行时，动态更改。但其缺点也很明显，就是在运行时编织，会造成一点的运行时性能损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件开发的目的最终是为了解决各种需求，包括业务需求和系统需求。使用面向对象的思想，我们可以对业务需求等普通关注点进行很好的抽象和封装，并且使之模块化。但对于系统需求一类的关注点来说，情况有所不同。&lt;/p&gt;
&lt;p&gt;对于业务需求而言，需求与具体实现直接的关系基本上是一对一的。我</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>创建者模式对比</title>
    <link href="http://example.com/2022/03/07/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2022/03/07/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/</id>
    <published>2022-03-07T07:55:00.000Z</published>
    <updated>2022-03-07T07:58:03.500Z</updated>
    
    <content type="html"><![CDATA[<p>工厂方法模式vs建造者模式</p><pre><code>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</code></pre><p>抽象工厂模式vs建造者模式</p><pre><code>    抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。    建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。    如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工厂方法模式vs建造者模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。

我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="创建者模式" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://example.com/2022/03/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T07:49:00.000Z</published>
    <updated>2022-03-07T07:55:15.846Z</updated>
    
    <content type="html"><![CDATA[<p>概述：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</p><p>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</p><p>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>结构：</p><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</p><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p><p>产品类（Product）：要创建的复杂对象。</p><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p><p>优点：<br>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p><p>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过<br>程更加清晰，也更方便使用程序来控制创建过程。</p><p>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</p><p>缺点：<br>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>使用场景：</p><p>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</p><p>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表<br>示是独立的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;p&gt;分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。&lt;/p&gt;
&lt;p&gt;由于实现了构建和</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="建造者模式" scheme="http://example.com/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://example.com/2022/03/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T07:41:00.000Z</published>
    <updated>2022-03-07T07:48:09.685Z</updated>
    
    <content type="html"><![CDATA[<p>概述：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p>结构：<br>原型模式包含如下角色：<br>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。<br>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。<br>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</p><p>  <img src="/images/pasted-126.png" alt="upload successful"></p><p>  原型模式的克隆分为浅克隆和深克隆。</p><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原<br>有属性所指向的对象的内存地址。</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。（使用对象流，先将原型对象存入file，然后从file读取，即为深克隆）</p><p>Java中的Object类中提供了clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。</p><p>使用场景：对象的创建非常复杂，可以使用原型模式快捷的创建对象。性能和安全要求比较高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。&lt;/p&gt;
&lt;p&gt;结构：&lt;br&gt;原型模式包含如下角色：&lt;br&gt;抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。&lt;br&gt;具体原型类：实现抽象原型类的 clone() 方法，</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原型模式" scheme="http://example.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
