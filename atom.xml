<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-07T13:01:58.232Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring AOP 一世</title>
    <link href="http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/"/>
    <id>http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/</id>
    <published>2022-03-07T12:03:00.000Z</published>
    <updated>2022-03-07T13:01:58.232Z</updated>
    
    <content type="html"><![CDATA[<p>AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint</p><p>Spring中以接口定义Pointcut作为其AOP框架中所有Pointcut的最顶级抽象，该接口定义了两个方法来捕获系统中相应的Joinpoint，并提供了一个TruePointcut类型实例。如果Pointcut类型为TruePointcut，默认会对系统中的所有对象，以及对象上所有被支持的Joinpoint进行匹配。</p><p> <img src="/images/pasted-129.png" alt="upload successful"></p><p> ClassFileter和MethodMatcher分别用于匹配将被执行织入操作的对象以及相应的方法。（重用不同级别的匹配定义，并且可以在不同或相同的级别上进行组合操作，或者强制让某个子类只覆写相应的方法）</p><p> <img src="/images/pasted-130.png" alt="upload successful"></p><p> Spring中各种advice实现全部遵循AOP ALLiance规定的接口。</p><p> <img src="/images/pasted-131.png" alt="upload successful"><br> advice实现了将被织入到Pointcut规定的Joinpoint处的横切逻辑。在Spring中，advice按照其自身实例能否在目标对象类的所有实例中共享这一标准，可以划分为两大类（per-class和per-instance）</p><p> per-class类型的advice：该类型可以在目标对象类的所有实例之间共享。这种类型的advice通常只提供方法拦截的功能。不会为目标对象类保存任何状态或添加新特性。除了上图没有列出的intriuduction类型的advice外，其余都属于pre-class。（如：BeforeAdvice、ThrowsAdvic、AfterReturningAdvice、AroundAdvice等）</p><p> per-instance类型的advice：introduction是唯一的一种per-instance型advice。其可以在不改目标类定义的情况下，为目标类添加新的属性和行为。</p><p> 当所有的Pointcut和advice准备好之后，就可以将其装入Aspect。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint&lt;/p&gt;
&lt;p&gt;Spring中以接口定义Pointcut作为其AOP框</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP的实现机制</title>
    <link href="http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-07T11:43:00.000Z</published>
    <updated>2022-03-07T11:57:38.005Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）。与最初AspectJ采用编译器将横切逻辑织入到目标对象不同，动态代理和字节码生成都是在运行期间为目标对象生成一个代理对象，而将横切逻辑织入到这个代理对象中，系统最终使用的是织入横切逻辑的代理对象而不是真正的目标对象。</p><p> <img src="/images/pasted-128.png" alt="upload successful"><br>注意：动态代理需要实现统一接口，而cglib生成字节码需要方法可以重写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP国家的公民</title>
    <link href="http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/"/>
    <id>http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/</id>
    <published>2022-03-07T10:33:00.000Z</published>
    <updated>2022-03-07T11:39:52.542Z</updated>
    
    <content type="html"><![CDATA[<p>Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。</p><p>Pointcut：Pointcut是Joinpoint的表达方式。将横切逻辑编织入当前系统的过程中，需要参考Pointcut规定的Joinpoint信息，才可以指定应该往系统的哪些Joinpoint上编织横切逻辑。即声明了一个Pointcut就指定了系统中符合条件的一组Joinpoint。</p><p>advice：advice是单一横切关注点逻辑的载体，它代表将会编织到Joinpoint的横切逻辑。如果将Aspect比作OOP中的class，那么advice就相当于class中的method。（常见的如before advice、after advice、after returning advice、after throwing advice，after advice、around advice等）</p><p>Aspect：Aspect是对系统中横切关注点进行模块化封装的AOP概念实体。通常情况下，Aspect可以含有多个Pointcut以及相关Advice定义。</p><p>织入和织入器：织入过程就是“飞架”AOP和OOP的那座桥，只有经过织入过程后，以Aspect模块化的横切关注点才会集成到OOP的现存系统中。而完成织入过程的那个人就是织入器。AspectJ有专门的编译器来完成织入操作，即ajc，所有ajc就是AspectJ完成织入的织入器；JBossAOP采用自定义的类加载器完成最终织入，那么这个类加载器就是他的织入器。SpringAOP使用一组自定义的类来完成最终的织入操作，proxyFactory类则是SpringAOP中最通用的织入器。</p><p>目标对象：符合Pointcut所指定的条件，将在织入过程中被织入横切逻辑的对象，称为目标对象。</p><p>当把所有这些概念组织到一个场景后，就有如下一副场景图：</p><p>   <img src="/images/pasted-127.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。&lt;/p&gt;
&lt;p&gt;Pointcut：Pointcut是Joinpoint的表达方</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>为什么需要AOP？</title>
    <link href="http://example.com/2022/03/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F/"/>
    <id>http://example.com/2022/03/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F/</id>
    <published>2022-03-07T08:29:00.000Z</published>
    <updated>2022-03-07T08:46:14.426Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发的目的最终是为了解决各种需求，包括业务需求和系统需求。使用面向对象的思想，我们可以对业务需求等普通关注点进行很好的抽象和封装，并且使之模块化。但对于系统需求一类的关注点来说，情况有所不同。</p><p>对于业务需求而言，需求与具体实现直接的关系基本上是一对一的。我们可以在系统中某一个确定的点找到针对这种需求的实现。</p><p>但是在开发测试中或者进入生产环境后需要对系统进行监控，我们需要添加日志功能，除此之外，业务方法的执行可能需要一定的权限限制。那么方法执行前需要有相应的安全检查功能。对于这些系统需求，想要以面向对象的方式实现并集成待整个系统中，不仅仅是一个需求对应一个实现那么简单。可能遍布所有的业务对象。</p><p>因此，提出了AOP（面向切面编程），我们可以对类似于logging和security等系统需求进行模块化组织，简化系统需求和实现的对比关系，进而使得整个系统的实现更具模块化。</p><p>AOP是一种理念，其实现需要一种方式。就好似OOP需要对应的语言支撑一样。AOP也需要某种语言帮助实现相应的概念实体（AOL）。</p><p>静态AOP：相应的横切关注点以Aspect形式实现后，会通过特定的编译器，将实现后的Aspect编织到系统的静态类中。</p><p>静态AOP的优点：Aspect直接以java字节码的形式编译到java类。jvm可以想运行类一样运行，不会对系统造成任何性能损失。</p><p>静态AOP的缺点：灵活性不够，如果横切关注点需要改变织入位置，需要重新修改Aspect，编织进系统。</p><p>动态AOP：AOP的各种概念实体全部都是put的java类，所有容易开发和基础。Aspect和class一样以类的身份作为系统的一员。其织入过程在运行时进行，而不是预先编译织入。而且信息可以采用外部xml等形式保存，在调制编织点时不必变更系统其他模块，甚至在系统运行时，动态更改。但其缺点也很明显，就是在运行时编织，会造成一点的运行时性能损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件开发的目的最终是为了解决各种需求，包括业务需求和系统需求。使用面向对象的思想，我们可以对业务需求等普通关注点进行很好的抽象和封装，并且使之模块化。但对于系统需求一类的关注点来说，情况有所不同。&lt;/p&gt;
&lt;p&gt;对于业务需求而言，需求与具体实现直接的关系基本上是一对一的。我</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>创建者模式对比</title>
    <link href="http://example.com/2022/03/07/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2022/03/07/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/</id>
    <published>2022-03-07T07:55:00.000Z</published>
    <updated>2022-03-07T07:58:03.500Z</updated>
    
    <content type="html"><![CDATA[<p>工厂方法模式vs建造者模式</p><pre><code>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</code></pre><p>抽象工厂模式vs建造者模式</p><pre><code>    抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。    建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。    如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工厂方法模式vs建造者模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。

我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="创建者模式" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://example.com/2022/03/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T07:49:00.000Z</published>
    <updated>2022-03-07T07:55:15.846Z</updated>
    
    <content type="html"><![CDATA[<p>概述：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</p><p>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</p><p>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>结构：</p><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</p><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p><p>产品类（Product）：要创建的复杂对象。</p><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p><p>优点：<br>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p><p>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过<br>程更加清晰，也更方便使用程序来控制创建过程。</p><p>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</p><p>缺点：<br>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>使用场景：</p><p>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</p><p>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表<br>示是独立的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;p&gt;分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。&lt;/p&gt;
&lt;p&gt;由于实现了构建和</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="建造者模式" scheme="http://example.com/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://example.com/2022/03/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T07:41:00.000Z</published>
    <updated>2022-03-07T07:48:09.685Z</updated>
    
    <content type="html"><![CDATA[<p>概述：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p>结构：<br>原型模式包含如下角色：<br>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。<br>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。<br>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</p><p>  <img src="/images/pasted-126.png" alt="upload successful"></p><p>  原型模式的克隆分为浅克隆和深克隆。</p><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原<br>有属性所指向的对象的内存地址。</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。（使用对象流，先将原型对象存入file，然后从file读取，即为深克隆）</p><p>Java中的Object类中提供了clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。</p><p>使用场景：对象的创建非常复杂，可以使用原型模式快捷的创建对象。性能和安全要求比较高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。&lt;/p&gt;
&lt;p&gt;结构：&lt;br&gt;原型模式包含如下角色：&lt;br&gt;抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。&lt;br&gt;具体原型类：实现抽象原型类的 clone() 方法，</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原型模式" scheme="http://example.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://example.com/2022/03/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T01:24:00.000Z</published>
    <updated>2022-03-07T01:39:37.035Z</updated>
    
    <content type="html"><![CDATA[<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，<br>直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。</p><p>1、简单工厂模式：简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><p>结构：</p><pre><code>简单工厂包含如下角色：抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。具体产品 ：实现或者继承抽象产品的子类具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</code></pre><p>优点：封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p>缺点：增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><p>拓展：静态工厂– 在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是<br>23种设计模式中的。</p><p>2、工厂方法模式：使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><p>概念：定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延<br>迟到其工厂的子类。</p><p>结构：</p><pre><code>工厂方法模式的主要角色：抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</code></pre><p>优点：<br>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，<br>满足开闭原则；</p><p>缺点：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p><p>3、抽象工厂模式：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生<br>产多个等级的产品。</p><pre><code>结构：抽象工厂模式的主要角色如下：抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</code></pre><p>优点：<br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><p>使用场景：</p><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><p>模式拓展（简单工厂+配置文件解除耦合）：可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全<br>类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p><p>jdk中的工厂方法使用：</p><p>1、集合-迭代器<br>2、DateForamt类中的getInstance()方法使用的是工厂模式；<br>3、Calendar类中的getInstance()方法使用的是工厂模式；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="工厂模式" scheme="http://example.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？</title>
    <link href="http://example.com/2022/03/05/elementData%E8%AE%BE%E7%BD%AE%E6%88%90%E4%BA%86transient%EF%BC%8C%E9%82%A3ArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%91%A2%EF%BC%9F/"/>
    <id>http://example.com/2022/03/05/elementData%E8%AE%BE%E7%BD%AE%E6%88%90%E4%BA%86transient%EF%BC%8C%E9%82%A3ArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%91%A2%EF%BC%9F/</id>
    <published>2022-03-05T05:00:00.000Z</published>
    <updated>2022-03-05T05:03:07.952Z</updated>
    
    <content type="html"><![CDATA[<p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p><p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p><p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p><p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p><p>源码如下：</p><pre><code>private void writeObject(java.io.ObjectOutputStream s)                throws java.io.IOException&#123;            // 防止序列化期间有修改            int expectedModCount = modCount;            // 写出非transient非static属性（会写出size属性）            s.defaultWriteObject();            // 写出元素个数        s.writeInt(size);            // 依次写出元素        for (int i=0; i&lt;size; i++) &#123;            s.writeObject(elementData[i]);        &#125;            // 如果有修改，抛出异常        if (modCount != expectedModCount) &#123;            throw new ConcurrentModificationException();        &#125;    &#125;        private void readObject(java.io.ObjectInputStream s)            throws java.io.IOException, ClassNotFoundException &#123;        // 声明为空数组        elementData = EMPTY_ELEMENTDATA;            // 读入非transient非static属性（会读取size属性）        s.defaultReadObject();            // 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读        s.readInt();            if (size &gt; 0) &#123;            // 计算容量            int capacity = calculateCapacity(elementData, size);            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);            // 检查是否需要扩容            ensureCapacityInternal(size);                Object[] a = elementData;            // 依次读取元素到数组中            for (int i=0; i&lt;size; i++) &#123;                a[i] = s.readObject();            &#125;        &#125;    &#125;    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。&lt;/p&gt;
&lt;p&gt;一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObjec</summary>
      
    
    
    
    <category term="集合" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/"/>
    
    <category term="ArrayList" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/ArrayList/"/>
    
    
    <category term="transient" scheme="http://example.com/tags/transient/"/>
    
  </entry>
  
  <entry>
    <title>反射和反序列化对单例模式的破坏</title>
    <link href="http://example.com/2022/03/05/%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A0%B4%E5%9D%8F/"/>
    <id>http://example.com/2022/03/05/%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A0%B4%E5%9D%8F/</id>
    <published>2022-03-05T01:45:00.000Z</published>
    <updated>2022-03-05T02:44:20.102Z</updated>
    
    <content type="html"><![CDATA[<p>除了枚举单列模式外，其余的单例实现方式都有可能被反射和反序列化所破坏。那么如何解决反射和反序列化对单例模式的破坏呢？</p><p>1、反射方式破解单例的解决方法:这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操<br>作。</p><pre><code>/** * @author atao * @version 1.0.0 * @ClassName Demo7.java * @Description 懒汉式-方式3（双重检查锁）双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检 * 测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问 * 题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 * 要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关 * 键字可以保证可见性和有序性。 * @createTime 2022年03月05日 10:35:00 */public class Demo7 &#123;private static volatile Demo7 singleton;private Demo7()&#123;    // 解决反射对单例模式的破坏    if (singleton != null)&#123;        throw new RuntimeException();    &#125;&#125;public static Demo7 getInstance()&#123;    if (singleton == null)&#123;        synchronized (Demo2.class)&#123;            if (singleton == null)&#123;                singleton = new Demo7();            &#125;        &#125;    &#125;    return singleton;&#125;&#125;</code></pre><p>2、在Singleton类中添加 readResolve() 方法，在反序列化时被反射调用，如果定义了这个方法，<br>就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><pre><code>/** * @author atao * @version 1.0.0 * @ClassName Demo8.java * @Description  懒汉式-方式4（静态内部类方式）静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态 * 内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 * static 修饰，保证只被实例化一次，并且严格保证实例化顺序。 * @createTime 2022年03月05日 10:37:00 */public class Demo8 &#123;    private Demo8 singleton;    private Demo8()&#123;    &#125;    private static class inner&#123;        public static Demo8 singleton = new Demo8();    &#125;    public static Demo8 getInstance()&#123;        return Demo8.inner.singleton;    &#125;    /**     * 解决反序列化对单例模式的破坏     * @return     */    private Object readResolve()&#123;        return Demo8.inner.singleton;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了枚举单列模式外，其余的单例实现方式都有可能被反射和反序列化所破坏。那么如何解决反射和反序列化对单例模式的破坏呢？&lt;/p&gt;
&lt;p&gt;1、反射方式破解单例的解决方法:这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操&lt;br&gt;作。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="破坏" scheme="http://example.com/tags/%E7%A0%B4%E5%9D%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件设计原则</title>
    <link href="http://example.com/2022/03/04/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/03/04/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2022-03-04T13:57:00.000Z</published>
    <updated>2022-03-04T14:04:16.777Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><p>1、开闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>2、里式替换原则：里氏代换原则是面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>3、依赖倒转原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>4、接口隔离原则：客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>5、迪米特法则：迪米特法则又叫最少知识原则。<br>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and<br>not to strangers）。<br>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发<br>该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。<br>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象<br>的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>6、合成复用原则：合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br>通常类的复用分为继承复用和合成复用两种。<br>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所<br>以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展<br>与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可<br>能发生变化。<br>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已<br>有对象的功能，它有以下优点：</li><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”<br>复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的<br>对象。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。&lt;/p&gt;
&lt;p&gt;1、开闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计原则" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>UML类图</title>
    <link href="http://example.com/2022/03/04/UML%E7%B1%BB%E5%9B%BE/"/>
    <id>http://example.com/2022/03/04/UML%E7%B1%BB%E5%9B%BE/</id>
    <published>2022-03-04T13:51:00.000Z</published>
    <updated>2022-03-04T13:57:31.240Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-117.png" alt="upload successful"></p><p> 属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p><p>+：表示public</p><p>-：表示private</p><p>#：表示protected</p><p>属性的完整表示方式是： 可见性 名称 ：类型 [ = 缺省值]<br>方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型]</p><p>类之间关系的表示方式：</p><p>1、关联关系：关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师<br>傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。</p><p> <img src="/images/pasted-118.png" alt="upload successful"></p><p> <img src="/images/pasted-119.png" alt="upload successful"></p><p> 自关联：</p><p> <img src="/images/pasted-120.png" alt="upload successful"></p><p> 2、聚合关系：聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。<br>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体<br>对象而独立存在。</p><p> <img src="/images/pasted-121.png" alt="upload successful"></p><p> 3、组合关系：组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，<br>部分对象不能脱离整体对象而存在。</p><p> <img src="/images/pasted-122.png" alt="upload successful"></p><p> 4、依赖关系：依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方<br>法来完成一些职责。</p><p> <img src="/images/pasted-123.png" alt="upload successful"></p><p> 5、继承关系：继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p> <img src="/images/pasted-124.png" alt="upload successful"></p><p> 6、实现关系：实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p> <img src="/images/pasted-125.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-117.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：&lt;/p&gt;
&lt;p&gt;+：表示public&lt;/p</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="UML" scheme="http://example.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>设计模式的分类</title>
    <link href="http://example.com/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://example.com/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2022-03-04T13:31:00.000Z</published>
    <updated>2022-03-04T13:34:39.072Z</updated>
    
    <content type="html"><![CDATA[<p>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。（单例、原型、工厂方法、抽象工厂、建造者等）</p><p>结构型模式：用于描述如何将类或对象按某种布局成更大的结构。（代理、适配器、桥接、装饰、外观、享元、组合等）</p><p>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。（模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访<br>问者、备忘录、解释器等）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。（单例、原型、工厂方法、抽象工厂、建造者等）&lt;/p&gt;
&lt;p&gt;结构型模式：用于描述如何将类或对象按某种布局成更大的结构。（代理、适配器、桥接、装饰、外观、享元、组合等）&lt;/p&gt;
&lt;p&gt;行为型模式：</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="分类" scheme="http://example.com/tags/%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>将革命进行得更彻底一些（classpath-scanning 功能介绍）</title>
    <link href="http://example.com/2022/03/04/%E5%B0%86%E9%9D%A9%E5%91%BD%E8%BF%9B%E8%A1%8C%E5%BE%97%E6%9B%B4%E5%BD%BB%E5%BA%95%E4%B8%80%E4%BA%9B%EF%BC%88classpath-scanning-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
    <id>http://example.com/2022/03/04/%E5%B0%86%E9%9D%A9%E5%91%BD%E8%BF%9B%E8%A1%8C%E5%BE%97%E6%9B%B4%E5%BD%BB%E5%BA%95%E4%B8%80%E4%BA%9B%EF%BC%88classpath-scanning-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%89/</id>
    <published>2022-03-04T08:23:00.000Z</published>
    <updated>2022-03-04T09:01:35.117Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们还是需要将相应对象的bean定义，一个个地添加到IoC容器的配置文件中。与之前唯一的区别就是，不用在配置文件中明确指定依赖关<br>系了（改用注解来表达了嘛）。。既然使用注解来表达对象之间的依赖注入关系，那为什么不搞的彻底<br>一点儿，将那些几乎“光秃秃”的bean定义从配置文件中彻底消灭呢？OK，我们想到了，Spring开发<br>团队也想到了，classpath-scanning的功能正是因此而诞生的！</p><p>使用相应的注解对组成应用程序的相关类进行标注之后，classpath-scanning功能可以从某一顶层<br>包（base package）开始扫描。当扫描到某个类标注了相应的注解之后，就会提取该类的相关信息，构<br>建对应的BeanDefinition，然后把构建完的BeanDefinition注册到容器。这之后所发生的事情就不<br>用我说了，既然相关的类已经添加到了容器，那么后面BeanPostProcessor为@Autowired或者<br>@Resource所提供的注入肯定是有东西拿咯！</p><p>classpath-scanning功能的触发是由<a href="context:component-scan">context:component-scan</a>决定的。</p><p><a href="context:component-scan">context:component-scan</a>默认扫描的注解类型是@Component。不过，在@Component语义基<br>础上细化后的@Repository、@Service和@Controller也同样可以获得<a href="context:component-scan">context:component-scan</a><br>的青睐。@Component的语义更广、更宽泛，而@Repository、@Service和@Controller的语义则更具<br>体。所以，同样对于服务层的类定义来说，使用@Service标注它，要比使用@Component更为确切。<br>对于其他两种注解也是同样道理，我们暂且使用语义更广的@Component来标注FXNews相关类，以便<br>摆脱每次都要向IoC容器配置添加bean定义的苦恼。</p><p><a href="context:component-scan">context:component-scan</a>在扫描相关类定义并将它们添加到容器的时候，会使用一种默认的<br>命名规则，来生成那些添加到容器的bean定义的名称（beanName）。比如DowJonesNewsPersister通<br>过默认命名规则将获得dowJonesNewsPersister作为bean定义名称。如果想改变这一默认行为，可以指定一个自定义的名称</p><p>你或许会觉得有些诧异，因为我们并没有使用<a href="context:annotation-config">context:annotation-config</a>甚至直接将相应<br>的BeanPostProcessor添加到容器中，而FXNewsProvider怎么会获得相应的依赖注入呢？这个得怪<br><a href="context:component-scan">context:component-scan</a>“多管闲事”，它同时将AutowiredAnnotationBeanPostProcessor和<br>CommonAnnotationBeanPostProcessor一并注册到了容器中，所以，依赖注入的需求得以满足。如<br>果你不喜欢，非要自己通过 <a href="context:annotation-config">context:annotation-config</a> 或者直接添加相关 BeanPostProcessor的方式来满足@Autowired或者@Resource的需求，可以将<a href="context:component-scan">context:component-scan</a>的<br>annotation-config属性值从默认的true改为false。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;到目前为止，我们还是需要将相应对象的bean定义，一个个地添加到IoC容器的配置文件中。与之前唯一的区别就是，不用在配置文件中明确指定依赖关&lt;br&gt;系了（改用注解来表达了嘛）。。既然使用注解来表达对象之间的依赖注入关系，那为什么不搞的彻底&lt;br&gt;一点儿，将那些几乎“光秃秃”</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="IOC" scheme="http://example.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>Autowired之外的选择——使用JSR250 标注依赖注入关系</title>
    <link href="http://example.com/2022/03/04/Autowired%E4%B9%8B%E5%A4%96%E7%9A%84%E9%80%89%E6%8B%A9%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8JSR250-%E6%A0%87%E6%B3%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%85%B3%E7%B3%BB/"/>
    <id>http://example.com/2022/03/04/Autowired%E4%B9%8B%E5%A4%96%E7%9A%84%E9%80%89%E6%8B%A9%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8JSR250-%E6%A0%87%E6%B3%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%85%B3%E7%B3%BB/</id>
    <published>2022-03-04T08:20:00.000Z</published>
    <updated>2022-03-04T08:22:53.133Z</updated>
    
    <content type="html"><![CDATA[<p>除了可以使用Spring提供的@Autowired和@Qualifier来<br>标注相应类定义之外，还可以使用JSR250的@Resource和@PostConstruct以及@PreDestroy对相应<br>类进行标注，这同样可以达到依赖注入的目的。</p><p>@Resource与@Autowired不同，它遵循的是byName自动绑定形式的行为准则，也就是说，IoC容<br>器将根据@Resource所指定的名称，到容器中查找beanName与之对应的实例，然后将查找到的对象实<br>例注入给@Resource所标注的对象。</p><p>JSR250规定，如果@Resource标注于属性域或者方法之上的话，相应的容器将负责把指定的资源<br>注入给当前对象，所以，除了像我们这样直接在属性域上标注@Resource，还可以在构造方法或者普<br>通方法定义上标注@Resource，这与@Autowired能够存在的地方大致相同。</p><p>确切地说， 10 @PostConstruct和@PreDestroy不是服务于依赖注入的，它们主要用于标注对象生<br>命周期管理相关方法，这与Spring的InitializingBean和DisposableBean接口，以及配置项中的<br>init-method和destroy-method起到类似的作用。</p><p>如果想某个方法在对象实例化之后被调用，以做某些准备工作，或者想在对象销毁之前调用某个<br>方法清理某些资源，那么就可以像我们这样，使用@PostConstruct和@PreDestroy来标注这些方法。<br>当然，是使用@PostConstruct和@PreDestroy，还是使用Spring的InitializingBean和Disposable-Bean接口，或者init-method和destroy-method配置项，可以根据个人的喜好自己决定。</p><p>天上永远不会掉馅饼，我们只是使用@Resource或者@PostConstruct和@PreDestroy标注了相应<br>对象，并不能给该对象带来想要的东西。所以，就像@Autowired需要AutowiredAnnotationBeanPostProcessor为它与IoC容器牵线搭桥一样，JSR250的这些注解也同样需要一个BeanPostProcessor帮助它们实现自身的价值。这个BeanPostProcessor就是org.springframework.context.<br>annotation.CommonAnnotationBeanPostProcessor，只有将CommonAnnotationBeanPostProcessor添<br>加到容器，JSR250的相关注解才能发挥作用</p><p>既然不管是@Autowired还是@Resource都需要添加相应的BeanPostProcessor到容器，那么我们<br>就可以在基于XSD的配置文件中使用一个<a href="context:annotation-config">context:annotation-config</a>配置搞定以上所有的<br>BeanPostProcessor配置</p><p><a href="context:annotation-config">context:annotation-config</a> 不但帮我们把 AutowiredAnnotationBeanPostProcessor 和<br>CommonAnnotationBeanPostProcessor注册到容器，同时还会把PersistenceAnnotationBeanPostProcessor和RequiredAnnotationBeanPostProcessor一并进行注册，可谓一举四得啊！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了可以使用Spring提供的@Autowired和@Qualifier来&lt;br&gt;标注相应类定义之外，还可以使用JSR250的@Resource和@PostConstruct以及@PreDestroy对相应&lt;br&gt;类进行标注，这同样可以达到依赖注入的目的。&lt;/p&gt;
&lt;p&gt;@</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Qualifier的陪伴</title>
    <link href="http://example.com/2022/03/04/Qualifier%E7%9A%84%E9%99%AA%E4%BC%B4/"/>
    <id>http://example.com/2022/03/04/Qualifier%E7%9A%84%E9%99%AA%E4%BC%B4/</id>
    <published>2022-03-04T08:19:00.000Z</published>
    <updated>2022-03-04T08:20:06.461Z</updated>
    
    <content type="html"><![CDATA[<p>@Autowired是按照类型进行匹配，如果当前@Autowired标注的依赖在容器中只能找到一个实例<br>与之对应的话，那还好。可是，要是能够同时找到两个或者多个同一类型的对象实例，又该怎么办呢？<br>我们自己当然知道应该把具体哪个实例注入给当前对象，可是，IoC容器并不知道，所以，得通过某<br>种方式告诉它。这时，就可以使用@Qualifier对依赖注入的条件做进一步限定，使得容器不再迷茫。</p><p>@Qualifier实际上是byName自动绑定的注解版，既然IoC容器无法自己从多个同一类型的实例中<br>选取我们真正想要的那个，那么我们不妨就使用@Qualifier直接点名要哪个好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@Autowired是按照类型进行匹配，如果当前@Autowired标注的依赖在容器中只能找到一个实例&lt;br&gt;与之对应的话，那还好。可是，要是能够同时找到两个或者多个同一类型的对象实例，又该怎么办呢？&lt;br&gt;我们自己当然知道应该把具体哪个实例注入给当前对象，可是，IoC容器</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring基于注解的依赖注入</title>
    <link href="http://example.com/2022/03/04/Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/03/04/Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</id>
    <published>2022-03-04T08:14:00.000Z</published>
    <updated>2022-03-04T08:18:55.251Z</updated>
    
    <content type="html"><![CDATA[<p>@Autowired是基于注解的依赖注入的核心注解，它的存在可以让容器知道需要为当前类注入哪些<br>依赖。比如可以使用@Autowired对类进行标注，以表明要为该类注入的依赖。</p><p>@Autowired也是按照类型匹配进行依赖注入的</p><p>@Autowired可以标注于类定义的多个位置，包括如下几个。</p><p>1、域（Filed）或者说属性（Property）。不管它们声明的访问限制符是private、protected还是public，只要标注了@Autowired，它们所需要的依赖注入需求就都能够被满足。</p><p>2、构造方法定义（Constructor）。标注于类的构造方法之上的@Autowired，相当于抢夺了原有自<br>动绑定功能中“constructor”方式的权利，它将根据构造方法参数类型，来决定将什么样的依赖对象注入给当前对象。</p><p>3、方法定义（Method）。@Autowired不仅可以标注于传统的setter方法之上，而且还可以标注于任<br>意名称的方法定义之上，只要该方法定义了需要被注入的参数。</p><p>现在，虽然可以随意地在类定义的各种合适的地方标注@Autowired，希望这些被@Autowired标<br>注的依赖能够被注入，但是，仅将@Autowired标注于类定义中并不能让Spring的IoC容器聪明到自己<br>去查看这些注解，然后注入符合条件的依赖对象。容器需要某种方式来了解，哪些对象标注了<br>@Autowired，哪些对象可以作为可供选择的依赖对象来注入给需要的对象。在考虑使用什么方式实<br>现这一功能之前，我们先比较一下原有的自动绑定功能与使用@Autowired之后产生了哪些差别。</p><p>使用自动绑定的时候，我们将所有对象相关的bean定义追加到了容器的配置文件中，然后使用<br>default-autowire或者autowire告知容器，依照这两种属性指定的绑定方式，将容器中各个对象绑定到一起。在使用@Autowired之后，default-autowire或者autowire的职责就转给了@Autowired，<br>所以，现在，容器的配置文件中就只剩下了一个个孤伶伶的bean定义</p><p>为了给容器中定义的每个bean定义对应的实例注入依赖，可以遍历它们，然后通过反射，检查每<br>个bean定义对应的类上各种可能位置上的@Autowired。如果存在的话，就可以从当前容器管理的对象<br>中获取符合条件的对象，设置给@Autowired所标注的属性域、构造方法或者方法定义。</p><p>我们可以提供一个Spring<br>的IoC容器使用的BeanPostProcessor自定义实现，让这个BeanPostProcessor在实例化bean定义的<br>过程中，来检查当前对象是否有@Autowired标注的依赖需要注入。org.springframework.beans.<br>factory.annotation.AutowiredAnnotationBeanPostProcessor就是Spring提供的用于这一目的<br>的BeanPostProcessor实现。所以，很幸运，我们不用自己去实现它了。</p><p>相关类定义使用@Autowired标注之后，只要在IoC容器的配置文件中追加AutowiredAnnotationBeanPostProcessor就可以让整个应用开始运作了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@Autowired是基于注解的依赖注入的核心注解，它的存在可以让容器知道需要为当前类注入哪些&lt;br&gt;依赖。比如可以使用@Autowired对类进行标注，以表明要为该类注入的依赖。&lt;/p&gt;
&lt;p&gt;@Autowired也是按照类型匹配进行依赖注入的&lt;/p&gt;
&lt;p&gt;@Autow</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>ApplicationContext统一资源加载策略</title>
    <link href="http://example.com/2022/03/04/ApplicationContext%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/"/>
    <id>http://example.com/2022/03/04/ApplicationContext%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/</id>
    <published>2022-03-04T07:24:00.000Z</published>
    <updated>2022-03-04T07:55:24.970Z</updated>
    
    <content type="html"><![CDATA[<p>Spring框架内部使用org.springframework.core.io.Resource接口作为所有资源的抽象和访<br>问接口</p><p>其中ClassPathResource就是Resource的一个特定类型的实现，代表的是位于Classpath中的资源。</p><p>Resource接口可以根据资源的不同类型，或者资源所处的不同场合，给出相应的具体实现。Spring<br>框架在这个理念的基础上，提供了一些实现类（可以在org.springframework.core.io包下找到这<br>些实现类）。</p><p> ByteArrayResource。将字节（byte）数组提供的数据作为一种资源进行封装，如果通过<br>InputStream形式访问该类型的资源，该实现会根据字节数组的数据，构造相应的ByteArrayInputStream并返回。</p><p> ClassPathResource。该实现从Java应用程序的ClassPath中加载具体资源并进行封装，可以使<br>用指定的类加载器（ClassLoader）或者给定的类进行资源加载。 </p><p> FileSystemResource。对java.io.File类型的封装，所以，我们可以以文件或者URL的形<br>式对该类型资源进行访问，只要能跟File打的交道，基本上跟FileSystemResource也可以。  </p><p> UrlResource。通过java.net.URL进行的具体资源查找定位的实现类，内部委派URL进行具<br>体的资源操作。  </p><p> InputStreamResource。将给定的InputStream视为一种资源的Resource实现类，较为少用。<br>可能的情况下，以ByteArrayResource以及其他形式资源实现代之。</p><p>如果给定的实现类不满足需求，还可以通过实现Resource接口自定义。</p><p>org.springframework.core.io.ResourceLoader接口是资源查找定位策略的统一抽象，具体的资源查找定<br>位策略则由相应的ResourceLoader实现类给出。</p><p>其中最主要的就是Resource getResource(String location);方法，通过它，我们就可以根<br>据指定的资源位置，定位到具体的资源实例。</p><p>1、可用的ResourceLoader：</p><p>ResourceLoader有一个默认的实现类，即org.springframework.core.io.DefaultResourceLoader，该类默认的资源查找处理逻辑如下。</p><p>(1) 首先检查资源路径是否以classpath:前缀打头，如果是，则尝试构造ClassPathResource类<br>型资源并返回。</p><p>(2) 否则，(a) 尝试通过URL，根据资源路径来定位资源，如果没有抛出MalformedURLException，<br>有则会构造UrlResource类型的资源并返回；(b)如果还是无法根据资源路径定位指定的资源，则委派<br>getResourceByPath(String) 方法来定位， DefaultResourceLoader 的<br>getResourceByPath(String)方法默认实现逻辑是，构造ClassPathResource类型的资源并返回。</p><p>为了避免DefaultResourceLoader在最后getResourceByPath(String)方法上的不恰当处理，<br>我们可以使用org.springframework.core.io.FileSystemResourceLoader，它继承自DefaultResourceLoader，但覆写了getResourceByPath(String)方法，使之从文件系统加载资源并以<br>FileSystemResource类型返回。这样，我们就可以取得预想的资源类型。</p><p>FileSystemResourceLoader在ResourceLoader家族中的兄弟FileSystemXmlApplicationContext，也是覆写了getResourceByPath(String)方法的逻辑，以改变DefaultResourceLoader的<br>默认资源加载行为，最终从文件系统中加载并返回FileSystemResource类型的资源。</p><p>2、 ResourcePatternResolver ——批量查找的ResourceLoader：</p><p>ResourcePatternResolver是ResourceLoader的扩展，ResourceLoader每次只能根据资源路径<br>返回确定的单个Resource实例，而ResourcePatternResolver则可以根据指定的资源路径匹配模式，<br>每次返回多个Resource实例。</p><p>ResourcePatternResolver在继承ResourceLoader原有定义的基础上，又引入了Resource[]<br>getResources(String)方法定义，以支持根据路径匹配模式返回多个Resources的功能。它同时还<br>引入了一种新的协议前缀classpath*:，针对这一点的支持，将由相应的子类实现给出。</p><p>ResourcePatternResolver最常用的一个实现是org.springframework.core.io.support.<br>PathMatchingResourcePatternResolver，该实现类支持ResourceLoader级别的资源加载，支持基<br>于Ant风格的路径匹配模式（类似于**/<em>.suffix之类的路径形式），支持ResourcePatternResolver新<br>增加的classpath</em>:前缀等，基本上集所有技能于一身。</p><p>在构造PathMatchingResourcePatternResolver实例的时候，可以指定一个ResourceLoader，<br>如果不指定的话，则PathMatchingResourcePatternResolver内部会默认构造一个DefaultResourceLoader实例。PathMatchingResourcePatternResolver内部会将匹配后确定的资源路径，<br>委派给它的ResourceLoader来查找和定位资源。这样，如果不指定任何ResourceLoader的话，PathMatchingResourcePatternResolver在加载资源的行为上会与DefaultResourceLoader基本相同，<br>只存在返回的Resource数量上的差异。</p><p>不过，可以通过传入其他类型的ResourceLoader来替换PathMatchingResourcePatternResolver<br>内部默认使用的DefaultResourceLoader，从而改变其默认行为。</p><p> <img src="/images/pasted-115.png" alt="upload successful"></p><p> ApplicationContext继承了ResourcePatternResolver，当<br>然就间接实现了ResourceLoader接口。所以，任何的ApplicationContext实现都可以看作是一个<br>ResourceLoader甚至ResourcePatternResolver。而这就是ApplicationContext支持Spring内统一<br>资源加载策略的真相。</p><p>通常，所有的ApplicationContext实现类会直接或者间接地继承org.springframework.<br>context.support.AbstractApplicationContext，从这个类上，我们就可以看到ApplicationContext与ResourceLoader之间的所有关系。AbstractApplicationContext继承了DefaultResourceLoader，那么，它的getResource(String)当然就直接用DefaultResourceLoader的了。剩<br>下需要它“效劳”的，就是ResourcePatternResolver的Resource[]getResources (String)，当<br>然，AbstractApplicationContext也不负众望，当即拿下。AbstractApplicationContext类的内<br>部声明有一个resourcePatternResolver，类型是ResourcePatternResolver，对应的实例类型为<br>PathMatchingResourcePatternResolver 。之前我们说过 PathMatchingResourcePatternResolver构造的时候会接受一个ResourceLoader，而AbstractApplicationContext本身又继承自<br>DefaultResourceLoader，当然就直接把自身给“贡献”了。这样，整个ApplicationContext的实<br>现类就完全可以支持ResourceLoader或者ResourcePatternResolver接口，你能说ApplicationContext不支持Spring的统一资源加载吗？说白了，ApplicationContext的实现类在作为ResourceLoader或者ResourcePatternResolver时候的行为，完全就是委派给了PathMatchingResourcePatternResolver和DefaultResourceLoader来做。</p><p> <img src="/images/pasted-116.png" alt="upload successful"></p><p> 1、既然ApplicationContext可以作为ResourceLoader或者ResourcePatternResolver来使用，<br>那么，很显然，我们可以通过ApplicationContext来加载任何Spring支持的Resource类型。与直接<br>使用ResourceLoader来做这些事情相比，很明显，ApplicationContext的表现过于“谦虚”了。</p><p>2、ApplicationContext容器本身就是一个ResourceLoader，我们为了该类还需要单独提供<br>一个resourceLoader实例就有些多于了，直接将当前的ApplicationContext容器作为ResourceLoader注入不就行了？而ResourceLoaderAware和ApplicationContextAware接口正好可以帮助我<br>们做到这一点，只不过现在的FooBar需要依赖于Spring的API了。不过，在我看来，这没有什么大不<br>了，因为我们从来也没有真正逃脱过依赖（这种依赖也好，那种依赖也罢）。</p><p>3、容器可以将bean定义文件中的字符串形式表达的信息，正确地转换成具体对象定<br>义的依赖类型。对于那些Spring容器提供的默认的PropertyEditors无法识别的对象类型，我们可以<br>提供自定义的PropertyEditor实现并注册到容器中，以供容器做类型转换的时候使用。默认情况下，<br>BeanFactory容器不会为org.springframework.core.io.Resource类型提供相应的PropertyEditor，所以，如果我们想注入Resource类型的bean定义，就需要注册自定义的PropertyEditor到<br>BeanFactory容器。不过，对于ApplicationContext来说，我们无需这么做，因为ApplicationContext容器可以正确识别Resource类型并转换后注入相关对象。</p><p>4、特定的 10 ApplicationContext容器实现，在作为ResourceLoader加载资源时，会有其特定的行为。<br>我们下面主要讨论两种类型的ApplicationContext容器，即ClassPathXmlApplicationContext和<br>FileSystemXmlApplicationContext。其他类型的ApplicationContext容器，会在稍后章节中提到。 11<br>我们知道，对于URL所接受的资源路径来说，通常开始都会有一个协议前缀，比如file:、http:、ftp:<br>等。既然Spring使用UrlResource对URL定位查找的资源进行了抽象，那么，同样也支持这样类型的<br>资源路径，而且，在这个基础上，Spring还扩展了协议前缀的集合。ResourceLoader中增加了一种新<br>的资源路径协议——classpath:，ResourcePatternResolver又增加了一种——classpath*:。这<br>样，我们就可以通过这些资源路径协议前缀，明确地告知Spring容器要从classpath中加载资源</p><p>当ClassPathXmlApplicationContext在实例化的时候，即使没有指明<br>classpath:或者classpath*:等前缀，它会默认从classpath中加载bean定义配置文件</p><p>而FileSystemXmlApplicationContext则有些不同，如果我们像如下代码那样指定conf/<br>appContext.xml，它会尝试从文件系统中加载bean定义文件</p><p>不过，我们可以像如下代码所示，通过在资源路径之前增加classpath:前缀，明确指定<br>FileSystemXmlApplicationContext从classpath中加载bean定义的配置文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring框架内部使用org.springframework.core.io.Resource接口作为所有资源的抽象和访&lt;br&gt;问接口&lt;/p&gt;
&lt;p&gt;其中ClassPathResource就是Resource的一个特定类型的实现，代表的是位于Classpath中的资源。&lt;</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="资源加载" scheme="http://example.com/tags/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC容器 ApplicationContext</title>
    <link href="http://example.com/2022/03/04/Spring-IoC%E5%AE%B9%E5%99%A8-ApplicationContext/"/>
    <id>http://example.com/2022/03/04/Spring-IoC%E5%AE%B9%E5%99%A8-ApplicationContext/</id>
    <published>2022-03-04T07:21:00.000Z</published>
    <updated>2022-03-04T07:23:24.352Z</updated>
    
    <content type="html"><![CDATA[<p>作为Spring提供的较之BeanFactory更为先进的IoC容器实现，ApplicationContext除了拥有<br>BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能，包括BeanFactoryPostProcessor、BeanPostProcessor以及其他特殊类型bean的自动识别、容器启动后bean实例的自动初始化、<br>国际化的信息支持、容器内事件发布等。</p><p>常见的ApplicationContext实现类有 </p><p>org.springframework.context.support.FileSystemXmlApplicationContext。在默认<br>情况下，从文件系统加载bean定义以及相关资源的ApplicationContext实现。</p><p>org.springframework.context.support.ClassPathXmlApplicationContext。在默认情况下，从Classpath加载bean定义以及相关资源的ApplicationContext实现。 </p><p>org.springframework.web.context.support.XmlWebApplicationContext。Spring提供的用于Web应用程序的ApplicationContext实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为Spring提供的较之BeanFactory更为先进的IoC容器实现，ApplicationContext除了拥有&lt;br&gt;BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能，包括BeanFactoryPostProcessor、BeanPostPr</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>了解Spring中bean的一生</title>
    <link href="http://example.com/2022/03/04/%E4%BA%86%E8%A7%A3Spring%E4%B8%ADbean%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <id>http://example.com/2022/03/04/%E4%BA%86%E8%A7%A3Spring%E4%B8%ADbean%E7%9A%84%E4%B8%80%E7%94%9F/</id>
    <published>2022-03-04T06:10:00.000Z</published>
    <updated>2022-03-04T06:52:30.847Z</updated>
    
    <content type="html"><![CDATA[<p>容器启动之后，并不会马上就实例化相应的bean定义。我们知道，容器现在仅仅拥有所有对象的BeanDefinition来保存实例化阶段将要用的必要信息。只有当请求方通过BeanFactory的getBean()方法来请求某个对象实例的时候，才有可能触发Bean实例化阶段的活动。BeanFactory的getBean（）<br>法可以被客户端对象显式调用，也可以在容器内部隐式地被调用。隐式调用有如下两种情况。</p><p> 对于BeanFactory来说，对象实例化默认采用延迟初始化。通常情况下，当对象A被请求而需<br>要第一次实例化的时候，如果它所依赖的对象B之前同样没有被实例化，那么容器会先实例化对象A所依赖的对象。这时容器内部就会首先实例化对象B，以及对象 A依赖的其他还没有实例化的对象。这种情况是容器内部调用getBean()，对于本次请求的请求方是隐式的。</p><p> ApplicationContext启动之后会实例化所有的bean定义，但ApplicationContext在实现的过程中依然遵循Spring容器实现流程的两个阶段，只不过它<br>会在启动阶段的活动完成之后，紧接着调用注册到该容器的所有bean定义的实例化方法<br>getBean()。这就是为什么当你得到ApplicationContext类型的容器引用时，容器内所有对<br>象已经被全部实例化完成。不信你查一下类org.<br>AbstractApplicationContext的refresh()方法。</p><p> <img src="/images/pasted-113.png" alt="upload successful"></p><p> 1、 Bean的实例化与</p><p> BeanWrapper：容器在内部实现的时候，采用“策略模式（Strategy Pattern）”来决定采用何种方式初始化bean实例。<br>通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类。</p><p>org.springframework.beans.factory.support.InstantiationStrategy定义是实例化策略<br>的抽象接口，其直接子类SimpleInstantiationStrategy实现了简单的对象实例化功能，可以通过<br>反射来实例化对象实例，但不支持方法注入方式的对象实例化。CglibSubclassingInstantiationStrategy继承了SimpleInstantiationStrategy的以反射方式实例化对象的功能，并且通过CGLIB<br>的动态字节码生成功能，该策略实现类可以动态生成某个类的子类，进而满足了方法注入所需的对象<br>实例化需求。默认情况下，容器内部采用的是CglibSubclassingInstantiationStrategy。</p><p>容器只要根据相应bean定义的BeanDefintion取得实例化信息，结合CglibSubclassingInstantiationStrategy以及不同的bean定义类型，就可以返回实例化完成的对象实例。但是，返回方<br>式上有些“点缀”。不是直接返回构造完成的对象实例，而是以BeanWrapper对构造完成的对象实例<br>进行包裹，返回相应的BeanWrapper实例。</p><p>BeanWrapper接口通常在Spring框架内部使用，它有一个实现类org.springframework.beans.<br>BeanWrapperImpl。其作用是对某个bean进行“包裹”，然后对这个“包裹”的bean进行操作，比如设置或者获取bean的相应属性值。而在第一步结束后返回BeanWrapper实例而不是原先的对象实例，<br>就是为了第二步“设置对象属性”。</p><p>BeanWrapper定义继承了org.springframework.beans.PropertyAccessor接口，可以以统一的<br>方式对对象属性进行访问；BeanWrapper定义同时又直接或者间接继承了PropertyEditorRegistry<br>和TypeConverter接口。不知你是否还记得CustomEditorConfigurer？当把各种PropertyEditor注<br>册给容器时，知道后面谁用到这些PropertyEditor吗？对，就是BeanWrapper！在第一步构造完成<br>对象之后，Spring会根据对象实例构造一个BeanWrapperImpl实例，然后将之前CustomEditorConfigurer注册的PropertyEditor复制一份给BeanWrapperImpl实例（这就是BeanWrapper同时又<br>是PropertyEditorRegistry的原因）。这样，当BeanWrapper转换类型、设置对象属性值时，就不<br>会无从下手了。</p><p>2、 各色的Aware接口：</p><p>当对象实例化完成并且相关属性以及依赖设置完成之后，Spring容器会检查当前对象实例是否实<br>现了一系列的以Aware命名结尾的接口定义。如果是，则将这些Aware接口定义中规定的依赖注入给当前对象实例。</p><p>3、 BeanPostProcessor</p><p>BeanPostProcessor的概念容易与BeanFactoryPostProcessor的概念混淆。但只要记住BeanPostProcessor是存在于对象实例化阶段，而BeanFactoryPostProcessor则是存在于容器启动阶段，<br>这两个概念就比较容易区分了。</p><p>与BeanFactoryPostProcessor通常会处理容器内所有符合条件的BeanDefinition类似，BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例。该接口声明了两个方法，分别在<br>两个不同的时机执行。postProcessBeforeInitialization()方法是BeanPostProcessor前置处理这一步将<br>会执行的方法，postProcessAfterInitialization()则是对应BeanPostProcessor后置处<br>理那一步将会执行的方法。BeanPostProcessor的两个方法中都传入了原来的对象实例的引用，这为<br>我们扩展容器的对象实例化过程中的行为提供了极大的便利，我们几乎可以对传入的对象实例执行任<br>何的操作。</p><p>通常比较常见的使用BeanPostProcessor的场景，是处理标记接口实现类，或者为当前对象提供<br>代理实现。除了检查标记接口以便应用自定义逻辑，还可以通过BeanPostProcessor对当前对象实例做更多<br>的处理。比如替换当前对象实例或者字节码增强当前对象实例等。Spring的AOP则更多地使用<br>BeanPostProcessor来为对象生成相应的代理对象，如org.springframework.aop.framework.<br>autoproxy.BeanNameAutoProxyCreator。</p><p> <img src="/images/pasted-114.png" alt="upload successful"></p><p> 4、 InitializingBean和init-method：</p><p> org.springframework.beans.factory.InitializingBean是容器内部广泛使用的一个对象生<br>命周期标识接口</p><p>该接口定义很简单，其作用在于，在对象实例化过程调用过“BeanPostProcessor的前置处理”<br>之后，会接着检测当前对象是否实现了InitializingBean接口，如果是，则会调用其afterPropertiesSet()方法进一步调整对象实例的状态。比如，在有些情况下，某个业务对象实例化完成后，还<br>不能处于可以使用状态。这个时候就可以让该业务对象实现该接口，并在方法afterPropertiesSet()<br>中完成对该业务对象的后续处理。</p><p>虽然该接口在Spring容器内部广泛使用，但如果真的让我们的业务对象实现这个接口，则显得<br>Spring容器比较具有侵入性。所以，Spring还提供了另一种方式来指定自定义的对象初始化操作，那就<br>是在XML配置的时候，使用<bean>的init-method属性。</p><p>  通过init-method，系统中业务对象的自定义初始化操作可以以任何方式命名，而不再受制于<br>InitializingBean的afterPropertiesSet()。如果系统开发过程中规定：所有业务对象的自定义初<br>始化操作都必须以init()命名，为了省去挨个<bean>的设置init-method这样的烦琐，我们还可以通<br>过最顶层的<beans>的default-init-method统一指定这一init()方法名。</p><p> 5、 DisposableBean与destroy-method：</p><p> 当所有的一切，该设置的设置，该注入的注入，该调用的调用完成之后，容器将检查singleton类<br>型的bean实例，看其是否实现了org.springframework.beans.factory.DisposableBean接口。或<br>者其对应的bean定义是否通过<bean>的destroy-method属性指定了自定义的对象销毁方法。如果是，<br>就会为该实例注册一个用于对象销毁的回调（Callback），以便在这些singleton类型的对象实例销毁之<br>前，执行销毁逻辑。</p><p>  与InitializingBean和init-method用于对象的自定义初始化相对应，DisposableBean和<br>destroy-method为对象提供了执行自定义销毁逻辑的机会。</p><p>最常见到的该功能的使用场景就是在Spring容器中注册数据库连接池，在系统退出后，连接池应<br>该关闭，以释放相应资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;容器启动之后，并不会马上就实例化相应的bean定义。我们知道，容器现在仅仅拥有所有对象的BeanDefinition来保存实例化阶段将要用的必要信息。只有当请求方通过BeanFactory的getBean()方法来请求某个对象实例的时候，才有可能触发Bean实例化阶段的活动</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="bean" scheme="http://example.com/tags/bean/"/>
    
  </entry>
  
</feed>
