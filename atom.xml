<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-25T01:58:06.991Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在 Linux 系统中查看 TCP 状态？</title>
    <link href="http://example.com/2022/02/25/%E5%A6%82%E4%BD%95%E5%9C%A8-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B-TCP-%E7%8A%B6%E6%80%81%EF%BC%9F/"/>
    <id>http://example.com/2022/02/25/%E5%A6%82%E4%BD%95%E5%9C%A8-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B-TCP-%E7%8A%B6%E6%80%81%EF%BC%9F/</id>
    <published>2022-02-25T01:56:00.000Z</published>
    <updated>2022-02-25T01:58:06.991Z</updated>
    
    <content type="html"><![CDATA[<p>netstat-napt</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;netstat-napt&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>最左匹配原则</title>
    <link href="http://example.com/2022/02/24/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/02/24/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/</id>
    <published>2022-02-24T08:02:00.000Z</published>
    <updated>2022-02-24T08:04:16.906Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p><p>   select * from user where name=xx and city=xx ; ／／可以命中索引 </p><p>   select * from user where name=xx ; // 可以命中索引 </p><p>   select * from user where city=xx; // 无法命中索引 </p><pre><code>需要注意：查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDERBY子句也遵循此规则。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：&lt;/p&gt;
&lt;p&gt;   select </summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="最左匹配原则" scheme="http://example.com/tags/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>一条SQL语句执行得很慢的原因有哪些？</title>
    <link href="http://example.com/2022/02/24/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2022/02/24/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2022-02-24T07:50:00.000Z</published>
    <updated>2022-02-24T07:59:49.798Z</updated>
    
    <content type="html"><![CDATA[<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log 页写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><pre><code>转载：https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN%23rd</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个 SQL 执行的很慢，我们要分两种情况讨论：&lt;/p&gt;
&lt;p&gt;1、大多数情况下很正常，偶尔很慢，则有如下原因&lt;/p&gt;
&lt;p&gt;(1)、数据库在刷新脏页，例如 redo log 页写满了需要同步到磁盘。&lt;/p&gt;
&lt;p&gt;(2)、执行的时候，遇到锁，如表锁、行锁。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="性能" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>分库分表之后的主键处理方式</title>
    <link href="http://example.com/2022/02/24/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%BB%E9%94%AE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/02/24/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%BB%E9%94%AE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2022-02-24T04:56:00.000Z</published>
    <updated>2022-02-24T05:00:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>1、UUID：不适合作为主键，其太长了而且无序，插入效率低</p><p>2、数据库自增id：两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。</p><p>3、利⽤ redis ⽣成 id : 性能⽐᫾好，灵活⽅便，不依赖于数据库。但是，引⼊了新的组件造成<br>系统更加复杂，可⽤性降低，编码更加复杂，增加了系统成本。</p><p>4、Twitter的snowflake算法：</p><p> <img src="/images/pasted-102.png" alt="upload successful"></p><p> 1.第一位</p><p>占用1bit，其值始终是0，没有实际作用。</p><p>2.时间戳</p><p>占用41bit，精确到毫秒，总共可以容纳约140年的时间。</p><p>3.工作机器id</p><p>占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。</p><p>4.序列号</p><p>占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。</p><p>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法：</p><p>1024x4096</p><p>SnowFlake算法的优点：</p><p>1.生成ID时不依赖于DB，完全在内存生成，高性能高可用。</p><p>2.ID呈趋势递增，后续插入索引树的时候性能较好。</p><p>SnowFlake算法的缺点：</p><p>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、UUID：不适合作为主键，其太长了而且无序，插入效率低&lt;/p&gt;
&lt;p&gt;2、数据库自增id：两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。&lt;/p&gt;
&lt;p&gt;3、利⽤ redis </summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="主键" scheme="http://example.com/tags/%E4%B8%BB%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>http常见状态码</title>
    <link href="http://example.com/2022/02/23/http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://example.com/2022/02/23/http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2022-02-23T07:48:00.000Z</published>
    <updated>2022-02-23T07:56:43.034Z</updated>
    
    <content type="html"><![CDATA[<p>1xx：表示一种提示信息，一般是服务器的中间状态，不常用</p><p>2xx：表示服务器已经成功处理了请求</p><p>200：成功<br>204：成功（响应头没有body数据）<br>206：用于http分块下载或者断点续传，表示响应的body里面的数据并不完整，只是一部分</p><p>3xx：客户端请求的资源发生了变动需要重定向</p><p>301：表示永久重定向，即访问的资源永久不存在</p><p>302：临时重定向，即访问的资源还在，需要换一个url访问</p><p>301和302会在响应头使用location字段表明重定向的url进行重定向</p><p>304：不具有跳转含义，表明请求的资源未修改，重定向缓存文件。</p><p>4xx：请求的报文有误，服务器无法处理</p><p>400：请求错误，具体不清楚</p><p>403：服务器禁止访问资源</p><p>404：访问的资源在服务器找不到</p><p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p><p>「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p><p>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p><p>「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器<br>发⽣了错误。</p><p>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意<br>思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1xx：表示一种提示信息，一般是服务器的中间状态，不常用&lt;/p&gt;
&lt;p&gt;2xx：表示服务器已经成功处理了请求&lt;/p&gt;
&lt;p&gt;200：成功&lt;br&gt;204：成功（响应头没有body数据）&lt;br&gt;206：用于http分块下载或者断点续传，表示响应的body里面的数据并不完整，只是</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://example.com/2022/02/23/http/"/>
    <id>http://example.com/2022/02/23/http/</id>
    <published>2022-02-23T07:37:47.000Z</published>
    <updated>2022-02-23T07:38:21.504Z</updated>
    
    <content type="html"><![CDATA[<p>http是计算机世界里面两点之间进行文字、图片、视频等超文本数据传输的协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;http是计算机世界里面两点之间进行文字、图片、视频等超文本数据传输的协议&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>get和post的区别</title>
    <link href="http://example.com/2022/02/18/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/02/18/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-02-18T14:38:00.000Z</published>
    <updated>2022-02-18T14:39:22.715Z</updated>
    
    <content type="html"><![CDATA[<p>POST和GET都是向服务器提交数据，并且都会从服务器获取数据。</p><p>区别：</p><p>1、传送方式：get通过地址栏传输，post通过报文传输。</p><p>2、传送长度：get参数有长度限制（受限于url长度），而post无限制</p><p>3、GET和POST还有一个重大区别，简单的说：</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol><p>建议：</p><p>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；</p><p>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p><p>案例：一般情况下，登录的时候都是用的POST传输，涉及到密码传输，而页面查询的时候，如文章id查询文章，用get 地址栏的链接为：article.php?id=11，用post查询地址栏链接为：article.php， 不会将传输的数据展现出来。</p><p>拓展资料：</p><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p><p>GET请求只能进行url编码，而POST支持多种编码方式。</p><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p><p>GET参数通过URL传递，POST放在Request body中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;POST和GET都是向服务器提交数据，并且都会从服务器获取数据。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;1、传送方式：get通过地址栏传输，post通过报文传输。&lt;/p&gt;
&lt;p&gt;2、传送长度：get参数有长度限制（受限于url长度），而post无限制&lt;/p&gt;
&lt;p&gt;3、GET</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="get" scheme="http://example.com/tags/get/"/>
    
    <category term="post" scheme="http://example.com/tags/post/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://example.com/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-11T13:22:00.000Z</published>
    <updated>2022-02-11T13:38:00.109Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。说直白一点就是在不修改目标对象的基础上，使用代理对象来增强目标对象的业务逻辑方法。</p><p>代理模式分为：静态代理和动态代理（jdk动态代理和cglib动态代理）</p><p>静态代理就是：代理类在程序运行前就确定好了和目标类的关系，在编译期就实现了。其中静态代理的缺点在于：</p><p>1、代码复杂，不便于管理：试想对于代理类，需要和目标类实现相同接口即每个代理类都要实现目标类的的方法，会出现代码重复，且考虑到如果接口增加一个方法，其所有实现类都要重写，维护也麻烦。</p><p>2、代理类依赖于目标类：当代理类考虑代理多个服务的时候，不便于实现</p><p>动态代理是在程序运行期间根据jvm反射机制动态生成的。</p><p>jdk动态代理：基于java反射机制实现的。具体通过使用java.lang.reflect 包提供三个类支持代理模式 Proxy, Method和 InovcationHandler。（要求：求目标对象必须实现接口）</p><pre><code>public interface UsbSell &#123;    Object sell(float amount);&#125;public class UsbFactory implements UsbSell &#123;public Object sell(float amount) &#123;    float price = 0;    if (amount &gt; 100)&#123;        price = (float) (amount * (1 + 0.2));    &#125;else &#123;        price = (float) (amount * (1 + 0.5));    &#125;    return price;    &#125;&#125;public class ProxySeller &#123;private Object target;public ProxySeller() &#123;&#125;public ProxySeller(Object target) &#123;    this.target = target;&#125;public Object getProxy()&#123;    return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123;        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;            float res = (Float) method.invoke(target,args);            System.out.println(&quot;==&quot;+res);            return proxy;        &#125;    &#125;);&#125;&#125;public class Main &#123;public static void main(String[] args) &#123;    UsbFactory factory = new UsbFactory();    ProxySeller seller = new ProxySeller(factory);    UsbSell proxy = (UsbSell)seller.getProxy();    UsbSell s = (UsbSell)proxy.sell(50);    s.sell(50);&#125;&#125;</code></pre><p> cglib动态代理：一个开源项目。对于无接口的类，要为其创建动态代理，就要使用 CGLIB 来实现。CGLIB 代理的生成原理是生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象。所以，使用CGLIB 生成动态代理，要求目标类必须能够被继承，即不能是 final 的类。</p><pre><code>     public class Saller &#123;public float sell(int amount)&#123;    float price = 100;    if (amount &gt; 100)&#123;        price = (float) (price * (1 + 0.2));    &#125;else &#123;        price = (float) (price * (1 + 0.5));    &#125;    return price;&#125;&#125;public class ProxySaller implements MethodInterceptor &#123;private Object target;public ProxySaller() &#123;&#125;public ProxySaller(Object target) &#123;    this.target = target;&#125;public Object getProxySaller()&#123;    Enhancer enhancer = new Enhancer();    enhancer.setSuperclass(target.getClass());    enhancer.setCallback(this);    Saller saller = (Saller) enhancer.create();    return saller;&#125;public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;    Float price = (Float) methodProxy.invoke(target,objects);    System.out.println(&quot;===&quot;+price);    return price;&#125;&#125;public class Main &#123;public static void main(String[] args) &#123;    Saller saller = new Saller();    ProxySaller proxySaller = new ProxySaller(saller);    Saller proxy = (Saller) proxySaller.getProxySaller();    proxy.sell(100);&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。说直白一点就是在不修改目标对象的基础上，使用代理对象来增强目标对象的业务逻辑方法。&lt;/p&gt;
&lt;p&gt;代理模式</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="代理模式" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>innoDB中的锁</title>
    <link href="http://example.com/2022/02/10/innoDB%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://example.com/2022/02/10/innoDB%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2022-02-10T05:38:00.000Z</published>
    <updated>2022-02-10T11:19:02.156Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB实现了共享锁（读锁）和排他锁（写锁）两种行级锁。意向共享锁和意向排他锁两种表级别的锁。</p><p> <img src="/images/pasted-97.png" alt="upload successful"></p><p> <img src="/images/pasted-98.png" alt="upload successful"></p><p> <img src="/images/pasted-99.png" alt="upload successful"></p><p> <img src="/images/pasted-100.png" alt="upload successful"></p><p> <img src="/images/pasted-101.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB实现了共享锁（读锁）和排他锁（写锁）两种行级锁。意向共享锁和意向排他锁两种表级别的锁。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-97.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/im</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>lock与latch</title>
    <link href="http://example.com/2022/02/10/lock%E4%B8%8Elatch/"/>
    <id>http://example.com/2022/02/10/lock%E4%B8%8Elatch/</id>
    <published>2022-02-10T05:36:00.000Z</published>
    <updated>2022-02-10T05:38:14.315Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-96.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-96.png&quot; alt=&quot;upload successful&quot;&gt;
 &lt;/p&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL分区</title>
    <link href="http://example.com/2022/02/09/MySQL%E5%88%86%E5%8C%BA/"/>
    <id>http://example.com/2022/02/09/MySQL%E5%88%86%E5%8C%BA/</id>
    <published>2022-02-09T12:14:49.000Z</published>
    <updated>2022-02-09T12:14:49.287Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL表</title>
    <link href="http://example.com/2022/02/09/MySQL%E8%A1%A8/"/>
    <id>http://example.com/2022/02/09/MySQL%E8%A1%A8/</id>
    <published>2022-02-09T10:47:00.000Z</published>
    <updated>2022-02-09T12:07:08.587Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB中，表根据主键顺序存放。每张表都有一个主键，在建表时没有显示定义主键，则innoDB会先判断表中是否有非空的唯一索引，如果有，则该索引即为主键（对于多个非空唯一索引，根据定义的顺序选择，而不是建表列的顺序选择），如果没有，则会自动创建一个6字节的指针。</p><p>innoDB中，数据被逻辑的放在一个表空间。表空间由段组成，段又由区组成，区又有页组成，页时最基本的单位。如下：<br> <img src="/images/pasted-83.png" alt="upload successful"></p><p>innoDB默认情况下有一个共享表空间，如果用户开启参数innodb_file_per_table则每张表的数据单独放到一个表空间。（需要注意的是：单独的表空间只是存放数据、索引和插入缓冲bitmap页，对于其他数据，如回滚信息、插入缓冲索引页等仍是存放在共享表空间）</p><p>对于段由innoDB管理，数据段即为B+tree的叶子节点，索引段即为B+tree的非叶子节点，回滚段较为特殊。</p><p>区则是连续页（默认16kb/页）组成的空间（大小1mb）。一个区默认有64个连续的页。为了保证区中页的连续性，innoDB会一次从磁盘申请4-5个区。值得注意的是：</p><p> <img src="/images/pasted-84.png" alt="upload successful"></p><p> innoDB常见页：</p><p> <img src="/images/pasted-85.png" alt="upload successful"></p><p> 页又由行组成最多允许7992（16kb/2-200）行记录。innoDB提供了Compact和Redundant格式的行数据格式。需要注意：除了下图的信息外，还存在事务ID列（6字节）和回滚指针列（7字节），如果innoDB没有定义主键还会有一个6字节的rowid列</p><p> Compact行记录：</p><p> <img src="/images/pasted-86.png" alt="upload successful"></p><p> <img src="/images/pasted-87.png" alt="upload successful"></p><p> Redundant行记录格式：</p><p> <img src="/images/pasted-88.png" alt="upload successful"></p><p> <img src="/images/pasted-89.png" alt="upload successful"></p><p>当然一般情况下innoDB的数据都是放在页类型为B+tree-node中，但是当发生行溢出，数据存放在Uncompress BLOB页中。<br> <img src="/images/pasted-90.png" alt="upload successful"></p><p> innoDB数据页结构：</p><p> <img src="/images/pasted-92.png" alt="upload successful"><br> <img src="/images/pasted-91.png" alt="upload successful"></p><p> <img src="/images/pasted-93.png" alt="upload successful"></p><p> <img src="/images/pasted-94.png" alt="upload successful"></p><p> <img src="/images/pasted-95.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB中，表根据主键顺序存放。每张表都有一个主键，在建表时没有显示定义主键，则innoDB会先判断表中是否有非空的唯一索引，如果有，则该索引即为主键（对于多个非空唯一索引，根据定义的顺序选择，而不是建表列的顺序选择），如果没有，则会自动创建一个6字节的指针。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="表" scheme="http://example.com/tags/%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL文件</title>
    <link href="http://example.com/2022/02/09/MySQL%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2022/02/09/MySQL%E6%96%87%E4%BB%B6/</id>
    <published>2022-02-09T08:05:00.000Z</published>
    <updated>2022-02-09T08:39:14.232Z</updated>
    
    <content type="html"><![CDATA[<p>1、参数文件：MySQL实例启动时会读取参数文件来初始化。</p><p>2、日志文件：</p><p>错误日志（记录了MySQL执行期间的错误信息）</p><p>二进制日志（记录了对MySQL执行的写操作，默认未开启。</p><p>作用：<br>1、恢复，可以通过binlog进行数据的恢复<br>2、复制：通过复制和执行binlog对远程的MySQL进行实时数据同步（主从复制）<br>3、审计：对binlog数据进行审计，看是否有对数据库进行注入的攻击</p><p> <img src="/images/pasted-81.png" alt="upload successful"></p><p> <img src="/images/pasted-82.png" alt="upload successful"><br>）</p><p>慢查询日志（可以从中得到一些SQL优化信息，默认未开启）</p><p>查询日志（记录了所有对MySQL的请求信息）</p><p>3、套接字文件</p><p>4、pid文件</p><p>5、表结构定义文件（以frm为后缀名）：记录了该表的表结构定义。除此之外还用于存放视图的定义。</p><p>6、innoDB存储引擎文件：</p><p>a）表空间文件（默认10mb，名为ibdata1）：可以设置基于innoDB存储的单独的。idb独立表空间文件（仅存储数据、索引等信息，其他信息还是存放于表空间文件）。</p><p> <img src="/images/pasted-78.png" alt="upload successful"></p><p> b）、redolog文件（默认会有两个名为ib_logfile0和ib_logfile1的文件）：每个innoDB至少有一个redolog组（每组至少有两个redolog文件），redolog冲缓冲区写入磁盘是按512字节，即一个扇区大小，可以保障写入必定成功（所有不需要doublewrite）</p><p> <img src="/images/pasted-79.png" alt="upload successful"></p><p> <img src="/images/pasted-80.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、参数文件：MySQL实例启动时会读取参数文件来初始化。&lt;/p&gt;
&lt;p&gt;2、日志文件：&lt;/p&gt;
&lt;p&gt;错误日志（记录了MySQL执行期间的错误信息）&lt;/p&gt;
&lt;p&gt;二进制日志（记录了对MySQL执行的写操作，默认未开启。&lt;/p&gt;
&lt;p&gt;作用：&lt;br&gt;1、恢复，可以通过bi</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="文件" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>innoDB存储引擎</title>
    <link href="http://example.com/2022/02/09/innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://example.com/2022/02/09/innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2022-02-09T03:04:00.000Z</published>
    <updated>2022-02-09T07:37:44.969Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB存储引擎是开源的第一个完整支持ACID事务的MySQL存储引擎（第一个支持事务的是BDB存储引擎），其特点是行锁设计、支持MVCC、支持外键、一致性非锁定读等。被广泛的应用。</p><p> <img src="/images/pasted-58.png" alt="upload successful"></p><p> innoDB存储引擎有多个内存块，组成了一个大的内存池，每个内存块有指定的后台线程来维护其运行。</p><p> 1、main线程主要负责将缓冲区的数据异步刷新到磁盘，保证数据的一致性（包括脏页的刷新、合并插入缓冲、undo页的回收等）</p><p> 2、IO线程主要是负责IO请求的回调，包括read、write、insert buffer、log等，其使用了AIO机制，保证了IO性能。</p><p> 3、Purge线程主要用于回收提交事务之后，undo页可能不再需要，需要对其进行回收。（1.2版本支持多个Purge线程，目的是进一步加快undo页的回收，提升性能）</p><p> 4、Page cleaner线程主要用于脏页的刷新操作，减轻main线程的压力。</p><p> innoDB是基于磁盘存储的，为了权衡磁盘速度和CPU速度的差异，提供了一块缓冲池技术来提升性能。（因此可以将缓冲池区域设置大一点来进行优化操作）innoDB1.0允许多个缓冲池实例，磁盘读取的页根据哈希值均匀分配到不同缓冲池中（目的：减少数据库资源竞争，增加数据库并发处理能力）</p><p> 在数据的读取中，会先去缓冲池中查看是否存在于缓冲池，如果存在直接读取，不存在则去磁盘读取，在同步到缓冲池中。而对于写操作则是先写到缓冲池，然后根据Checkpoint机制将脏数据刷新到磁盘，保证磁盘和内存数据的一致性。</p><p> 缓冲池具体的数据页有：</p><p> <img src="/images/pasted-59.png" alt="upload successful"></p><p> 为了管理这些数据页，innoDB使用了一个freeLIst链表来管理空闲的页内存，LRUList来管理已经分配的页内存，flushList来管理脏页。（脏页及存在于LRUList，又存在于flushList，是两者共享的）</p><p> 对于LRUList管理的页，采用了LRU（最近最少使用）算法来管理（缓冲池页大小默认16kb），在LRU列表中加入了一个midpoint位置（默认是5/8位置处），midpoint位置前面的是热点数据区域，后面的是冷数据区域（设置冷、热数据区域主要是为了保证一些经常被访问的数据存在于内存中，提示效率的一种考虑）。当一个新的页被分配到LRULIst上，会先加入到midpoint位置后面（这样做是为了防止当进行全表查询的时候，多个页会覆盖调热数据区域的页，而这些查的数据页又只使用一次，后续不再使用，当后面访问热区域的页时有会从磁盘中查找，浪费性能），同时也指定了一个从冷数据区域晋升到热数据区域的参数，当到了晋升时间后，冷数据区域的页就会晋升到热数据区域。</p><p>值得注意的是：空闲页的内存freeList+以分配的页内存LRUList并不等于缓冲池的内存，因为缓冲池中包含得其他部分页（自适应哈希索引、lock信息等）不需要LRU维护，不存在于LRUList中。</p><p> <img src="/images/pasted-60.png" alt="upload successful"></p><p> 另外，页是支持压缩的，16kb的页可以压缩成1kb、2kb、4kb、8kb。页的大小发生变化，所有对于压缩的页，会使用zipLRUList进行管理。（注意：LRUList包含zipLRUList中的页）</p><p> 对于zipLIRList的页的分配采用伙伴算法</p><p>例如压缩后的页为4kb</p><p>1、先检查4kb的zipLRUList是否有空闲页，存在即分配</p><p>2、否则，检查8kb的zipLRUList看是否存在空闲页，存在则将8kb分为两个4kb，将4kb的页放入4kbzipLRUList<br>，然后为其分配</p><p>3、在否则，检查16kb的freeList看是否存在空闲页，存在则将16kb分为两个4kb，一个8kb，分别放入对应zipLRUList，然后为其分配</p><p> <img src="/images/pasted-61.png" alt="upload successful"></p><p> 由上图可知，innoDB除了缓冲池，还存在redolog日志缓冲和额外内存池。</p><p> 其中redolog日志缓冲（默认8mb大小）是redolog文件的缓冲区（redolog文件记录了写请求的指令，对页的写指令都会记录到这个文件中，后续数据库恢复会使用到这个文件）当满足以下条件就会将缓冲区的数据刷新到文件中。</p><p> 1、每个事物提交会进行刷新</p><p> 2、当缓冲区小于一半，会进行刷新</p><p> 3、main线程每秒会进行一次刷新</p><p> 而额外的内存池则是在对于一些数据结构本身进行进行内存分配时会从额外内存储进行申请。</p><p>前面提到进行写操作入时，一般会先写到缓冲区，然后在根据checkpoint机制将脏页刷新到内存，保持内存和磁盘数据的一致性。但考虑到如果频繁发生写操作，而对脏数据刷新到磁盘不加以控制，每来一个写操作，都会进行一次刷新，那就会产生大量的io，导致整体性能下降；除此之外，在刷新的时候如果出现了宕机，数据也会丢失。因此采用提交事物前，先写redolog日志，然后在修改内存中的页，即使将脏页刷新到磁盘时出现宕机，也能够根据redolog日志进行恢复。而chenckpoint技术就是为了解决</p><p>1、缩短数据库的恢复时间（因为chenckpoint前的脏页都已经刷新到磁盘了，只需对chenckpoint之后的进行恢复）<br>2、缓冲池不够时将脏页刷新到磁盘。（当缓冲池不够用时，会根据LRU算法将最近最少用的页淘汰，而淘汰时会检测是否为脏页，如果是则执行checkpoint，将脏页刷新到磁盘）<br>3、redolog日志不够用时，刷新脏页（即redolog的大小是有限制的，chenckpont前的是可重用的，而chenckpoint之后的是需要的，如果redolog文件里面全部都是需要使用的，则必须进行checkpoint）</p><p>在innoDB中，使用LSN（八字节）标记版本，每个页都有自己的LSN，redolog日志中和checkpoint中也有。</p><p>在innoDB中存在两种checkpoint，即sharp checkpoint（默认）和fuzzy checkpoint。</p><p>sharp checkpoint发生在数据库关闭时，此时会将所有脏页刷新到磁盘（会发生迟钝）</p><p>fuzzy checkpoint则是每次只刷新部分脏页到磁盘。以下是几种发生fuzzy checkpoint的情况：</p><p> <img src="/images/pasted-62.png" alt="upload successful"></p><p> 1、main线程会每秒或10秒的速度从fulshList中刷新页到磁盘。</p><p> 2、当缓冲池没有多余空闲空间，会根据LRU算法冲LRUList淘汰页，对于淘汰的页会检测是否是脏页，是则会刷新到磁盘。</p><p> 3、当redolog不可用时会强制flushList中的脏页进行刷新</p><p> 4、当脏页太多，也会强制进行checkpoint刷新脏页到磁盘。</p><p> innoDB主要工作都是在main线程中完成的，其内部由多个循环组成（主循环、后台循环、刷新循环、暂停循环），在多个循环中切换进行工作。</p><p> innoDB1.0</p><p> 主循环：</p><p> <img src="/images/pasted-64.png" alt="upload successful"></p><p> <img src="/images/pasted-65.png" alt="upload successful"></p><p> 后台循环：</p><p> <img src="/images/pasted-66.png" alt="upload successful"></p><p> innoDB1.2基于上述IO限制，加入了innoDB_io_capacitiy用于表示IO（默认200），对于刷新的页用百分比来控制<br> <img src="/images/pasted-67.png" alt="upload successful"><br> 另外一个参数是innoDB_max_dirty_pct（默认75），当脏页小于innoDB_max_dirty_pct也会刷新一定量的脏页（之前是不会刷新的）。</p><p>  <img src="/images/pasted-61.png" alt="upload successful"><br>  接下来说一说innoDB的插入缓冲。insert buffer和数据页一样，是物理页的一部分。</p><p>  在innoDB中，主键是唯一标识，插入记录一般按主键递增顺序插入。因此，聚集索引一般是顺序的（比如自增id这种），对于顺序的一般插入操作速度很快，但对于主键是uuid之类则和辅助索引一样，是随机的。因此对于这种情况，按顺序插入则相对要慢得多。因此insert buffer的作用就是对于非聚集索引的插入或者更新操作先判断是否存在缓冲池，若存在则直接插入，不存在则放到insert buffer中，在以一定频率进行inser buffer和辅助索引子节点的合并，提高对于非聚集索引的插入性能。当然使用insert buffer需要满足<br> <img src="/images/pasted-69.png" alt="upload successful"></p><p> <img src="/images/pasted-70.png" alt="upload successful"></p><p> insert buffer数据实现是一颗b+树，<br> <img src="/images/pasted-72.png" alt="upload successful"></p><p><img src="/images/pasted-73.png" alt="upload successful"></p><p> <img src="/images/pasted-74.png" alt="upload successful"></p><p> change buffer：在1.0.x版本引入了channge buffer，可以对增删改都进行缓冲<br> <img src="/images/pasted-71.png" alt="upload successful"></p><p> 两次写：当innoDB刷新某个页到磁盘中，但只刷新了部分，数据库就宕机了（部分写失效）。double write就是为了解决这种情况产生的。</p><p> <img src="/images/pasted-75.png" alt="upload successful"></p><p> double write由两部分组成。一部分时内存double write buffer（大小2mb），一部分是磁盘上的共享表空间中连续的128页（即两个区，大小为2mb）。在对脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复杂到 doublewrite buffer，然后doubllewrite buffer再分两次顺序的写到共享表空间的物理磁盘上（每次写1mb）。完成之后，在将doublewrite buffer中的页写入各个表文件空间中。如果在写入表中磁盘时发生了宕机什么的。在恢复时，可以从共享表空间中找到一个备份页，将其复制到表空间。</p><p> <img src="/images/pasted-76.png" alt="upload successful"></p><p> 自适应哈希：innoDB会对表上各索引页的查询监控。如果建立哈希索引会提升性能，则建立哈希索引。而条件就是：对这个页的连续访问模式要一样。</p><p> 异步IO：innoDB采用AIO的方式处理磁盘操作，可以在发起一个IO请求后，立马发起另一个IO请求，当全部发送完后，等所有请求操作完。除此之外，还可以进行IO的合并操作。</p><p> 刷新邻接页：即刷新一个脏页时，会检测该页周围的页是否是脏页，是则一并刷新。</p><p> <img src="/images/pasted-77.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB存储引擎是开源的第一个完整支持ACID事务的MySQL存储引擎（第一个支持事务的是BDB存储引擎），其特点是行锁设计、支持MVCC、支持外键、一致性非锁定读等。被广泛的应用。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-58.png&quot; al</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="innoDB" scheme="http://example.com/tags/innoDB/"/>
    
  </entry>
  
  <entry>
    <title>jedis和redission</title>
    <link href="http://example.com/2022/02/08/jedis%E5%92%8Credission/"/>
    <id>http://example.com/2022/02/08/jedis%E5%92%8Credission/</id>
    <published>2022-02-08T12:45:00.000Z</published>
    <updated>2022-02-08T12:46:11.557Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-57.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-57.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="框架实现" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>一致性hash算法</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</id>
    <published>2022-02-08T12:33:00.000Z</published>
    <updated>2022-02-08T12:34:21.071Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-55.png" alt="upload successful"></p><p> <img src="/images/pasted-56.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-55.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-56.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/Redis/"/>
    
    
    <category term="一致性哈希算法" scheme="http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群的主从复制模型</title>
    <link href="http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-02-08T12:27:00.000Z</published>
    <updated>2022-02-08T12:27:38.911Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-54.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-54.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="主从复制模型" scheme="http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存优化</title>
    <link href="http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-08T12:09:00.000Z</published>
    <updated>2022-02-08T12:10:03.147Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-52.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-52.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存优化" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Redis的回收进程如何工作</title>
    <link href="http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/"/>
    <id>http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</id>
    <published>2022-02-08T09:37:00.000Z</published>
    <updated>2022-02-08T11:59:38.055Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-51.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-51.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="回收进程" scheme="http://example.com/tags/%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一个Redis实例能存放多少key？</title>
    <link href="http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/"/>
    <id>http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/</id>
    <published>2022-02-08T09:27:00.000Z</published>
    <updated>2022-02-08T09:28:21.147Z</updated>
    
    <content type="html"><![CDATA[<p>理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的<br>值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的&lt;br&gt;值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
  </entry>
  
</feed>
