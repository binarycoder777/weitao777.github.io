<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-08T12:48:29.130Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring AOP实现机制的一个小小陷阱</title>
    <link href="http://example.com/2022/03/08/Spring%20AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%99%B7%E9%98%B1/"/>
    <id>http://example.com/2022/03/08/Spring%20AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%99%B7%E9%98%B1/</id>
    <published>2022-03-08T12:36:00.000Z</published>
    <updated>2022-03-08T12:48:29.130Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Spring AOP采用代理模式实现，具体的横切逻辑会被添加到动态生成的代理对象中，只要调用的是目标对象的代理对象上的方法就可以保证目标对象的方法执行可以被拦截。</p><p>不过遗憾的是，代理模式的实现机制在处理方法调用的时序方面会给使用这种机制实现的AOP产品造成一个缺憾。在处理对象方法中，不管你如何添加横切逻辑，也不管添加多少横切逻辑，有一点是确定的，你最终需要调用目标对象的同一方法来执行最初所应以的方法逻辑。如果目标对象中原始方法调用依赖于其他对象，那没问题。我们可以为目标对象注入所依赖对象的代理，并且可以保证相应的Joinpoint被拦截并且织入相应横切逻辑。但是如果目标对象中的原始方法调用直接调用自身方法时，会导致出现问题</p><p> <img src="/images/pasted-133.png" alt="upload successful"></p><p> 在代理对象的method1执行经历了层层拦截后，最终会将调用转向目标对象上的method1，之后调用流程全部在走targetobject之上，当method1调用method2时，它调用targetobject的method2，而不是代理对象的method2，而针对method2的横切逻辑是织入到代理对象上的，因此method1中调用的method2没有被成功拦截。</p><p> 好在Spring AOP提供了AopContent来公开当前目标对象的代理对象，我们只要在目标对象中使用AopContent.currentProxy()就可以获取当前目标对象所对应的代理对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道Spring AOP采用代理模式实现，具体的横切逻辑会被添加到动态生成的代理对象中，只要调用的是目标对象的代理对象上的方法就可以保证目标对象的方法执行可以被拦截。&lt;/p&gt;
&lt;p&gt;不过遗憾的是，代理模式的实现机制在处理方法调用的时序方面会给使用这种机制实现的AOP产品</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP的常见应用案例</title>
    <link href="http://example.com/2022/03/08/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2022/03/08/AOP%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/</id>
    <published>2022-03-08T11:26:00.000Z</published>
    <updated>2022-03-08T12:33:39.435Z</updated>
    
    <content type="html"><![CDATA[<p>1、异常处理：</p><p>通常将Error和RuntimeException及其子类称作非受检异常。（编译器不会对这些类型的异常进行编译期检查），而其他的则为受检异常（编写程序期间就应进行处理）。Fault Barrier即为对非受检异常的处理。</p><p>对于这些非受检异常的处理可以归并于溢出进行处理，而不是让他们散落到系统的各处。介于此，我们可以通过实现一个Aspect来处理，让其对系统中所有可能的falut情况进行统一的处理。而这个专职于处理Falut的Aspect即为Falut Barrier。</p><p>2、安全检查：</p><p>Filter是Servlet规范为我们提供的一种AOP支持。通过它我们可以为基于servlet的web应用添加相应的资源访问控制等等。但是，基于filter的web应用的资源访问控制仅仅是特定领域安全检查需求。而通过AOP，我们可以为任何类型的应用添加安全支持。（Spring Security则是基于Spring的一款强大的安全框架）</p><p>3、缓存：</p><p>AOP应用的另一个主要场景则是为系统透明地添加缓存支持。缓存可以在很大程度上提升系统性能。为了避免需要添加的缓存实现逻辑影响业务逻辑的实现，我们可以让缓存的实现独立于业务对象的实现外，将系统中的缓存需求通过AOP的Aspect进行封装，只在系统中某个点确切需要缓存的情况下才进行织入。（现在已经有许多现成的Caching产品实现，入EhCache、Redis等）</p><p>Spring Modules项目提供了对现有Caching产品的集成，这样可以通过外部声明的方式为系统中的Joinpoint加Caching支持。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、异常处理：&lt;/p&gt;
&lt;p&gt;通常将Error和RuntimeException及其子类称作非受检异常。（编译器不会对这些类型的异常进行编译期检查），而其他的则为受检异常（编写程序期间就应进行处理）。Fault Barrier即为对非受检异常的处理。&lt;/p&gt;
&lt;p&gt;对于这些</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="应用" scheme="http://example.com/tags/%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言程序经过预处理、编译、汇编和链接等各个阶段的变化情况</title>
    <link href="http://example.com/2022/03/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BB%8F%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AD%89%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5/"/>
    <id>http://example.com/2022/03/08/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%BB%8F%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E5%92%8C%E9%93%BE%E6%8E%A5%E7%AD%89%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5/</id>
    <published>2022-03-08T07:59:00.000Z</published>
    <updated>2022-03-08T11:26:01.536Z</updated>
    
    <content type="html"><![CDATA[<p>编译过程概述：通常编译程序的过程分为词法分析、语法分析、语义分析、目目标代码生成4个阶段（如果编译器支持优化，还可以有中间代码生成和代码优化两个阶段）。</p><p> <img src="/images/pasted-132.png" alt="upload successful"></p><p>1、词法分析</p><p>此阶段的任务是从左到右一个字符一个字符地读入源程序，对构成源程序的字符进行扫描和分解，从而识别出一个个单词（逻辑上紧密相连的一组有集体含义的字符）。</p><p>2、语法分析</p><p>此阶段的任务是在词法分析的基础上将单词序列分解成各类语法短语（也称语法单位）可表示成语法树。</p><p>注：词法分析和语法分析本质上都是对源程序的结构进行分析。</p><p>3、语义分析</p><p>语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。</p><p>4、中间代码生成</p><p>“中间代码”是一种结构简单，含义明确的记号系统，这种记号系统可以设计为多种多样的形式，重要的设计原则为两点：一是容易生成；二是容易将它翻译成目标代码。很多编译程序采用了一种近似“三地址指令”的“四元式”中间代码。这种四元式的形式为：（运算符，运算对象1，运算对象2，结果）</p><p>5、代码优化</p><p>将中间代码进行变换或进行改造，目的：使生成的目标代码更为高效，即省时间和空间</p><p>6、目标代码生成</p><p>任务是把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译过程概述：通常编译程序的过程分为词法分析、语法分析、语义分析、目目标代码生成4个阶段（如果编译器支持优化，还可以有中间代码生成和代码优化两个阶段）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-132.png&quot; alt=&quot;upload succes</summary>
      
    
    
    
    <category term="编译原理" scheme="http://example.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="基础概念" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 一世</title>
    <link href="http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/"/>
    <id>http://example.com/2022/03/07/Spring-AOP-%E4%B8%80%E4%B8%96/</id>
    <published>2022-03-07T12:03:00.000Z</published>
    <updated>2022-03-07T13:01:58.232Z</updated>
    
    <content type="html"><![CDATA[<p>AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint</p><p>Spring中以接口定义Pointcut作为其AOP框架中所有Pointcut的最顶级抽象，该接口定义了两个方法来捕获系统中相应的Joinpoint，并提供了一个TruePointcut类型实例。如果Pointcut类型为TruePointcut，默认会对系统中的所有对象，以及对象上所有被支持的Joinpoint进行匹配。</p><p> <img src="/images/pasted-129.png" alt="upload successful"></p><p> ClassFileter和MethodMatcher分别用于匹配将被执行织入操作的对象以及相应的方法。（重用不同级别的匹配定义，并且可以在不同或相同的级别上进行组合操作，或者强制让某个子类只覆写相应的方法）</p><p> <img src="/images/pasted-130.png" alt="upload successful"></p><p> Spring中各种advice实现全部遵循AOP ALLiance规定的接口。</p><p> <img src="/images/pasted-131.png" alt="upload successful"><br> advice实现了将被织入到Pointcut规定的Joinpoint处的横切逻辑。在Spring中，advice按照其自身实例能否在目标对象类的所有实例中共享这一标准，可以划分为两大类（per-class和per-instance）</p><p> per-class类型的advice：该类型可以在目标对象类的所有实例之间共享。这种类型的advice通常只提供方法拦截的功能。不会为目标对象类保存任何状态或添加新特性。除了上图没有列出的intriuduction类型的advice外，其余都属于pre-class。（如：BeforeAdvice、ThrowsAdvic、AfterReturningAdvice、AroundAdvice等）</p><p> per-instance类型的advice：introduction是唯一的一种per-instance型advice。其可以在不改目标类定义的情况下，为目标类添加新的属性和行为。</p><p> 当所有的Pointcut和advice准备好之后，就可以将其装入Aspect。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP的Joinpoint可以有许多类型，入构造方法调用、字段的设置及获取、方法调用等。但是在Spring AOP中，仅支持方法级别的Joinpoint。更确切的说，只支持方法执行类型的Joinpoint&lt;/p&gt;
&lt;p&gt;Spring中以接口定义Pointcut作为其AOP框</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP的实现机制</title>
    <link href="http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/03/07/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</id>
    <published>2022-03-07T11:43:00.000Z</published>
    <updated>2022-03-07T11:57:38.005Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）。与最初AspectJ采用编译器将横切逻辑织入到目标对象不同，动态代理和字节码生成都是在运行期间为目标对象生成一个代理对象，而将横切逻辑织入到这个代理对象中，系统最终使用的是织入横切逻辑的代理对象而不是真正的目标对象。</p><p> <img src="/images/pasted-128.png" alt="upload successful"><br>注意：动态代理需要实现统一接口，而cglib生成字节码需要方法可以重写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring AOP采用动态代理机制（先尝试jdk动态代理，如果没有实现相应接口，则采用cglib字节码生成技术）和字节码生成技术实现（对目标对象进行继承拓展，为其生成相应的子类，子类通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的子类即可）</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>AOP国家的公民</title>
    <link href="http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/"/>
    <id>http://example.com/2022/03/07/AOP%E5%9B%BD%E5%AE%B6%E7%9A%84%E5%85%AC%E6%B0%91/</id>
    <published>2022-03-07T10:33:00.000Z</published>
    <updated>2022-03-07T11:39:52.542Z</updated>
    
    <content type="html"><![CDATA[<p>Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。</p><p>Pointcut：Pointcut是Joinpoint的表达方式。将横切逻辑编织入当前系统的过程中，需要参考Pointcut规定的Joinpoint信息，才可以指定应该往系统的哪些Joinpoint上编织横切逻辑。即声明了一个Pointcut就指定了系统中符合条件的一组Joinpoint。</p><p>advice：advice是单一横切关注点逻辑的载体，它代表将会编织到Joinpoint的横切逻辑。如果将Aspect比作OOP中的class，那么advice就相当于class中的method。（常见的如before advice、after advice、after returning advice、after throwing advice，after advice、around advice等）</p><p>Aspect：Aspect是对系统中横切关注点进行模块化封装的AOP概念实体。通常情况下，Aspect可以含有多个Pointcut以及相关Advice定义。</p><p>织入和织入器：织入过程就是“飞架”AOP和OOP的那座桥，只有经过织入过程后，以Aspect模块化的横切关注点才会集成到OOP的现存系统中。而完成织入过程的那个人就是织入器。AspectJ有专门的编译器来完成织入操作，即ajc，所有ajc就是AspectJ完成织入的织入器；JBossAOP采用自定义的类加载器完成最终织入，那么这个类加载器就是他的织入器。SpringAOP使用一组自定义的类来完成最终的织入操作，proxyFactory类则是SpringAOP中最通用的织入器。</p><p>目标对象：符合Pointcut所指定的条件，将在织入过程中被织入横切逻辑的对象，称为目标对象。</p><p>当把所有这些概念组织到一个场景后，就有如下一副场景图：</p><p>   <img src="/images/pasted-127.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Joinpoint：在系统运行前，AOP的功能模块都需要编织入OOP的功能模块中。所以，要进行这种编织，我们需要在哪些执行点进行。这些将要在其上执行编织操作的系统执行点即称之为Joinpoint。&lt;/p&gt;
&lt;p&gt;Pointcut：Pointcut是Joinpoint的表达方</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>为什么需要AOP？</title>
    <link href="http://example.com/2022/03/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F/"/>
    <id>http://example.com/2022/03/07/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F/</id>
    <published>2022-03-07T08:29:00.000Z</published>
    <updated>2022-03-07T08:46:14.426Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发的目的最终是为了解决各种需求，包括业务需求和系统需求。使用面向对象的思想，我们可以对业务需求等普通关注点进行很好的抽象和封装，并且使之模块化。但对于系统需求一类的关注点来说，情况有所不同。</p><p>对于业务需求而言，需求与具体实现直接的关系基本上是一对一的。我们可以在系统中某一个确定的点找到针对这种需求的实现。</p><p>但是在开发测试中或者进入生产环境后需要对系统进行监控，我们需要添加日志功能，除此之外，业务方法的执行可能需要一定的权限限制。那么方法执行前需要有相应的安全检查功能。对于这些系统需求，想要以面向对象的方式实现并集成待整个系统中，不仅仅是一个需求对应一个实现那么简单。可能遍布所有的业务对象。</p><p>因此，提出了AOP（面向切面编程），我们可以对类似于logging和security等系统需求进行模块化组织，简化系统需求和实现的对比关系，进而使得整个系统的实现更具模块化。</p><p>AOP是一种理念，其实现需要一种方式。就好似OOP需要对应的语言支撑一样。AOP也需要某种语言帮助实现相应的概念实体（AOL）。</p><p>静态AOP：相应的横切关注点以Aspect形式实现后，会通过特定的编译器，将实现后的Aspect编织到系统的静态类中。</p><p>静态AOP的优点：Aspect直接以java字节码的形式编译到java类。jvm可以想运行类一样运行，不会对系统造成任何性能损失。</p><p>静态AOP的缺点：灵活性不够，如果横切关注点需要改变织入位置，需要重新修改Aspect，编织进系统。</p><p>动态AOP：AOP的各种概念实体全部都是put的java类，所有容易开发和基础。Aspect和class一样以类的身份作为系统的一员。其织入过程在运行时进行，而不是预先编译织入。而且信息可以采用外部xml等形式保存，在调制编织点时不必变更系统其他模块，甚至在系统运行时，动态更改。但其缺点也很明显，就是在运行时编织，会造成一点的运行时性能损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;软件开发的目的最终是为了解决各种需求，包括业务需求和系统需求。使用面向对象的思想，我们可以对业务需求等普通关注点进行很好的抽象和封装，并且使之模块化。但对于系统需求一类的关注点来说，情况有所不同。&lt;/p&gt;
&lt;p&gt;对于业务需求而言，需求与具体实现直接的关系基本上是一对一的。我</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>创建者模式对比</title>
    <link href="http://example.com/2022/03/07/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2022/03/07/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/</id>
    <published>2022-03-07T07:55:00.000Z</published>
    <updated>2022-03-07T07:58:03.500Z</updated>
    
    <content type="html"><![CDATA[<p>工厂方法模式vs建造者模式</p><pre><code>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</code></pre><p>抽象工厂模式vs建造者模式</p><pre><code>    抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。    建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。    如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工厂方法模式vs建造者模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。

我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="创建者模式" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://example.com/2022/03/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T07:49:00.000Z</published>
    <updated>2022-03-07T07:55:15.846Z</updated>
    
    <content type="html"><![CDATA[<p>概述：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</p><p>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</p><p>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>结构：</p><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</p><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p><p>产品类（Product）：要创建的复杂对象。</p><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p><p>优点：<br>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p><p>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过<br>程更加清晰，也更方便使用程序来控制创建过程。</p><p>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</p><p>缺点：<br>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>使用场景：</p><p>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</p><p>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表<br>示是独立的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;p&gt;分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。&lt;/p&gt;
&lt;p&gt;由于实现了构建和</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="建造者模式" scheme="http://example.com/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://example.com/2022/03/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T07:41:00.000Z</published>
    <updated>2022-03-07T07:48:09.685Z</updated>
    
    <content type="html"><![CDATA[<p>概述：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p>结构：<br>原型模式包含如下角色：<br>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。<br>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。<br>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</p><p>  <img src="/images/pasted-126.png" alt="upload successful"></p><p>  原型模式的克隆分为浅克隆和深克隆。</p><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原<br>有属性所指向的对象的内存地址。</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。（使用对象流，先将原型对象存入file，然后从file读取，即为深克隆）</p><p>Java中的Object类中提供了clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。</p><p>使用场景：对象的创建非常复杂，可以使用原型模式快捷的创建对象。性能和安全要求比较高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。&lt;/p&gt;
&lt;p&gt;结构：&lt;br&gt;原型模式包含如下角色：&lt;br&gt;抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。&lt;br&gt;具体原型类：实现抽象原型类的 clone() 方法，</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="原型模式" scheme="http://example.com/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://example.com/2022/03/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-07T01:24:00.000Z</published>
    <updated>2022-03-07T01:39:37.035Z</updated>
    
    <content type="html"><![CDATA[<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，<br>直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。</p><p>1、简单工厂模式：简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><p>结构：</p><pre><code>简单工厂包含如下角色：抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。具体产品 ：实现或者继承抽象产品的子类具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</code></pre><p>优点：封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p>缺点：增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><p>拓展：静态工厂– 在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是<br>23种设计模式中的。</p><p>2、工厂方法模式：使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><p>概念：定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延<br>迟到其工厂的子类。</p><p>结构：</p><pre><code>工厂方法模式的主要角色：抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</code></pre><p>优点：<br>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，<br>满足开闭原则；</p><p>缺点：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p><p>3、抽象工厂模式：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生<br>产多个等级的产品。</p><pre><code>结构：抽象工厂模式的主要角色如下：抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</code></pre><p>优点：<br>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><p>使用场景：</p><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><p>模式拓展（简单工厂+配置文件解除耦合）：可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全<br>类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p><p>jdk中的工厂方法使用：</p><p>1、集合-迭代器<br>2、DateForamt类中的getInstance()方法使用的是工厂模式；<br>3、Calendar类中的getInstance()方法使用的是工厂模式；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="工厂模式" scheme="http://example.com/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>elementData设置成了transient，那ArrayList是怎么把元素序列化的呢？</title>
    <link href="http://example.com/2022/03/05/elementData%E8%AE%BE%E7%BD%AE%E6%88%90%E4%BA%86transient%EF%BC%8C%E9%82%A3ArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%91%A2%EF%BC%9F/"/>
    <id>http://example.com/2022/03/05/elementData%E8%AE%BE%E7%BD%AE%E6%88%90%E4%BA%86transient%EF%BC%8C%E9%82%A3ArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8A%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%91%A2%EF%BC%9F/</id>
    <published>2022-03-05T05:00:00.000Z</published>
    <updated>2022-03-05T05:03:07.952Z</updated>
    
    <content type="html"><![CDATA[<p>查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。</p><p>一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObject()是为了自己控制序列化的方式，这两个方法必须声明为private，在java.io.ObjectStreamClass#getPrivateMethod()方法中通过反射获取到writeObject()这个方法。</p><p>在ArrayList的writeObject()方法中先调用了s.defaultWriteObject()方法，这个方法是写入非static非transient的属性，在ArrayList中也就是size属性。同样地，在readObject()方法中先调用了s.defaultReadObject()方法解析出了size属性。</p><p>elementData定义为transient的优势，自己根据size序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p><p>源码如下：</p><pre><code>private void writeObject(java.io.ObjectOutputStream s)                throws java.io.IOException&#123;            // 防止序列化期间有修改            int expectedModCount = modCount;            // 写出非transient非static属性（会写出size属性）            s.defaultWriteObject();            // 写出元素个数        s.writeInt(size);            // 依次写出元素        for (int i=0; i&lt;size; i++) &#123;            s.writeObject(elementData[i]);        &#125;            // 如果有修改，抛出异常        if (modCount != expectedModCount) &#123;            throw new ConcurrentModificationException();        &#125;    &#125;        private void readObject(java.io.ObjectInputStream s)            throws java.io.IOException, ClassNotFoundException &#123;        // 声明为空数组        elementData = EMPTY_ELEMENTDATA;            // 读入非transient非static属性（会读取size属性）        s.defaultReadObject();            // 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读        s.readInt();            if (size &gt; 0) &#123;            // 计算容量            int capacity = calculateCapacity(elementData, size);            SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);            // 检查是否需要扩容            ensureCapacityInternal(size);                Object[] a = elementData;            // 依次读取元素到数组中            for (int i=0; i&lt;size; i++) &#123;                a[i] = s.readObject();            &#125;        &#125;    &#125;    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查看writeObject()方法可知，先调用s.defaultWriteObject()方法，再把size写入到流中，再把元素一个一个的写入到流中。&lt;/p&gt;
&lt;p&gt;一般地，只要实现了Serializable接口即可自动序列化，writeObject()和readObjec</summary>
      
    
    
    
    <category term="集合" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/"/>
    
    <category term="ArrayList" scheme="http://example.com/categories/%E9%9B%86%E5%90%88/ArrayList/"/>
    
    
    <category term="transient" scheme="http://example.com/tags/transient/"/>
    
  </entry>
  
  <entry>
    <title>反射和反序列化对单例模式的破坏</title>
    <link href="http://example.com/2022/03/05/%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A0%B4%E5%9D%8F/"/>
    <id>http://example.com/2022/03/05/%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A0%B4%E5%9D%8F/</id>
    <published>2022-03-05T01:45:00.000Z</published>
    <updated>2022-03-05T02:44:20.102Z</updated>
    
    <content type="html"><![CDATA[<p>除了枚举单列模式外，其余的单例实现方式都有可能被反射和反序列化所破坏。那么如何解决反射和反序列化对单例模式的破坏呢？</p><p>1、反射方式破解单例的解决方法:这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操<br>作。</p><pre><code>/** * @author atao * @version 1.0.0 * @ClassName Demo7.java * @Description 懒汉式-方式3（双重检查锁）双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检 * 测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问 * 题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。 * 要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关 * 键字可以保证可见性和有序性。 * @createTime 2022年03月05日 10:35:00 */public class Demo7 &#123;private static volatile Demo7 singleton;private Demo7()&#123;    // 解决反射对单例模式的破坏    if (singleton != null)&#123;        throw new RuntimeException();    &#125;&#125;public static Demo7 getInstance()&#123;    if (singleton == null)&#123;        synchronized (Demo2.class)&#123;            if (singleton == null)&#123;                singleton = new Demo7();            &#125;        &#125;    &#125;    return singleton;&#125;&#125;</code></pre><p>2、在Singleton类中添加 readResolve() 方法，在反序列化时被反射调用，如果定义了这个方法，<br>就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><pre><code>/** * @author atao * @version 1.0.0 * @ClassName Demo8.java * @Description  懒汉式-方式4（静态内部类方式）静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态 * 内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 * static 修饰，保证只被实例化一次，并且严格保证实例化顺序。 * @createTime 2022年03月05日 10:37:00 */public class Demo8 &#123;    private Demo8 singleton;    private Demo8()&#123;    &#125;    private static class inner&#123;        public static Demo8 singleton = new Demo8();    &#125;    public static Demo8 getInstance()&#123;        return Demo8.inner.singleton;    &#125;    /**     * 解决反序列化对单例模式的破坏     * @return     */    private Object readResolve()&#123;        return Demo8.inner.singleton;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了枚举单列模式外，其余的单例实现方式都有可能被反射和反序列化所破坏。那么如何解决反射和反序列化对单例模式的破坏呢？&lt;/p&gt;
&lt;p&gt;1、反射方式破解单例的解决方法:这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操&lt;br&gt;作。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="破坏" scheme="http://example.com/tags/%E7%A0%B4%E5%9D%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件设计原则</title>
    <link href="http://example.com/2022/03/04/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/03/04/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2022-03-04T13:57:00.000Z</published>
    <updated>2022-03-04T14:04:16.777Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><p>1、开闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>2、里式替换原则：里氏代换原则是面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>3、依赖倒转原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>4、接口隔离原则：客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>5、迪米特法则：迪米特法则又叫最少知识原则。<br>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and<br>not to strangers）。<br>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发<br>该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。<br>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象<br>的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>6、合成复用原则：合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br>通常类的复用分为继承复用和合成复用两种。<br>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所<br>以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展<br>与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可<br>能发生变化。<br>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已<br>有对象的功能，它有以下优点：</li><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”<br>复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的<br>对象。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。&lt;/p&gt;
&lt;p&gt;1、开闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计原则" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>UML类图</title>
    <link href="http://example.com/2022/03/04/UML%E7%B1%BB%E5%9B%BE/"/>
    <id>http://example.com/2022/03/04/UML%E7%B1%BB%E5%9B%BE/</id>
    <published>2022-03-04T13:51:00.000Z</published>
    <updated>2022-03-04T13:57:31.240Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-117.png" alt="upload successful"></p><p> 属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p><p>+：表示public</p><p>-：表示private</p><p>#：表示protected</p><p>属性的完整表示方式是： 可见性 名称 ：类型 [ = 缺省值]<br>方法的完整表示方式是： 可见性 名称(参数列表) [ ： 返回类型]</p><p>类之间关系的表示方式：</p><p>1、关联关系：关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师<br>傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。</p><p> <img src="/images/pasted-118.png" alt="upload successful"></p><p> <img src="/images/pasted-119.png" alt="upload successful"></p><p> 自关联：</p><p> <img src="/images/pasted-120.png" alt="upload successful"></p><p> 2、聚合关系：聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。<br>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体<br>对象而独立存在。</p><p> <img src="/images/pasted-121.png" alt="upload successful"></p><p> 3、组合关系：组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，<br>部分对象不能脱离整体对象而存在。</p><p> <img src="/images/pasted-122.png" alt="upload successful"></p><p> 4、依赖关系：依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方<br>法来完成一些职责。</p><p> <img src="/images/pasted-123.png" alt="upload successful"></p><p> 5、继承关系：继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p> <img src="/images/pasted-124.png" alt="upload successful"></p><p> 6、实现关系：实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p> <img src="/images/pasted-125.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-117.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：&lt;/p&gt;
&lt;p&gt;+：表示public&lt;/p</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="UML" scheme="http://example.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>设计模式的分类</title>
    <link href="http://example.com/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://example.com/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2022-03-04T13:31:00.000Z</published>
    <updated>2022-03-04T13:34:39.072Z</updated>
    
    <content type="html"><![CDATA[<p>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。（单例、原型、工厂方法、抽象工厂、建造者等）</p><p>结构型模式：用于描述如何将类或对象按某种布局成更大的结构。（代理、适配器、桥接、装饰、外观、享元、组合等）</p><p>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。（模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访<br>问者、备忘录、解释器等）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。（单例、原型、工厂方法、抽象工厂、建造者等）&lt;/p&gt;
&lt;p&gt;结构型模式：用于描述如何将类或对象按某种布局成更大的结构。（代理、适配器、桥接、装饰、外观、享元、组合等）&lt;/p&gt;
&lt;p&gt;行为型模式：</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="分类" scheme="http://example.com/tags/%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>将革命进行得更彻底一些（classpath-scanning 功能介绍）</title>
    <link href="http://example.com/2022/03/04/%E5%B0%86%E9%9D%A9%E5%91%BD%E8%BF%9B%E8%A1%8C%E5%BE%97%E6%9B%B4%E5%BD%BB%E5%BA%95%E4%B8%80%E4%BA%9B%EF%BC%88classpath-scanning-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%89/"/>
    <id>http://example.com/2022/03/04/%E5%B0%86%E9%9D%A9%E5%91%BD%E8%BF%9B%E8%A1%8C%E5%BE%97%E6%9B%B4%E5%BD%BB%E5%BA%95%E4%B8%80%E4%BA%9B%EF%BC%88classpath-scanning-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%EF%BC%89/</id>
    <published>2022-03-04T08:23:00.000Z</published>
    <updated>2022-03-04T09:01:35.117Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们还是需要将相应对象的bean定义，一个个地添加到IoC容器的配置文件中。与之前唯一的区别就是，不用在配置文件中明确指定依赖关<br>系了（改用注解来表达了嘛）。。既然使用注解来表达对象之间的依赖注入关系，那为什么不搞的彻底<br>一点儿，将那些几乎“光秃秃”的bean定义从配置文件中彻底消灭呢？OK，我们想到了，Spring开发<br>团队也想到了，classpath-scanning的功能正是因此而诞生的！</p><p>使用相应的注解对组成应用程序的相关类进行标注之后，classpath-scanning功能可以从某一顶层<br>包（base package）开始扫描。当扫描到某个类标注了相应的注解之后，就会提取该类的相关信息，构<br>建对应的BeanDefinition，然后把构建完的BeanDefinition注册到容器。这之后所发生的事情就不<br>用我说了，既然相关的类已经添加到了容器，那么后面BeanPostProcessor为@Autowired或者<br>@Resource所提供的注入肯定是有东西拿咯！</p><p>classpath-scanning功能的触发是由<a href="context:component-scan">context:component-scan</a>决定的。</p><p><a href="context:component-scan">context:component-scan</a>默认扫描的注解类型是@Component。不过，在@Component语义基<br>础上细化后的@Repository、@Service和@Controller也同样可以获得<a href="context:component-scan">context:component-scan</a><br>的青睐。@Component的语义更广、更宽泛，而@Repository、@Service和@Controller的语义则更具<br>体。所以，同样对于服务层的类定义来说，使用@Service标注它，要比使用@Component更为确切。<br>对于其他两种注解也是同样道理，我们暂且使用语义更广的@Component来标注FXNews相关类，以便<br>摆脱每次都要向IoC容器配置添加bean定义的苦恼。</p><p><a href="context:component-scan">context:component-scan</a>在扫描相关类定义并将它们添加到容器的时候，会使用一种默认的<br>命名规则，来生成那些添加到容器的bean定义的名称（beanName）。比如DowJonesNewsPersister通<br>过默认命名规则将获得dowJonesNewsPersister作为bean定义名称。如果想改变这一默认行为，可以指定一个自定义的名称</p><p>你或许会觉得有些诧异，因为我们并没有使用<a href="context:annotation-config">context:annotation-config</a>甚至直接将相应<br>的BeanPostProcessor添加到容器中，而FXNewsProvider怎么会获得相应的依赖注入呢？这个得怪<br><a href="context:component-scan">context:component-scan</a>“多管闲事”，它同时将AutowiredAnnotationBeanPostProcessor和<br>CommonAnnotationBeanPostProcessor一并注册到了容器中，所以，依赖注入的需求得以满足。如<br>果你不喜欢，非要自己通过 <a href="context:annotation-config">context:annotation-config</a> 或者直接添加相关 BeanPostProcessor的方式来满足@Autowired或者@Resource的需求，可以将<a href="context:component-scan">context:component-scan</a>的<br>annotation-config属性值从默认的true改为false。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;到目前为止，我们还是需要将相应对象的bean定义，一个个地添加到IoC容器的配置文件中。与之前唯一的区别就是，不用在配置文件中明确指定依赖关&lt;br&gt;系了（改用注解来表达了嘛）。。既然使用注解来表达对象之间的依赖注入关系，那为什么不搞的彻底&lt;br&gt;一点儿，将那些几乎“光秃秃”</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="IOC" scheme="http://example.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>Autowired之外的选择——使用JSR250 标注依赖注入关系</title>
    <link href="http://example.com/2022/03/04/Autowired%E4%B9%8B%E5%A4%96%E7%9A%84%E9%80%89%E6%8B%A9%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8JSR250-%E6%A0%87%E6%B3%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%85%B3%E7%B3%BB/"/>
    <id>http://example.com/2022/03/04/Autowired%E4%B9%8B%E5%A4%96%E7%9A%84%E9%80%89%E6%8B%A9%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8JSR250-%E6%A0%87%E6%B3%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%85%B3%E7%B3%BB/</id>
    <published>2022-03-04T08:20:00.000Z</published>
    <updated>2022-03-04T08:22:53.133Z</updated>
    
    <content type="html"><![CDATA[<p>除了可以使用Spring提供的@Autowired和@Qualifier来<br>标注相应类定义之外，还可以使用JSR250的@Resource和@PostConstruct以及@PreDestroy对相应<br>类进行标注，这同样可以达到依赖注入的目的。</p><p>@Resource与@Autowired不同，它遵循的是byName自动绑定形式的行为准则，也就是说，IoC容<br>器将根据@Resource所指定的名称，到容器中查找beanName与之对应的实例，然后将查找到的对象实<br>例注入给@Resource所标注的对象。</p><p>JSR250规定，如果@Resource标注于属性域或者方法之上的话，相应的容器将负责把指定的资源<br>注入给当前对象，所以，除了像我们这样直接在属性域上标注@Resource，还可以在构造方法或者普<br>通方法定义上标注@Resource，这与@Autowired能够存在的地方大致相同。</p><p>确切地说， 10 @PostConstruct和@PreDestroy不是服务于依赖注入的，它们主要用于标注对象生<br>命周期管理相关方法，这与Spring的InitializingBean和DisposableBean接口，以及配置项中的<br>init-method和destroy-method起到类似的作用。</p><p>如果想某个方法在对象实例化之后被调用，以做某些准备工作，或者想在对象销毁之前调用某个<br>方法清理某些资源，那么就可以像我们这样，使用@PostConstruct和@PreDestroy来标注这些方法。<br>当然，是使用@PostConstruct和@PreDestroy，还是使用Spring的InitializingBean和Disposable-Bean接口，或者init-method和destroy-method配置项，可以根据个人的喜好自己决定。</p><p>天上永远不会掉馅饼，我们只是使用@Resource或者@PostConstruct和@PreDestroy标注了相应<br>对象，并不能给该对象带来想要的东西。所以，就像@Autowired需要AutowiredAnnotationBeanPostProcessor为它与IoC容器牵线搭桥一样，JSR250的这些注解也同样需要一个BeanPostProcessor帮助它们实现自身的价值。这个BeanPostProcessor就是org.springframework.context.<br>annotation.CommonAnnotationBeanPostProcessor，只有将CommonAnnotationBeanPostProcessor添<br>加到容器，JSR250的相关注解才能发挥作用</p><p>既然不管是@Autowired还是@Resource都需要添加相应的BeanPostProcessor到容器，那么我们<br>就可以在基于XSD的配置文件中使用一个<a href="context:annotation-config">context:annotation-config</a>配置搞定以上所有的<br>BeanPostProcessor配置</p><p><a href="context:annotation-config">context:annotation-config</a> 不但帮我们把 AutowiredAnnotationBeanPostProcessor 和<br>CommonAnnotationBeanPostProcessor注册到容器，同时还会把PersistenceAnnotationBeanPostProcessor和RequiredAnnotationBeanPostProcessor一并进行注册，可谓一举四得啊！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了可以使用Spring提供的@Autowired和@Qualifier来&lt;br&gt;标注相应类定义之外，还可以使用JSR250的@Resource和@PostConstruct以及@PreDestroy对相应&lt;br&gt;类进行标注，这同样可以达到依赖注入的目的。&lt;/p&gt;
&lt;p&gt;@</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Qualifier的陪伴</title>
    <link href="http://example.com/2022/03/04/Qualifier%E7%9A%84%E9%99%AA%E4%BC%B4/"/>
    <id>http://example.com/2022/03/04/Qualifier%E7%9A%84%E9%99%AA%E4%BC%B4/</id>
    <published>2022-03-04T08:19:00.000Z</published>
    <updated>2022-03-04T08:20:06.461Z</updated>
    
    <content type="html"><![CDATA[<p>@Autowired是按照类型进行匹配，如果当前@Autowired标注的依赖在容器中只能找到一个实例<br>与之对应的话，那还好。可是，要是能够同时找到两个或者多个同一类型的对象实例，又该怎么办呢？<br>我们自己当然知道应该把具体哪个实例注入给当前对象，可是，IoC容器并不知道，所以，得通过某<br>种方式告诉它。这时，就可以使用@Qualifier对依赖注入的条件做进一步限定，使得容器不再迷茫。</p><p>@Qualifier实际上是byName自动绑定的注解版，既然IoC容器无法自己从多个同一类型的实例中<br>选取我们真正想要的那个，那么我们不妨就使用@Qualifier直接点名要哪个好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@Autowired是按照类型进行匹配，如果当前@Autowired标注的依赖在容器中只能找到一个实例&lt;br&gt;与之对应的话，那还好。可是，要是能够同时找到两个或者多个同一类型的对象实例，又该怎么办呢？&lt;br&gt;我们自己当然知道应该把具体哪个实例注入给当前对象，可是，IoC容器</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring基于注解的依赖注入</title>
    <link href="http://example.com/2022/03/04/Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2022/03/04/Spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</id>
    <published>2022-03-04T08:14:00.000Z</published>
    <updated>2022-03-04T08:18:55.251Z</updated>
    
    <content type="html"><![CDATA[<p>@Autowired是基于注解的依赖注入的核心注解，它的存在可以让容器知道需要为当前类注入哪些<br>依赖。比如可以使用@Autowired对类进行标注，以表明要为该类注入的依赖。</p><p>@Autowired也是按照类型匹配进行依赖注入的</p><p>@Autowired可以标注于类定义的多个位置，包括如下几个。</p><p>1、域（Filed）或者说属性（Property）。不管它们声明的访问限制符是private、protected还是public，只要标注了@Autowired，它们所需要的依赖注入需求就都能够被满足。</p><p>2、构造方法定义（Constructor）。标注于类的构造方法之上的@Autowired，相当于抢夺了原有自<br>动绑定功能中“constructor”方式的权利，它将根据构造方法参数类型，来决定将什么样的依赖对象注入给当前对象。</p><p>3、方法定义（Method）。@Autowired不仅可以标注于传统的setter方法之上，而且还可以标注于任<br>意名称的方法定义之上，只要该方法定义了需要被注入的参数。</p><p>现在，虽然可以随意地在类定义的各种合适的地方标注@Autowired，希望这些被@Autowired标<br>注的依赖能够被注入，但是，仅将@Autowired标注于类定义中并不能让Spring的IoC容器聪明到自己<br>去查看这些注解，然后注入符合条件的依赖对象。容器需要某种方式来了解，哪些对象标注了<br>@Autowired，哪些对象可以作为可供选择的依赖对象来注入给需要的对象。在考虑使用什么方式实<br>现这一功能之前，我们先比较一下原有的自动绑定功能与使用@Autowired之后产生了哪些差别。</p><p>使用自动绑定的时候，我们将所有对象相关的bean定义追加到了容器的配置文件中，然后使用<br>default-autowire或者autowire告知容器，依照这两种属性指定的绑定方式，将容器中各个对象绑定到一起。在使用@Autowired之后，default-autowire或者autowire的职责就转给了@Autowired，<br>所以，现在，容器的配置文件中就只剩下了一个个孤伶伶的bean定义</p><p>为了给容器中定义的每个bean定义对应的实例注入依赖，可以遍历它们，然后通过反射，检查每<br>个bean定义对应的类上各种可能位置上的@Autowired。如果存在的话，就可以从当前容器管理的对象<br>中获取符合条件的对象，设置给@Autowired所标注的属性域、构造方法或者方法定义。</p><p>我们可以提供一个Spring<br>的IoC容器使用的BeanPostProcessor自定义实现，让这个BeanPostProcessor在实例化bean定义的<br>过程中，来检查当前对象是否有@Autowired标注的依赖需要注入。org.springframework.beans.<br>factory.annotation.AutowiredAnnotationBeanPostProcessor就是Spring提供的用于这一目的<br>的BeanPostProcessor实现。所以，很幸运，我们不用自己去实现它了。</p><p>相关类定义使用@Autowired标注之后，只要在IoC容器的配置文件中追加AutowiredAnnotationBeanPostProcessor就可以让整个应用开始运作了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;@Autowired是基于注解的依赖注入的核心注解，它的存在可以让容器知道需要为当前类注入哪些&lt;br&gt;依赖。比如可以使用@Autowired对类进行标注，以表明要为该类注入的依赖。&lt;/p&gt;
&lt;p&gt;@Autowired也是按照类型匹配进行依赖注入的&lt;/p&gt;
&lt;p&gt;@Autow</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="注解" scheme="http://example.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
</feed>
