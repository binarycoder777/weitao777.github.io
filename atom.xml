<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-03T13:56:15.460Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring的IOC容器之BeanFactory</title>
    <link href="http://example.com/2022/03/03/Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E4%B9%8BBeanFactory/"/>
    <id>http://example.com/2022/03/03/Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E4%B9%8BBeanFactory/</id>
    <published>2022-03-03T13:21:00.000Z</published>
    <updated>2022-03-03T13:56:15.460Z</updated>
    
    <content type="html"><![CDATA[<p>BeanFactory，顾名思义，就是生产Bean的工厂。当然，严格来说，这个“生产过程”可能不像<br>说起来那么简单。既然Spring框架提倡使用POJO，那么把每个业务对象看作一个JavaBean对象，或许<br>更容易理解为什么Spring的IoC基本容器会起这么一个名字。作为Spring提供的基本的IoC容器，<br>BeanFactory可以完成作为IoC Service Provider的所有职责，包括业务对象的注册和对象间依赖关系的<br>绑定。</p><p>BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零<br>件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。相似地，将应用所需<br>的所有业务对象交给BeanFactory之后，剩下要做的，就是直接从BeanFactory取得最终组装完成并<br>且可用的对象。至于这个最终业务对象如何组装，你不需要关心，BeanFactory会帮你搞定。</p><p>所以，对于客户端来说，与BeanFactory打交道其实很简单。最基本地，BeanFactory肯定会公<br>开一个取得组装完成的对象的方法接口，就像代码清单4-1中真正的BeanFactory的定义所展示的那<br>样。</p><p>BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。相似地，将应用所需的所有业务对象交给BeanFactory之后，剩下要做的，就是直接从BeanFactory取得最终组装完成并<br>且可用的对象。至于这个最终业务对象如何组装，你不需要关心，BeanFactory会帮你搞定。</p><p>当BeanFactory说这些事情让它来做的时候，可能没有告诉你它会怎么来做<br>这个事情。不过没关系，我们通常只需将“生产线图纸”交给BeanFactory就行了。通常情况下，它会通过常用的图纸（XML文件）来注册并管理各个业务对象之间的依赖关系。</p><p>当然BeanFactory只是一个接口，我们最终需要一个该接口的实现来进行实际的Bean的管理，DefaultListableBeanFactory就是这么一个比较通用的BeanFactory实现类。</p><p>DefaultListableBeanFactory除了间接地实现了BeanFactory接口，还实现了BeanDefinitionRegistry接口，该接口才是在BeanFactory的实现中担当Bean注册管理的角色。基本上，BeanFactory接口只定义如何访问容器内管理的Bean的方法，各个BeanFactory的具体实现类负责具体Bean的注册以及管理工作。BeanDefinitionRegistry接口定义抽象了Bean的注册逻辑。通常情况下，具体的BeanFactory实现类会实现这个接口来管理Bean的注册。</p><p> <img src="/images/pasted-110.png" alt="upload successful"></p><p> 每一个受管的对象，在容器中都会有一个BeanDefinition的实例（instance）与之相对应，该<br>BeanDefinition的实例负责保存对象的所有必要信息，包括其对应的对象的class类型、是否是抽象<br>类、构造方法参数以及其他属性等。当客户端向BeanFactory请求相应对象的时候，BeanFactory会<br>通过这些信息为客户端返回一个完备可用的对象实例。RootBeanDefinition和ChildBeanDefinition是BeanDefinition的两个主要实现类。</p><p>采用外部配置文件时，Spring的IoC容器有一个统一的处理方式。通常情况下，需要根据不同的外<br>部配置文件格式，给出相应的BeanDefinitionReader实现类，由BeanDefinitionReader的相应实<br>现类负责将相应的配置文件内容读取并映射到BeanDefinition，然后将映射后的BeanDefinition注<br>册到一个BeanDefinitionRegistry，之后，BeanDefinitionRegistry即完成Bean的注册和加载。<br>当然，大部分工作，包括解析文件格式、装配BeanDefinition之类的工作，都是由BeanDefinitionReader的相应实现类来做的，BeanDefinitionRegistry只不过负责保管而已。</p><p>与为  Properties配置文件格式提供PropertiesBeanDefinitionReader相对应，Spring同样为XML<br>格式的配置文件提供了现成的BeanDefinitionReader实现，即XmlBeanDefinitionReader。<br>XmlBeanDefinitionReader负责读取Spring指定格式的XML配置文件并解析，之后将解析后的文件内<br>容映射到相应的BeanDefinition，并加载到相应的<br>BeanDefinitionRegistry中（在这里是DefaultListableBeanFactory）。这时，整个BeanFactory就可以放给客户端使用了。除了提供XmlBeanDefinitionReader用于XML格式配置文件的加载，Spring还在DefaultListableBeanFactory的基础上构建了简化XML格式配置加载的XmlBeanFactory实现。</p><p>如果要通过注解标注的方式为类注入所需要的依赖，现在可以使用@Autowired以 及@Component等对相关类进行标记。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;BeanFactory，顾名思义，就是生产Bean的工厂。当然，严格来说，这个“生产过程”可能不像&lt;br&gt;说起来那么简单。既然Spring框架提倡使用POJO，那么把每个业务对象看作一个JavaBean对象，或许&lt;br&gt;更容易理解为什么Spring的IoC基本容器会起这么一</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="BeanFactory" scheme="http://example.com/tags/BeanFactory/"/>
    
  </entry>
  
  <entry>
    <title>Spring的IOC容器</title>
    <link href="http://example.com/2022/03/03/Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2022/03/03/Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8/</id>
    <published>2022-03-03T13:11:00.000Z</published>
    <updated>2022-03-03T13:20:31.109Z</updated>
    
    <content type="html"><![CDATA[<p>Spring的IoC容器是一个IoC Service Provider，但是，这只是它被冠以IoC之名的部分原因，我们不能忽略的是“容器”。Spring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spring的IoC容器之上，Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring的IoC容器和IoCService Provider所提供的服务之间存在一定的交集。</p><p> <img src="/images/pasted-109.png" alt="upload successful"></p><p> Spring提供了两种容器类型：BeanFactoryApplicationContext</p><p>  BeanFactory。基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的<br>IoC容器选择。</p><p>  ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring的IoC容器是一个IoC Service Provider，但是，这只是它被冠以IoC之名的部分原因，我们不能忽略的是“容器”。Spring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spri</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="IOC" scheme="http://example.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>—IoC Service Provider 如何管理对象间的 依赖关系</title>
    <link href="http://example.com/2022/03/03/%E2%80%94IoC-Service-Provider-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"/>
    <id>http://example.com/2022/03/03/%E2%80%94IoC-Service-Provider-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</id>
    <published>2022-03-03T10:30:00.000Z</published>
    <updated>2022-03-03T13:11:08.016Z</updated>
    
    <content type="html"><![CDATA[<p>IoC Service Provider不是人类，也就不能像酒吧服务生那样通过大脑来记忆和存储所有的相关信<br>息。所以，它需要寻求其他方式来记录诸多对象之间的对应关系。比如：</p><p> 它可以通过最基本的文本文件来记录被注入对象和其依赖对象之间的对应关系； </p><p> 它也可以通过描述性较强的XML文件格式来记录对应信息；</p><p> 它还可以通过编写代码的方式来注册这些对应信息； </p><p> 甚至，如果愿意，它也可以通过语音方式来记录对象间的依赖注入关系（“嗨，它要一个这种类型的对象，拿这个给它”）。</p><p>那么，实际情况下，各种具体的IoC Service Provider实现又是通过哪些方式来记录“服务信息”的呢？我们可以归纳一下，当前流行的 IoC Service Provider产品使用的注册对象管理信息的方式主要有以下几种。</p><p>1、直接编码方式</p><p>2、配置文件方式</p><p>3、元数据方式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IoC Service Provider不是人类，也就不能像酒吧服务生那样通过大脑来记忆和存储所有的相关信&lt;br&gt;息。所以，它需要寻求其他方式来记录诸多对象之间的对应关系。比如：&lt;/p&gt;
&lt;p&gt; 它可以通过最基本的文本文件来记录被注入对象和其依赖对象之间的对应关系； &lt;/</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="IOC" scheme="http://example.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>IoC Service Provider 的职责</title>
    <link href="http://example.com/2022/03/03/IoC-Service-Provider-%E7%9A%84%E8%81%8C%E8%B4%A3/"/>
    <id>http://example.com/2022/03/03/IoC-Service-Provider-%E7%9A%84%E8%81%8C%E8%B4%A3/</id>
    <published>2022-03-03T10:27:00.000Z</published>
    <updated>2022-03-03T10:28:50.333Z</updated>
    
    <content type="html"><![CDATA[<p>IoC Service Provider的职责相对来说比较简单，主要有两个：业务对象的构建管理和业务对象间<br>的依赖绑定。</p><p> 业务对象的构建管理。在IoC场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。所以，IoC Service Provider需要将对象的构建逻辑从客户端对象那里剥离出来，以免这部分逻辑污染业务对象的实现。</p><p> 业务对象间的依赖绑定。对于IoC Service Provider来说，这个职责是最艰巨也是最重要的，这是它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不<br>会得到依赖对象的任何响应（最常见的倒是会收到一个NullPointerException）。IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状<br>态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IoC Service Provider的职责相对来说比较简单，主要有两个：业务对象的构建管理和业务对象间&lt;br&gt;的依赖绑定。&lt;/p&gt;
&lt;p&gt; 业务对象的构建管理。在IoC场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。所以，IoC S</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="IoC Service Provider" scheme="http://example.com/tags/IoC-Service-Provider/"/>
    
  </entry>
  
  <entry>
    <title>IOC的基本理念：让别人为你服务</title>
    <link href="http://example.com/2022/03/03/IOC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E5%BF%B5%EF%BC%9A%E8%AE%A9%E5%88%AB%E4%BA%BA%E4%B8%BA%E4%BD%A0%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2022/03/03/IOC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E5%BF%B5%EF%BC%9A%E8%AE%A9%E5%88%AB%E4%BA%BA%E4%B8%BA%E4%BD%A0%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-03-03T09:01:00.000Z</published>
    <updated>2022-03-03T10:25:33.400Z</updated>
    
    <content type="html"><![CDATA[<p>IOC即控制反转，它还有一个别名叫做依赖注入（Dependency<br>Injection）。</p><p>在我日常开发中，经常需要一个对象依赖于另一个对象的服务。最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。这就好比要装修新房，需要用家具，这个时候，根据通常解决<br>对象依赖关系的做法，我们就会直接打造出需要的家具来。不过，通常都是分工明确的，所以，大多数情况下，我们可以去家具广场将家具买回来，然后根据需要装修布置即可。不管是直接打造家具（通过new构造对象），还是去家具广场买家具（通过工厂设计模式），有一个共同点需要我们关注，那就是我们都是自己主动地去获取依赖的对象！可是回头想想，我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。</p><p>实际上IOC就是为了帮助我们解决这种问题的，而提供了更加轻松简洁的方式。它的反转，就反转在让你从原来的事必躬亲，转变为现在的享受服务。</p><p>通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过IoC Service Provider来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。被注入对象需要什么，直接跟IoC Service Provider招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到IoC Service Provider为被注入对象服务的目的。IoC Service Provider在这里就是通常的IoC容器所充当的角色。从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转，控制也从被注入对象转到了IoC Service Provider那里。</p><p> <img src="/images/pasted-107.png" alt="upload successful"></p><p> （IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定<br>到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或<br>者IoC容器实现。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IOC即控制反转，它还有一个别名叫做依赖注入（Dependency&lt;br&gt;Injection）。&lt;/p&gt;
&lt;p&gt;在我日常开发中，经常需要一个对象依赖于另一个对象的服务。最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。这就好比要装修新房，需要用家具，这个时候，根据</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="IOC的理解" scheme="http://example.com/tags/IOC%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring三种注入方法比较</title>
    <link href="http://example.com/2022/03/03/Spring%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2022/03/03/Spring%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/</id>
    <published>2022-03-03T08:53:00.000Z</published>
    <updated>2022-03-03T08:54:49.415Z</updated>
    
    <content type="html"><![CDATA[<p> 接口注入。从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退<br>役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter<br>方法注入则不需要如此。</p><p>构造方法注入。这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以  马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反<br>射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且<br>在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多<br>个构造方法，而参数数量的变动可能造成维护上的不便。</p><p>setter方法注入。因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。  另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无<br>法在构造完成后马上进入就绪状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 接口注入。从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退&lt;br&gt;役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter&lt;br&gt;方法注入则不需要如此。&lt;/p&gt;
&lt;p&gt;构造方法注入。这种注入方式的优点就是，对象在构造完</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/categories/Spring/"/>
    
    
    <category term="注入方式" scheme="http://example.com/tags/%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL怎么查看索引是否是高选择性？</title>
    <link href="http://example.com/2022/03/02/MySQL%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E6%98%AF%E9%AB%98%E9%80%89%E6%8B%A9%E6%80%A7%EF%BC%9F/"/>
    <id>http://example.com/2022/03/02/MySQL%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E6%98%AF%E9%AB%98%E9%80%89%E6%8B%A9%E6%80%A7%EF%BC%9F/</id>
    <published>2022-03-02T11:33:00.000Z</published>
    <updated>2022-03-02T11:40:36.822Z</updated>
    
    <content type="html"><![CDATA[<p>通过show index查看结果列中的cardinality值（表示索引中不重复记录数量的预估值），在实际应用中cardinality/table.size应该尽可能接近1。</p><p>cardinality是在存储引擎层进行统计的。具体方式是通过采样的方法来完成。具体发生在insert和update操作中，策略为①表中1/16数据发生过变化②stat_modified_counter&gt;2 000 000 000（表中数据实际未增加，实际发生变化的还是这一行数据①就无法适用，则通过②的计数器stat_modirfied_counter表示发生变化次数）。</p><p> <img src="/images/pasted-106.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过show index查看结果列中的cardinality值（表示索引中不重复记录数量的预估值），在实际应用中cardinality/table.size应该尽可能接近1。&lt;/p&gt;
&lt;p&gt;cardinality是在存储引擎层进行统计的。具体方式是通过采样的方法来完成。具体</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB行溢出（Redundant）</title>
    <link href="http://example.com/2022/03/02/InnoDB%E8%A1%8C%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2022/03/02/InnoDB%E8%A1%8C%E6%BA%A2%E5%87%BA/</id>
    <published>2022-03-02T10:45:00.000Z</published>
    <updated>2022-03-02T10:53:16.247Z</updated>
    
    <content type="html"><![CDATA[<p>3个列长度总和是66000，innoDB存储引擎的页为16kb，16384字节，会产生行溢出，因此对于这种情况，数据不会存放于b+tree的叶子节点中，而是存入页类型为uncompress blob页中。</p><p> <img src="/images/pasted-105.png" alt="upload successful"></p><p> 每页中至少存放两条行记录（否则失去了B+tree的意义，变为了链表），因此如果一页中只能放一条记录，则会将数据放到溢出页。而对于Text或BLOB的数据类型亦然。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3个列长度总和是66000，innoDB存储引擎的页为16kb，16384字节，会产生行溢出，因此对于这种情况，数据不会存放于b+tree的叶子节点中，而是存入页类型为uncompress blob页中。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-1</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="行结构" scheme="http://example.com/tags/%E8%A1%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中varchar中的N</title>
    <link href="http://example.com/2022/03/02/MySQL%E4%B8%ADvarchar%E4%B8%AD%E7%9A%84N/"/>
    <id>http://example.com/2022/03/02/MySQL%E4%B8%ADvarchar%E4%B8%AD%E7%9A%84N/</id>
    <published>2022-03-02T10:42:00.000Z</published>
    <updated>2022-03-02T10:44:12.635Z</updated>
    
    <content type="html"><![CDATA[<p>varchar(N)指的是字符长度，而官方文档中指的是最大支持65535是字节</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;varchar(N)指的是字符长度，而官方文档中指的是最大支持65535是字节&lt;/p&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="行" scheme="http://example.com/tags/%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 系统中查看 TCP 状态？</title>
    <link href="http://example.com/2022/02/25/%E5%A6%82%E4%BD%95%E5%9C%A8-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B-TCP-%E7%8A%B6%E6%80%81%EF%BC%9F/"/>
    <id>http://example.com/2022/02/25/%E5%A6%82%E4%BD%95%E5%9C%A8-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B-TCP-%E7%8A%B6%E6%80%81%EF%BC%9F/</id>
    <published>2022-02-25T01:56:00.000Z</published>
    <updated>2022-02-25T01:58:06.991Z</updated>
    
    <content type="html"><![CDATA[<p>netstat-napt</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;netstat-napt&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>最左匹配原则</title>
    <link href="http://example.com/2022/02/24/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/02/24/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/</id>
    <published>2022-02-24T08:02:00.000Z</published>
    <updated>2022-02-24T08:04:16.906Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p><p>   select * from user where name=xx and city=xx ; ／／可以命中索引 </p><p>   select * from user where name=xx ; // 可以命中索引 </p><p>   select * from user where city=xx; // 无法命中索引 </p><pre><code>需要注意：查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDERBY子句也遵循此规则。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：&lt;/p&gt;
&lt;p&gt;   select </summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="最左匹配原则" scheme="http://example.com/tags/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>一条SQL语句执行得很慢的原因有哪些？</title>
    <link href="http://example.com/2022/02/24/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/"/>
    <id>http://example.com/2022/02/24/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</id>
    <published>2022-02-24T07:50:00.000Z</published>
    <updated>2022-02-24T07:59:49.798Z</updated>
    
    <content type="html"><![CDATA[<p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log 页写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><pre><code>转载：https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN%23rd</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个 SQL 执行的很慢，我们要分两种情况讨论：&lt;/p&gt;
&lt;p&gt;1、大多数情况下很正常，偶尔很慢，则有如下原因&lt;/p&gt;
&lt;p&gt;(1)、数据库在刷新脏页，例如 redo log 页写满了需要同步到磁盘。&lt;/p&gt;
&lt;p&gt;(2)、执行的时候，遇到锁，如表锁、行锁。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="性能" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>分库分表之后的主键处理方式</title>
    <link href="http://example.com/2022/02/24/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%BB%E9%94%AE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/02/24/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%BB%E9%94%AE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2022-02-24T04:56:00.000Z</published>
    <updated>2022-02-24T05:00:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>1、UUID：不适合作为主键，其太长了而且无序，插入效率低</p><p>2、数据库自增id：两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。</p><p>3、利⽤ redis ⽣成 id : 性能⽐᫾好，灵活⽅便，不依赖于数据库。但是，引⼊了新的组件造成<br>系统更加复杂，可⽤性降低，编码更加复杂，增加了系统成本。</p><p>4、Twitter的snowflake算法：</p><p> <img src="/images/pasted-102.png" alt="upload successful"></p><p> 1.第一位</p><p>占用1bit，其值始终是0，没有实际作用。</p><p>2.时间戳</p><p>占用41bit，精确到毫秒，总共可以容纳约140年的时间。</p><p>3.工作机器id</p><p>占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。</p><p>4.序列号</p><p>占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。</p><p>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法：</p><p>1024x4096</p><p>SnowFlake算法的优点：</p><p>1.生成ID时不依赖于DB，完全在内存生成，高性能高可用。</p><p>2.ID呈趋势递增，后续插入索引树的时候性能较好。</p><p>SnowFlake算法的缺点：</p><p>依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、UUID：不适合作为主键，其太长了而且无序，插入效率低&lt;/p&gt;
&lt;p&gt;2、数据库自增id：两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。&lt;/p&gt;
&lt;p&gt;3、利⽤ redis </summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="主键" scheme="http://example.com/tags/%E4%B8%BB%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>http常见状态码</title>
    <link href="http://example.com/2022/02/23/http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://example.com/2022/02/23/http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2022-02-23T07:48:00.000Z</published>
    <updated>2022-02-23T07:56:43.034Z</updated>
    
    <content type="html"><![CDATA[<p>1xx：表示一种提示信息，一般是服务器的中间状态，不常用</p><p>2xx：表示服务器已经成功处理了请求</p><p>200：成功<br>204：成功（响应头没有body数据）<br>206：用于http分块下载或者断点续传，表示响应的body里面的数据并不完整，只是一部分</p><p>3xx：客户端请求的资源发生了变动需要重定向</p><p>301：表示永久重定向，即访问的资源永久不存在</p><p>302：临时重定向，即访问的资源还在，需要换一个url访问</p><p>301和302会在响应头使用location字段表明重定向的url进行重定向</p><p>304：不具有跳转含义，表明请求的资源未修改，重定向缓存文件。</p><p>4xx：请求的报文有误，服务器无法处理</p><p>400：请求错误，具体不清楚</p><p>403：服务器禁止访问资源</p><p>404：访问的资源在服务器找不到</p><p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p><p>「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p><p>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p><p>「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器<br>发⽣了错误。</p><p>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意<br>思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1xx：表示一种提示信息，一般是服务器的中间状态，不常用&lt;/p&gt;
&lt;p&gt;2xx：表示服务器已经成功处理了请求&lt;/p&gt;
&lt;p&gt;200：成功&lt;br&gt;204：成功（响应头没有body数据）&lt;br&gt;206：用于http分块下载或者断点续传，表示响应的body里面的数据并不完整，只是</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://example.com/2022/02/23/http/"/>
    <id>http://example.com/2022/02/23/http/</id>
    <published>2022-02-23T07:37:47.000Z</published>
    <updated>2022-02-23T07:38:21.504Z</updated>
    
    <content type="html"><![CDATA[<p>http是计算机世界里面两点之间进行文字、图片、视频等超文本数据传输的协议</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;http是计算机世界里面两点之间进行文字、图片、视频等超文本数据传输的协议&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>get和post的区别</title>
    <link href="http://example.com/2022/02/18/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/02/18/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-02-18T14:38:00.000Z</published>
    <updated>2022-02-18T14:39:22.715Z</updated>
    
    <content type="html"><![CDATA[<p>POST和GET都是向服务器提交数据，并且都会从服务器获取数据。</p><p>区别：</p><p>1、传送方式：get通过地址栏传输，post通过报文传输。</p><p>2、传送长度：get参数有长度限制（受限于url长度），而post无限制</p><p>3、GET和POST还有一个重大区别，简单的说：</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包</p><p>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol><p>建议：</p><p>1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；</p><p>2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p><p>案例：一般情况下，登录的时候都是用的POST传输，涉及到密码传输，而页面查询的时候，如文章id查询文章，用get 地址栏的链接为：article.php?id=11，用post查询地址栏链接为：article.php， 不会将传输的数据展现出来。</p><p>拓展资料：</p><p>GET在浏览器回退时是无害的，而POST会再次提交请求。</p><p>GET产生的URL地址可以被Bookmark，而POST不可以。</p><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p><p>GET请求只能进行url编码，而POST支持多种编码方式。</p><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p><p>GET请求在URL中传送的参数是有长度限制的，而POST么有。</p><p>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</p><p>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p><p>GET参数通过URL传递，POST放在Request body中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;POST和GET都是向服务器提交数据，并且都会从服务器获取数据。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;1、传送方式：get通过地址栏传输，post通过报文传输。&lt;/p&gt;
&lt;p&gt;2、传送长度：get参数有长度限制（受限于url长度），而post无限制&lt;/p&gt;
&lt;p&gt;3、GET</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="get" scheme="http://example.com/tags/get/"/>
    
    <category term="post" scheme="http://example.com/tags/post/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://example.com/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-02-11T13:22:00.000Z</published>
    <updated>2022-02-11T13:38:00.109Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。说直白一点就是在不修改目标对象的基础上，使用代理对象来增强目标对象的业务逻辑方法。</p><p>代理模式分为：静态代理和动态代理（jdk动态代理和cglib动态代理）</p><p>静态代理就是：代理类在程序运行前就确定好了和目标类的关系，在编译期就实现了。其中静态代理的缺点在于：</p><p>1、代码复杂，不便于管理：试想对于代理类，需要和目标类实现相同接口即每个代理类都要实现目标类的的方法，会出现代码重复，且考虑到如果接口增加一个方法，其所有实现类都要重写，维护也麻烦。</p><p>2、代理类依赖于目标类：当代理类考虑代理多个服务的时候，不便于实现</p><p>动态代理是在程序运行期间根据jvm反射机制动态生成的。</p><p>jdk动态代理：基于java反射机制实现的。具体通过使用java.lang.reflect 包提供三个类支持代理模式 Proxy, Method和 InovcationHandler。（要求：求目标对象必须实现接口）</p><pre><code>public interface UsbSell &#123;    Object sell(float amount);&#125;public class UsbFactory implements UsbSell &#123;public Object sell(float amount) &#123;    float price = 0;    if (amount &gt; 100)&#123;        price = (float) (amount * (1 + 0.2));    &#125;else &#123;        price = (float) (amount * (1 + 0.5));    &#125;    return price;    &#125;&#125;public class ProxySeller &#123;private Object target;public ProxySeller() &#123;&#125;public ProxySeller(Object target) &#123;    this.target = target;&#125;public Object getProxy()&#123;    return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123;        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;            float res = (Float) method.invoke(target,args);            System.out.println(&quot;==&quot;+res);            return proxy;        &#125;    &#125;);&#125;&#125;public class Main &#123;public static void main(String[] args) &#123;    UsbFactory factory = new UsbFactory();    ProxySeller seller = new ProxySeller(factory);    UsbSell proxy = (UsbSell)seller.getProxy();    UsbSell s = (UsbSell)proxy.sell(50);    s.sell(50);&#125;&#125;</code></pre><p> cglib动态代理：一个开源项目。对于无接口的类，要为其创建动态代理，就要使用 CGLIB 来实现。CGLIB 代理的生成原理是生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象。所以，使用CGLIB 生成动态代理，要求目标类必须能够被继承，即不能是 final 的类。</p><pre><code>     public class Saller &#123;public float sell(int amount)&#123;    float price = 100;    if (amount &gt; 100)&#123;        price = (float) (price * (1 + 0.2));    &#125;else &#123;        price = (float) (price * (1 + 0.5));    &#125;    return price;&#125;&#125;public class ProxySaller implements MethodInterceptor &#123;private Object target;public ProxySaller() &#123;&#125;public ProxySaller(Object target) &#123;    this.target = target;&#125;public Object getProxySaller()&#123;    Enhancer enhancer = new Enhancer();    enhancer.setSuperclass(target.getClass());    enhancer.setCallback(this);    Saller saller = (Saller) enhancer.create();    return saller;&#125;public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;    Float price = (Float) methodProxy.invoke(target,objects);    System.out.println(&quot;===&quot;+price);    return price;&#125;&#125;public class Main &#123;public static void main(String[] args) &#123;    Saller saller = new Saller();    ProxySaller proxySaller = new ProxySaller(saller);    Saller proxy = (Saller) proxySaller.getProxySaller();    proxy.sell(100);&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。说直白一点就是在不修改目标对象的基础上，使用代理对象来增强目标对象的业务逻辑方法。&lt;/p&gt;
&lt;p&gt;代理模式</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="代理模式" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>innoDB中的锁</title>
    <link href="http://example.com/2022/02/10/innoDB%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://example.com/2022/02/10/innoDB%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2022-02-10T05:38:00.000Z</published>
    <updated>2022-02-10T11:19:02.156Z</updated>
    
    <content type="html"><![CDATA[<p>innoDB实现了共享锁（读锁）和排他锁（写锁）两种行级锁。意向共享锁和意向排他锁两种表级别的锁。</p><p> <img src="/images/pasted-97.png" alt="upload successful"></p><p> <img src="/images/pasted-98.png" alt="upload successful"></p><p> <img src="/images/pasted-99.png" alt="upload successful"></p><p> <img src="/images/pasted-100.png" alt="upload successful"></p><p> <img src="/images/pasted-101.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;innoDB实现了共享锁（读锁）和排他锁（写锁）两种行级锁。意向共享锁和意向排他锁两种表级别的锁。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-97.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/im</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>lock与latch</title>
    <link href="http://example.com/2022/02/10/lock%E4%B8%8Elatch/"/>
    <id>http://example.com/2022/02/10/lock%E4%B8%8Elatch/</id>
    <published>2022-02-10T05:36:00.000Z</published>
    <updated>2022-02-10T05:38:14.315Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-96.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-96.png&quot; alt=&quot;upload successful&quot;&gt;
 &lt;/p&gt;
</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL分区</title>
    <link href="http://example.com/2022/02/09/MySQL%E5%88%86%E5%8C%BA/"/>
    <id>http://example.com/2022/02/09/MySQL%E5%88%86%E5%8C%BA/</id>
    <published>2022-02-09T12:14:49.000Z</published>
    <updated>2022-02-09T12:14:49.287Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
