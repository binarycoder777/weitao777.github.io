<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-07T01:55:23.165Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis共享整数字符串</title>
    <link href="http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-02-07T01:55:00.000Z</published>
    <updated>2022-02-07T01:55:23.165Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-47.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-47.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="共享" scheme="http://example.com/tags/%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象内存回收</title>
    <link href="http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</id>
    <published>2022-02-07T01:53:00.000Z</published>
    <updated>2022-02-07T01:53:31.910Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-46.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-46.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="内存回收" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之对象</title>
    <link href="http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-02-07T00:49:00.000Z</published>
    <updated>2022-02-07T01:52:21.525Z</updated>
    
    <content type="html"><![CDATA[<p>Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现。</p><p>在底层上，由一个type类型表明当前数据对象属于哪个类型，由encodeing表明底层具体的数据结构实现，然后由一个指针指向底层的数据结构实现。这样的好处的话主要就是在不同的应用场景选择不同的底层数据结构实现，会大大提高redis的存储性能。</p><p>1、具体的话，String类型底层实现有：int、raw、embstr三种数据结构的实现。其中int类型的底层数据结构实现主要是用于存放整数值，当我们的value是一个整数值，就可以选择用int类型的底层实现。而raw类型的底层实现则是一个动态字符串数据结构，一般当字符串大于32字节就会使用到。embstr则是当字符串小于32字节会使用到。两者的不同在于，embstr只会进行一次内存分配和释放，而raw则会进行两次内存分配和释放；而且embstr的内存时连续的，而raw不是。</p><p>需要注意的是：double这种浮点型的数据作为value存储的时候，底层使用的是str类型的数据结构实现。另外上述三种底层数据结构实现是可以相互转换的。</p><p>2、list类型底层编码可以使ziplist和linkedlist两种类型，当list满足每个节点小于64字节并且节点数小于512个就可以采用ziplist作为底层实现，否则采用linkedlist</p><p>3、hash对象底层编码可以使ziplist和hashtable两种类型<br> <img src="/images/pasted-38.png" alt="upload successful"></p><p> <img src="/images/pasted-39.png" alt="upload successful"></p><p> 4、set集合的编码实现可以使整数集合和hashtable</p><p>  <img src="/images/pasted-40.png" alt="upload successful"></p><p>  5、有序集合zset的编码实现：ziplist和skiplist。</p><p> <img src="/images/pasted-41.png" alt="upload successful"></p><p> <img src="/images/pasted-42.png" alt="upload successful"></p><p> <img src="/images/pasted-43.png" alt="upload successful"></p><p> <img src="/images/pasted-44.png" alt="upload successful"></p><p> <img src="/images/pasted-45.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="对象" scheme="http://example.com/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之整数集合</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</id>
    <published>2022-02-06T13:40:00.000Z</published>
    <updated>2022-02-06T13:49:01.981Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="/images/pasted-37.png" alt="upload successful"></p><p> 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encoding决定保存是int16、32还是64.</p><p> 当将一个新元素加入整数集合时，而且这个元素类型长于当前集合类型，就会先对集合升级，然后在加入新元素。</p><p> 升级：</p><p> 1、根据新元素类型，开辟新的数组</p><p> 2、将原数组的元素转移到新数组的正确位置上，且转化为与新数组相同的类型</p><p> 3、将新元素加到新数组指定的位置</p><p> 好处：</p><p> 1、提升灵活性，C语言是静态类型语言，为了避免错误，不会将两种类型放在一个数据结构里面，通过底层数组升级操作，不必担心不同类型的整数出现类型错误</p><p> 2、节约内存，整数集合的升级操作，确保了只在需要的时候进行，尽量节约内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;img src=&quot;/images/pasted-37.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encodi</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="整数集合" scheme="http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之跳表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/</id>
    <published>2022-02-06T13:13:00.000Z</published>
    <updated>2022-02-06T13:24:50.758Z</updated>
    
    <content type="html"><![CDATA[<p>跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p> <img src="/images/pasted-33.png" alt="upload successful"></p><p> <img src="/images/pasted-34.png" alt="upload successful"></p><p> <img src="/images/pasted-35.png" alt="upload successful"></p><p> <img src="/images/pasted-36.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-33.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/imag</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="跳表" scheme="http://example.com/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之字典</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/</id>
    <published>2022-02-06T12:37:00.000Z</published>
    <updated>2022-02-06T13:24:45.912Z</updated>
    
    <content type="html"><![CDATA[<p>字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。</p><p>1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下标上的链表进行比较（没有链表则直接加上去），看是否是同一个值，如果是，则覆盖，不是则加到链表尾。</p><p>2、字典则是一个包含两个hash表的结构体，一般情况只使用下标为0的hash表，当对0下标的hash表进行扩容时，会使用到1下标处的hash表。即当0下标处的hash表</p><p>a）满足服务器没有执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于1</p><p>b）或者满足服务器执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于5</p><p>（因为在执bgsave或者bgrewriteaof命令时，服务器在执行备份操作，为了尽可能提高其效率，避免在此期间进行hash表扩容操作）</p><p>c）负载因子小于0.1会收缩</p><p>就会发生扩容，此时会渐进的将0下标的hash表的数据转移到扩容后的1下标处。（这里之所以采取渐进式的转移，主要是考虑到当hash表里面存的数据量很大时，一次性转移会很消耗时间）</p><p> <img src="/images/pasted-30.png" alt="upload successful"></p><p> <img src="/images/pasted-31.png" alt="upload successful"></p><p> <img src="/images/pasted-29.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。&lt;/p&gt;
&lt;p&gt;1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之链表</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</id>
    <published>2022-02-06T12:28:00.000Z</published>
    <updated>2022-02-06T12:35:31.761Z</updated>
    
    <content type="html"><![CDATA[<p>链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释放函数等。即最终是一个双端无环链表。</p><p> <img src="/images/pasted-25.png" alt="upload successful"></p><p> <img src="/images/pasted-26.png" alt="upload successful"></p><p> <img src="/images/pasted-24.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构之SDS</title>
    <link href="http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/"/>
    <id>http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/</id>
    <published>2022-02-06T12:13:00.000Z</published>
    <updated>2022-02-06T12:36:06.134Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：</p><p>1、可以通过len-free以常数阶获取字符串长度</p><p>2、可以通过free字段避免缓冲区出现溢出的情况</p><p>3、同时也减少字符串修改时，内存重新分配的次数，其具体实现是通过预先分配内存（即当追加字符串之后，字符串小于1MB，会多分配一倍的空间）和懒惰回收（即当字符串变短之后，不会立即回收那一部分空间，而是作为临时空间供后续字符串扩增做优化）</p><p>4、可以保存二进制安全的数据</p><p> <img src="/images/pasted-27.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点：&lt;/p&gt;
&lt;p&gt;1</summary>
      
    
    
    
    <category term="Redis" scheme="http://example.com/categories/Redis/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>枚举单例模式如何防止反射和反序列化</title>
    <link href="http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-01-27T11:08:00.000Z</published>
    <updated>2022-01-27T11:16:11.794Z</updated>
    
    <content type="html"><![CDATA[<p>1、</p><p>2、枚举单例在创建时不存在并发问题：</p><pre><code>枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的</code></pre><p>2、反序列化：</p><pre><code>Java对枚举的序列化作了规定，在序列化时，仅将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象。枚举在序列化和反序列化时，并不会调用构造方法，这就防止了反序列化导致的单例破坏的问题。</code></pre><p>3、反射：</p><pre><code>反射在通过newInstance创建对象时，会检查这个类是否是枚举类，如果是，会抛出异常java.lang.IllegalArgumentException: Cannot reflectively create enum objects，表示反射创建对象失败。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、&lt;/p&gt;
&lt;p&gt;2、枚举单例在创建时不存在并发问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的
&lt;/c</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单利模式防止反射创建新的实例</title>
    <link href="http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/</id>
    <published>2022-01-27T09:47:00.000Z</published>
    <updated>2022-01-27T09:49:12.324Z</updated>
    
    <content type="html"><![CDATA[<p>方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类</p><p>方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类&lt;/p&gt;
&lt;p&gt;方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="单例模式" scheme="http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如果实现了序列化接口, 还要做什么来防止反序列化破坏单例</title>
    <link href="http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/"/>
    <id>http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/</id>
    <published>2022-01-27T09:40:00.000Z</published>
    <updated>2022-01-27T09:47:09.071Z</updated>
    
    <content type="html"><![CDATA[<p>在类中添加如下方法<br> <img src="/images/pasted-23.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在类中添加如下方法&lt;br&gt; &lt;img src=&quot;/images/pasted-23.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis开发运维实践指南笔记</title>
    <link href="http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-26T14:10:01.000Z</published>
    <updated>2022-01-26T14:25:32.547Z</updated>
    
    <content type="html"><![CDATA[<p>1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。</p><p>2、<img src="/images/pasted-17.png" alt="upload successful"></p><p> 3、列出key：</p><p> <img src="/images/pasted-18.png" alt="upload successful"></p><p> 渐进的遍历整个数据库：keys命令会一次性遍历整个数据库获取与之匹配的键，当数据库包含得键值越来越多，这个命令会愈来愈慢，因此，可以用scan命令渐进的，分多次遍历整个数据库</p><p> <img src="/images/pasted-19.png" alt="upload successful"></p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>4、<br> <img src="/images/pasted-21.png" alt="upload successful"></p><p>5、</p><p> <img src="/images/pasted-22.png" alt="upload successful"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。&lt;/p&gt;
&lt;p&gt;2、&lt;img src=&quot;/images/pasted-17.png&quot; alt=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>交替打印输出</title>
    <link href="http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/</id>
    <published>2022-01-26T12:59:00.000Z</published>
    <updated>2022-01-26T13:00:45.447Z</updated>
    
    <content type="html"><![CDATA[<p> 三个线程交替打印输出</p><pre><code>public class AlternateOutput &#123;    public static void main(String[] args) &#123;//        Test1 test1 = new Test1();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(1);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(2);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        new Thread(()-&gt;&#123;//            try &#123;//                test1.print(3);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;).start();//        Test2 test2 = new Test2();//        Thread t1 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;a&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        Thread t2 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;b&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        Thread t3 = new Thread(()-&gt;&#123;//            try &#123;//                test2.print(&quot;c&quot;);//            &#125; catch (InterruptedException e) &#123;//                e.printStackTrace();//            &#125;//        &#125;);//        test2.setThreads(t1,t2,t3);//        test2.start();        Test3 test3 = new Test3();        Condition condition1 = test3.newCondition();        Condition condition2 = test3.newCondition();        Condition condition3 = test3.newCondition();        new Thread(()-&gt;&#123;            test3.print(&quot;a&quot;,condition1,condition2);        &#125;).start();        new Thread(()-&gt;&#123;            test3.print(&quot;b&quot;,condition2,condition3);        &#125;).start();        new Thread(()-&gt;&#123;            test3.print(&quot;c&quot;,condition3,condition1);        &#125;).start();        test3.start(condition1);    &#125;&#125;class Test1&#123;    private Integer flag = 1;    private Integer num = 10;    public void print(int curFlag) throws InterruptedException &#123;        for (int i=0; i&lt;num; ++i)&#123;            synchronized (this)&#123;                while (this.flag != curFlag)&#123;                    this.wait();                &#125;                System.out.println(curFlag);                this.flag = curFlag % 3 + 1;                this.notifyAll();            &#125;        &#125;    &#125;&#125;class Test2&#123;    private Thread[] threads;    private Integer num = 10;    public Test2(Thread... threads) &#123;        this.threads = threads;    &#125;    public void setThreads(Thread... threads) &#123;        this.threads = threads;    &#125;    public void print(String s) throws InterruptedException &#123;       for (int i=0;i&lt;num;++i)&#123;           LockSupport.park();           System.out.println(s);           LockSupport.unpark(getNextThread());       &#125;    &#125;    public Thread getNextThread()&#123;        int size = threads.length;        Thread cur = Thread.currentThread();        for (int i=0;i&lt;size;++i)&#123;            if (cur == threads[i])&#123;                return threads[(i + 1) % size];            &#125;        &#125;        return null;    &#125;    public void start() &#123;        for (Thread thread: threads)&#123;            thread.start();        &#125;        LockSupport.unpark(threads[0]);    &#125;&#125;class Test3 extends ReentrantLock&#123;    private int num = 10;    public void start(Condition condition)&#123;        this.lock();        try &#123;            condition.signal();        &#125;finally &#123;            this.unlock();        &#125;    &#125;    public void print(String s, Condition cur,Condition next)&#123;        for (int i=0;i&lt;num;++i)&#123;            this.lock();            try&#123;                cur.await();                System.out.println(s);                next.signal();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                this.unlock();            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 三个线程交替打印输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class AlternateOutput &amp;#123;

    public static void main(String[] args) &amp;#123;
//        Test1 test1 =</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized锁静态变量Integer</title>
    <link href="http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/"/>
    <id>http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/</id>
    <published>2022-01-25T02:18:00.000Z</published>
    <updated>2022-01-25T02:22:28.673Z</updated>
    
    <content type="html"><![CDATA[<p>当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128~127之间是有效的，因为存在Integer缓存问题）。</p><pre><code>public class Main &#123;    private static Integer i = 0;    public static void main(String[] args) throws InterruptedException &#123;        List&lt;Thread&gt; list = new ArrayList&lt;&gt;();        for (int j = 0; j &lt; 2; j++) &#123;            Thread thread = new Thread(() -&gt; &#123;                for (int k = 0; k &lt; 127; k++) &#123;                    synchronized (i) &#123;                        i++;                    &#125;                &#125;            &#125;, &quot;&quot; + j);            list.add(thread);        &#125;        list.stream().forEach(t -&gt; t.start());        list.stream().forEach(t -&gt; &#123;            try &#123;                t.join();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        System.out.println(i);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="synchronized" scheme="http://example.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>终止模式之两阶段终止模式（Interrupt）</title>
    <link href="http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-24T11:10:00.000Z</published>
    <updated>2022-01-24T11:20:45.418Z</updated>
    
    <content type="html"><![CDATA[<p>Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。<br>（如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛InterruptedException，并清除 打断标记如果打断的正在运行的线程，则会设置打断标记 ；park的线程被打断，也会设置 打断标记）</p><p> <img src="/images/pasted-16.png" alt="upload successful"></p><pre><code> public class TPTInterrupt &#123;public static void main(String[] args) throws InterruptedException &#123;    TPTInterrupt tptInterrupt = new TPTInterrupt();    tptInterrupt.start();    Thread.sleep(2000);    tptInterrupt.stop();&#125;private Thread thread;public void start()&#123;    thread = new Thread(()-&gt;&#123;        while (true)&#123;            Thread thread = Thread.currentThread();            if (thread.isInterrupted())&#123;                System.out.println(&quot;料理后事...&quot;);                break;            &#125;            try &#123;                Thread.sleep(1000);                System.out.println(&quot;运行中...&quot;);            &#125; catch (InterruptedException e) &#123;                // 标记打断                e.printStackTrace();                thread.interrupt();            &#125;        &#125;    &#125;);    thread.start();&#125;public void stop()&#123;    thread.interrupt();&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。&lt;br&gt;（如果被打断线程正在 sleep，wait，join 会导致</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/juc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="终止模式" scheme="http://example.com/tags/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>创建线程的方式</title>
    <link href="http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2022-01-24T11:02:00.000Z</published>
    <updated>2022-01-24T11:06:46.136Z</updated>
    
    <content type="html"><![CDATA[<p>1、创建Thread对象</p><p> <img src="/images/pasted-13.png" alt="upload successful"></p><p> 2、使用Runnable配合Thread使用</p><p> <img src="/images/pasted-14.png" alt="upload successful"></p><p> 3、FutureTask配合Callable和Thread使用</p><p> <img src="/images/pasted-15.png" alt="upload successful"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、创建Thread对象&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/pasted-13.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;p&gt; 2、使用Runnable配合Thread使用&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/p</summary>
      
    
    
    
    
    <category term="创建线程" scheme="http://example.com/tags/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为什么要自定义类型加载器？</title>
    <link href="http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/"/>
    <id>http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/</id>
    <published>2022-01-23T11:19:00.000Z</published>
    <updated>2022-01-23T11:20:52.309Z</updated>
    
    <content type="html"><![CDATA[<p>1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。(类的仲裁 –&gt; 类冲突)</p><p>2、修改类加载的方式：类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载</p><p>3、扩展加载源：比如从数据库、网络、甚至是电视机机顶盒进行加载</p><p>4、防止源码泄露：Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
  </entry>
  
  <entry>
    <title>沙箱安全机制</title>
    <link href="http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2022-01-23T11:16:00.000Z</published>
    <updated>2022-01-23T11:19:08.964Z</updated>
    
    <content type="html"><![CDATA[<p>沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
  </entry>
  
  <entry>
    <title>判定一个类型是否属于&quot;不再被使用的类&quot;的条件</title>
    <link href="http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/"/>
    <id>http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/</id>
    <published>2022-01-23T09:49:00.000Z</published>
    <updated>2022-01-23T09:50:58.551Z</updated>
    
    <content type="html"><![CDATA[<p>1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象</p><p>2、加载该类的类加载器被回收</p><p>3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象&lt;/p&gt;
&lt;p&gt;2、加载该类的类加载器被回收&lt;/p&gt;
&lt;p&gt;3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法&lt;/p&gt;
</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    <category term="jvm" scheme="http://example.com/categories/jv-m/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>类的初始化情况：主动使用vs被动使用</title>
    <link href="http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-23T09:31:00.000Z</published>
    <updated>2022-01-23T09:43:56.451Z</updated>
    
    <content type="html"><![CDATA[<p>主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。</p><p>以下使用被认为是主动使用：<br>1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化</p><p>2、当调用类的静态方法时，即当使用了字节码 invokestatic 指令</p><p>3、当使用类、接口的静态字段时(final 修饰特殊考虑)，比如，使用 getstatic 或者 putsttic 指令。(对应访问变量、赋值变量操作)</p><p>4、当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”)</p><p>5、当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</p><p>6、如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化</p><p>7、当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类</p><p>8、当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。(涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类)</p><p>注意：<br>1、当Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口在初始化一个类时，并不会先初始化它所实现的接口<br>在初始化一个接口时，并不会先初始化它的父接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化<br>2、JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[]) 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化</p><p>被动使用：除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p><p>1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化</p><p>2、当通过子类引用父类的静态变量，不会导致子类初始化</p><p>3、通过数组定义类引用，不会触发此类的初始化</p><p>4、引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</p><p>5、调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。&lt;/p&gt;
&lt;p&gt;以下使用被认为是主动使用：&lt;br&gt;1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化&lt;/p&gt;
&lt;p&gt;2、当调用类的静态方法时，即当使用了字节码 i</summary>
      
    
    
    
    <category term="jv&#39;m" scheme="http://example.com/categories/jv-m/"/>
    
    
    <category term="类初始化：主动使用与被动使用" scheme="http://example.com/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
