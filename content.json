{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-01-05T06:15:01.841Z","updated":"2022-01-05T06:10:01.885Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-01-05T08:23:28.052Z","updated":"2022-01-05T06:10:01.886Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-01-05T08:23:46.960Z","updated":"2022-01-05T06:10:01.887Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-01-05T08:55:42.212Z","updated":"2022-01-05T08:55:42.201Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-01-05T06:15:01.947Z","updated":"2022-01-05T06:10:01.888Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-01-05T08:22:49.166Z","updated":"2022-01-05T06:10:01.888Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-05T08:24:21.310Z","updated":"2022-01-05T06:10:01.888Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"枚举单例模式如何防止反射和反序列化","slug":"枚举单例模式如何防止反射和反序列化","date":"2022-01-27T11:08:00.000Z","updated":"2022-01-27T11:16:11.794Z","comments":true,"path":"2022/01/27/枚举单例模式如何防止反射和反序列化/","link":"","permalink":"http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"1、 2、枚举单例在创建时不存在并发问题： 枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的 2、反序列化： Java对枚举的序列化作了规定，在序列化时，仅将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象。枚举在序列化和反序列化时，并不会调用构造方法，这就防止了反序列化导致的单例破坏的问题。 3、反射： 反射在通过newInstance创建对象时，会检查这个类是否是枚举类，如果是，会抛出异常java.lang.IllegalArgumentException: Cannot reflectively create enum objects，表示反射创建对象失败。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"单利模式防止反射创建新的实例","slug":"单利模式防止反射创建新的实例","date":"2022-01-27T09:47:00.000Z","updated":"2022-01-27T09:49:12.324Z","comments":true,"path":"2022/01/27/单利模式防止反射创建新的实例/","link":"","permalink":"http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类 方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作","categories":[],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"如果实现了序列化接口, 还要做什么来防止反序列化破坏单例","slug":"：如果实现了序列化接口-还要做什么来防止反序列化破坏单例","date":"2022-01-27T09:40:00.000Z","updated":"2022-01-27T09:47:09.071Z","comments":true,"path":"2022/01/27/：如果实现了序列化接口-还要做什么来防止反序列化破坏单例/","link":"","permalink":"http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/","excerpt":"","text":"在类中添加如下方法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"John Doe"},{"title":"Redis开发运维实践指南笔记","slug":"Redis开发运维实践指南笔记","date":"2022-01-26T14:10:01.000Z","updated":"2022-01-26T14:25:32.547Z","comments":true,"path":"2022/01/26/Redis开发运维实践指南笔记/","link":"","permalink":"http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。 2、 3、列出key： 渐进的遍历整个数据库：keys命令会一次性遍历整个数据库获取与之匹配的键，当数据库包含得键值越来越多，这个命令会愈来愈慢，因此，可以用scan命令渐进的，分多次遍历整个数据库 4、 5、","categories":[],"tags":[],"author":"John Doe"},{"title":"交替打印输出","slug":"交替打印输出","date":"2022-01-26T12:59:00.000Z","updated":"2022-01-26T13:00:45.447Z","comments":true,"path":"2022/01/26/交替打印输出/","link":"","permalink":"http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/","excerpt":"","text":"三个线程交替打印输出 public class AlternateOutput &#123; public static void main(String[] args) &#123; // Test1 test1 = new Test1(); // new Thread(()-&gt;&#123; // try &#123; // test1.print(1); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;).start(); // new Thread(()-&gt;&#123; // try &#123; // test1.print(2); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;).start(); // new Thread(()-&gt;&#123; // try &#123; // test1.print(3); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;).start(); // Test2 test2 = new Test2(); // Thread t1 = new Thread(()-&gt;&#123; // try &#123; // test2.print(&quot;a&quot;); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;); // Thread t2 = new Thread(()-&gt;&#123; // try &#123; // test2.print(&quot;b&quot;); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;); // Thread t3 = new Thread(()-&gt;&#123; // try &#123; // test2.print(&quot;c&quot;); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;); // test2.setThreads(t1,t2,t3); // test2.start(); Test3 test3 = new Test3(); Condition condition1 = test3.newCondition(); Condition condition2 = test3.newCondition(); Condition condition3 = test3.newCondition(); new Thread(()-&gt;&#123; test3.print(&quot;a&quot;,condition1,condition2); &#125;).start(); new Thread(()-&gt;&#123; test3.print(&quot;b&quot;,condition2,condition3); &#125;).start(); new Thread(()-&gt;&#123; test3.print(&quot;c&quot;,condition3,condition1); &#125;).start(); test3.start(condition1); &#125; &#125; class Test1&#123; private Integer flag = 1; private Integer num = 10; public void print(int curFlag) throws InterruptedException &#123; for (int i=0; i&lt;num; ++i)&#123; synchronized (this)&#123; while (this.flag != curFlag)&#123; this.wait(); &#125; System.out.println(curFlag); this.flag = curFlag % 3 + 1; this.notifyAll(); &#125; &#125; &#125; &#125; class Test2&#123; private Thread[] threads; private Integer num = 10; public Test2(Thread... threads) &#123; this.threads = threads; &#125; public void setThreads(Thread... threads) &#123; this.threads = threads; &#125; public void print(String s) throws InterruptedException &#123; for (int i=0;i&lt;num;++i)&#123; LockSupport.park(); System.out.println(s); LockSupport.unpark(getNextThread()); &#125; &#125; public Thread getNextThread()&#123; int size = threads.length; Thread cur = Thread.currentThread(); for (int i=0;i&lt;size;++i)&#123; if (cur == threads[i])&#123; return threads[(i + 1) % size]; &#125; &#125; return null; &#125; public void start() &#123; for (Thread thread: threads)&#123; thread.start(); &#125; LockSupport.unpark(threads[0]); &#125; &#125; class Test3 extends ReentrantLock&#123; private int num = 10; public void start(Condition condition)&#123; this.lock(); try &#123; condition.signal(); &#125;finally &#123; this.unlock(); &#125; &#125; public void print(String s, Condition cur,Condition next)&#123; for (int i=0;i&lt;num;++i)&#123; this.lock(); try&#123; cur.await(); System.out.println(s); next.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; this.unlock(); &#125; &#125; &#125; &#125;","categories":[],"tags":[],"author":"John Doe"},{"title":"synchronized锁静态变量Integer","slug":"synchronized锁静态变量Integer","date":"2022-01-25T02:18:00.000Z","updated":"2022-01-25T02:22:28.673Z","comments":true,"path":"2022/01/25/synchronized锁静态变量Integer/","link":"","permalink":"http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/","excerpt":"","text":"当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128~127之间是有效的，因为存在Integer缓存问题）。 public class Main &#123; private static Integer i = 0; public static void main(String[] args) throws InterruptedException &#123; List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 2; j++) &#123; Thread thread = new Thread(() -&gt; &#123; for (int k = 0; k &lt; 127; k++) &#123; synchronized (i) &#123; i++; &#125; &#125; &#125;, &quot;&quot; + j); list.add(thread); &#125; list.stream().forEach(t -&gt; t.start()); list.stream().forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(i); &#125; &#125;","categories":[{"name":"juc","slug":"juc","permalink":"http://example.com/categories/juc/"}],"tags":[{"name":"synchronized","slug":"synchronized","permalink":"http://example.com/tags/synchronized/"}],"author":"John Doe"},{"title":"终止模式之两阶段终止模式（Interrupt）","slug":"终止模式之两阶段终止模式","date":"2022-01-24T11:10:00.000Z","updated":"2022-01-24T11:20:45.418Z","comments":true,"path":"2022/01/24/终止模式之两阶段终止模式/","link":"","permalink":"http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。（如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛InterruptedException，并清除 打断标记如果打断的正在运行的线程，则会设置打断标记 ；park的线程被打断，也会设置 打断标记） public class TPTInterrupt &#123; public static void main(String[] args) throws InterruptedException &#123; TPTInterrupt tptInterrupt = new TPTInterrupt(); tptInterrupt.start(); Thread.sleep(2000); tptInterrupt.stop(); &#125; private Thread thread; public void start()&#123; thread = new Thread(()-&gt;&#123; while (true)&#123; Thread thread = Thread.currentThread(); if (thread.isInterrupted())&#123; System.out.println(&quot;料理后事...&quot;); break; &#125; try &#123; Thread.sleep(1000); System.out.println(&quot;运行中...&quot;); &#125; catch (InterruptedException e) &#123; // 标记打断 e.printStackTrace(); thread.interrupt(); &#125; &#125; &#125;); thread.start(); &#125; public void stop()&#123; thread.interrupt(); &#125; &#125;","categories":[{"name":"juc","slug":"juc","permalink":"http://example.com/categories/juc/"},{"name":"设计模式","slug":"juc/设计模式","permalink":"http://example.com/categories/juc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"终止模式","slug":"终止模式","permalink":"http://example.com/tags/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"创建线程的方式","slug":"创建线程的方式","date":"2022-01-24T11:02:00.000Z","updated":"2022-01-24T11:06:46.136Z","comments":true,"path":"2022/01/24/创建线程的方式/","link":"","permalink":"http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1、创建Thread对象 2、使用Runnable配合Thread使用 3、FutureTask配合Callable和Thread使用","categories":[],"tags":[{"name":"创建线程","slug":"创建线程","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"}],"author":"John Doe"},{"title":"为什么要自定义类型加载器？","slug":"为什么要自定义类型加载器？","date":"2022-01-23T11:19:00.000Z","updated":"2022-01-23T11:20:52.309Z","comments":true,"path":"2022/01/23/为什么要自定义类型加载器？/","link":"","permalink":"http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/","excerpt":"","text":"1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。(类的仲裁 –&gt; 类冲突) 2、修改类加载的方式：类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载 3、扩展加载源：比如从数据库、网络、甚至是电视机机顶盒进行加载 4、防止源码泄露：Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[],"author":"John Doe"},{"title":"沙箱安全机制","slug":"沙箱安全机制","date":"2022-01-23T11:16:00.000Z","updated":"2022-01-23T11:19:08.964Z","comments":true,"path":"2022/01/23/沙箱安全机制/","link":"","permalink":"http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","excerpt":"","text":"沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[],"author":"John Doe"},{"title":"判定一个类型是否属于\"不再被使用的类\"的条件","slug":"判定一个类型是否属于-不再被使用的类-的条件","date":"2022-01-23T09:49:00.000Z","updated":"2022-01-23T09:50:58.551Z","comments":true,"path":"2022/01/23/判定一个类型是否属于-不再被使用的类-的条件/","link":"","permalink":"http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/","excerpt":"","text":"1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象 2、加载该类的类加载器被回收 3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"},{"name":"jvm","slug":"jv-m/jvm","permalink":"http://example.com/categories/jv-m/jvm/"}],"tags":[],"author":"John Doe"},{"title":"类的初始化情况：主动使用vs被动使用","slug":"类的初始化情况：主动使用vs被动使用","date":"2022-01-23T09:31:00.000Z","updated":"2022-01-23T09:43:56.451Z","comments":true,"path":"2022/01/23/类的初始化情况：主动使用vs被动使用/","link":"","permalink":"http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/","excerpt":"","text":"主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。 以下使用被认为是主动使用：1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化 2、当调用类的静态方法时，即当使用了字节码 invokestatic 指令 3、当使用类、接口的静态字段时(final 修饰特殊考虑)，比如，使用 getstatic 或者 putsttic 指令。(对应访问变量、赋值变量操作) 4、当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”) 5、当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 6、如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化 7、当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类 8、当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。(涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类) 注意：1、当Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口在初始化一个类时，并不会先初始化它所实现的接口在初始化一个接口时，并不会先初始化它的父接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化2、JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[]) 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化 被动使用：除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。 1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化 2、当通过子类引用父类的静态变量，不会导致子类初始化 3、通过数组定义类引用，不会触发此类的初始化 4、引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了 5、调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[{"name":"类初始化：主动使用与被动使用","slug":"类初始化：主动使用与被动使用","permalink":"http://example.com/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"}],"author":"John Doe"},{"title":"类的加载过程","slug":"类的加载过程","date":"2022-01-23T07:55:00.000Z","updated":"2022-01-23T08:54:30.085Z","comments":true,"path":"2022/01/23/类的加载过程/","link":"","permalink":"http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类的加载，我的理解就是将类的二进制字节码文件加载到内存中，并通过解析字节码中的常量池、类字段、类方法等信息，在jvm方法区中构建出该类的模板，并在堆区创建一个对象实例作为方法区这个类的各种数据访问入口，在jvm运行期间能够通过这个类的模板信息来调用类的静态变量、方法等。其加载过程的话，主要分为加载、链接（验证、准备、解析）、初始化三个步骤。 1、首先加载，就是查找类的全限定类名，将类的二进制字节码文件加载到jvm的内存中，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，并为之在堆区创建一个实例对象，作为方法区这个类的数据访问入口。当然，在加载前还需要进行验证操作，即检查字节码文件格式，看是否遵循jvm的规范。比如是否以魔数开头等。验证通过后，该类的二进制信息便会被加载到内存。 2、加载到方法区后需要验证，即检查类的语义、字节码验证、符号引用验证，看是否符合规范。 3、当验证完毕之后，就开始准备阶段，这一步主要是对类的静态变量分配内存并附上默认值。（注意：final修饰的静态变量在编译阶段就会分配，准备阶段是显示赋值，并且此阶段也不会为实例变量分配初始化） 4、然后便是解析阶段，即将符号引用转变为直接引用，得到类、字段、方法等在内存中的指针或者偏移量。 5、最后便是初始化，这个阶段主要是为类的静态变量进行显示赋值。即执行类构造器cinit方法。即执行类变量的赋值动作和静态语句块(static{}块)，虚期机会保证在子类的()方法执行之前, 父类的()方法已经执行完毕。如果一个类中没有静态语句块,也没有对变量的赋值操作, 那么编译器可以不为这个类生成()方法。 需要注意的是：接口与类不同的是, 执行接口的()方法不需要先执行父接口的()方法。只有当父接口中定义的变量被使用时, 父接口才会被初始化。 另外, 接口的实现类在初始化时也一样不会执行接口的()方法。另外，虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()法,其他线程部需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作, 那就可能造成多个进程阻塞, 在实际应用中这种阻塞往往是隐蔽的。","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[{"name":"类的加载过程","slug":"类的加载过程","permalink":"http://example.com/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"}],"author":"John Doe"},{"title":"关于集合类中的modCount++","slug":"关于集合类中的modCount","date":"2022-01-21T06:45:00.000Z","updated":"2022-01-21T07:17:15.741Z","comments":true,"path":"2022/01/21/关于集合类中的modCount/","link":"","permalink":"http://example.com/2022/01/21/%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%E7%9A%84modCount/","excerpt":"","text":"话不多说，直接看源码注释讲解 由上图可知，该字段目的在于记录集合结构被修改的次数（增、删、改），该字段被迭代器所使用，当对集合进行迭代遍历时，防止数据发生改变引起错误。因此，当我们使用迭代器时，如果该值被改了，就会触发fast-fail机制，抛出异常ConcurrentModificationExceptions。","categories":[{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"},{"name":"java","slug":"集合/java","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/java/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://example.com/tags/ArrayList/"}],"author":"John Doe"},{"title":"HashMap1.7","slug":"HashMap","date":"2022-01-18T11:27:00.000Z","updated":"2022-01-18T11:53:34.793Z","comments":true,"path":"2022/01/18/HashMap/","link":"","permalink":"http://example.com/2022/01/18/HashMap/","excerpt":"","text":"HashMap1.7底层由数组+链表实现，提供的无参构造方法默认数组容量是16，加载因子是0.75，临界值为16 * 0.75 = 12，当到了临界值则进行扩容。 你也可以通过有参构造方法指定容量和加载因子。 注意，不管有参无参此时都还未初始化数组，只是定义了数组容量。当我们第一次put往hashmap的放数据的时候才会初始化 而此时初始化会根据我们最初的容量大小进行初始化，大小为大于等于当前容量的2的幂。 然后便是计算hash值，根据hash值得到数组下标，根据下标到指定位置，如果发送hash冲突则通过拉链法，将冲突元素头插进链表","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"}],"author":"John Doe"},{"title":"ArrayList","slug":"ArrayList","date":"2022-01-17T12:13:00.000Z","updated":"2022-01-17T12:20:04.535Z","comments":true,"path":"2022/01/17/ArrayList/","link":"","permalink":"http://example.com/2022/01/17/ArrayList/","excerpt":"","text":"ArrayList 1、ArrayList底层默认是用object数组实现的，因此在增删元素上需要移动元素，效率较低，但支持随机访问元素 2、ArrayList是线层不安全的，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常或错误。 3、ArrayList的默认的大小是10。一开始是空数组，当第一次add的时候才会扩容到10，后续容器满了之后会按1.5倍进行扩容。如果一开始指定容器大小，后续则直接按1.5倍进行扩容。最大扩容不超过Integer.MAX_VALUE","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"}],"author":"John Doe"},{"title":"成员变量与局部变量","slug":"成员变量与局部变量","date":"2022-01-16T11:20:00.000Z","updated":"2022-01-16T11:22:59.161Z","comments":true,"path":"2022/01/16/成员变量与局部变量/","link":"","permalink":"http://example.com/2022/01/16/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/","excerpt":"","text":"从语法形式上看:成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。2. 从变量在内存中的存储⽅式来看:如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。3. 从变量在内存中的⽣存时间上看:成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。4. 成员变量如果没有被赋初值:则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[],"author":"John Doe"},{"title":"接口和抽象类的区别","slug":"接口和抽象类的区别","date":"2022-01-16T10:39:00.000Z","updated":"2022-01-16T11:17:43.700Z","comments":true,"path":"2022/01/16/接口和抽象类的区别/","link":"","permalink":"http://example.com/2022/01/16/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"接⼝的⽅法默认是 public ，所有⽅法在接⼝中不能有实现(Java 8 开始接⼝⽅法可以有默认实现），⽽抽象类可以有⾮抽象的⽅法。 接⼝中除了 static 、 final 变量，不能有其他变量，⽽抽象类中则不⼀定。 ⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 extends 关键字扩展多个接⼝。 接⼝⽅法默认修饰符是 public ，抽象⽅法可以有 public 、 protected 和 default 这些修饰符（抽象⽅法就是为了被重写所以不能使⽤ private 关键字修饰！）。 从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的规范。备注： 在 JDK8 中，接⼝也可以定义静态⽅法，可以直接⽤接⼝名调⽤。实现类和实现是不可以调⽤的。如果同时实现两个接⼝，接⼝中定义了⼀样的默认⽅法，则必须重写，不然会报错。 jdk9 的接⼝被允许定义私有⽅法 。总结⼀下 jdk7~jdk9 Java 中接⼝概念的变化： 在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实现接⼝的类实现。 jdk 8 的时候接⼝可以有默认⽅法和静态⽅法功能。 Jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"接口","slug":"接口","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3/"}],"author":"John Doe"},{"title":"在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤","slug":"在-Java-中定义⼀个不做事且没有参数的构造⽅法的作⽤","date":"2022-01-16T10:34:00.000Z","updated":"2022-01-16T10:34:43.521Z","comments":true,"path":"2022/01/16/在-Java-中定义⼀个不做事且没有参数的构造⽅法的作⽤/","link":"","permalink":"http://example.com/2022/01/16/%E5%9C%A8-Java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E2%BC%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E7%9A%84%E4%BD%9C%E2%BD%A4/","excerpt":"","text":"Java 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ super() 来调⽤⽗类特定的构造⽅法，则会调⽤⽗类中“没有参数的构造⽅法”。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构造⽅法中⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程序在⽗类中找不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参数的构造⽅法。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[],"author":"John Doe"},{"title":"重载和重写的区别","slug":"重载和重写的区别","date":"2022-01-16T10:05:00.000Z","updated":"2022-01-16T10:25:19.715Z","comments":true,"path":"2022/01/16/重载和重写的区别/","link":"","permalink":"http://example.com/2022/01/16/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"重载：在一个java类中，有多个方法同名，签名不同（即不同的参数数量、顺序以及类型）的函数，就发生了重载。 重写：子类继承了父类然后重写了父类中的方法（保持和父类方法的返回值类型、函数名、签名等都不变，只是在函数体中的代码实现逻辑改变了） 注意：重写时，子类抛出的异常范围应小于等于父类，访问修饰变量范围应大于等于父类。如果父类方法被final、static、private修饰则子类不能重写父类方法，但被static修饰的方法可以再次声明。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"重写","slug":"重写","permalink":"http://example.com/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"http://example.com/tags/%E9%87%8D%E8%BD%BD/"}],"author":"ATAO"},{"title":"Java中的基本数据类型","slug":"Java中的基本数据类型","date":"2022-01-15T10:31:00.000Z","updated":"2022-01-15T10:35:39.104Z","comments":true,"path":"2022/01/15/Java中的基本数据类型/","link":"","permalink":"http://example.com/2022/01/15/Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"java中的基本数据类型有byte（1字节）、short（2字节）、int（四字节）、long（8字节）、float（4字节）、double（8字节）、boolean（1位）、char（2字节）","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"ATAO"},{"title":"final、finalize()、finally","slug":"final、finalize-、finally","date":"2022-01-11T01:48:00.000Z","updated":"2022-01-11T02:27:34.968Z","comments":true,"path":"2022/01/11/final、finalize-、finally/","link":"","permalink":"http://example.com/2022/01/11/final%E3%80%81finalize-%E3%80%81finally/","excerpt":"","text":"1、final：在java中，final主要用于修饰类、方法和变量。 1.1 修饰类：用final修饰类时，表明这个类不能被其他类所继承。 注意：当用final对类进行修饰的时候，类中所有成员方法默认是final方法。 1.2 修饰方法：用fianl修饰方法时，表明这个方法不能被其子类重写。 1.3 修饰变量：用final修饰变量的话表明这个变量是一个常量，只能被赋值一次，赋值后其值不能够修改。 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化（）；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。 final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。 扩展：在java中，String被设计成final类，那为什么平时使用时，String的值可以被改变呢？ 字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。当我们对String对象值改变的时候，例如 String a=&quot;A&quot;; a=&quot;B&quot; 。a是String对象的一个引用（我们这里所说的String对象其实是指字符串常量），当a=“B”执行时，并不是原本String对象(&quot;A&quot;)发生改变，而是创建一个新的对象(&quot;B&quot;)，令a引用它。 2、finally：finally作为异常处理的一部分，它用在try/catch语句中，经常被用在需要释放资源的情况下。 注意： 1、只有与finally对应的try语句块得到执行的情况下，finally语句块才会执行。 2、在 try 语句块中执行了 System.exit (0) 语句，终止了 Java 虚拟机的运行或者在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed）等情况finally也可能不会执行。 易错点： 答案：4 4 4 原因：finally语句在return之前执行。 3、finalize：finalize()是在java.lang.Object里定义的，每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。 注意：一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。 所以，推荐不要使用finalize()方法，它跟析构函数不一样。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"final、finally、fi'nalize","slug":"final、finally、fi-nalize","permalink":"http://example.com/tags/final%E3%80%81finally%E3%80%81fi-nalize/"}],"author":"ATAo"},{"title":"为什么Integer 100==100 为true，而Integer 1000==1000为false？","slug":"为什么Integer-100-100-为true，而Integer-1000-1000为false？","date":"2022-01-08T13:39:00.000Z","updated":"2022-01-08T14:19:54.922Z","comments":true,"path":"2022/01/08/为什么Integer-100-100-为true，而Integer-1000-1000为false？/","link":"","permalink":"http://example.com/2022/01/08/%E4%B8%BA%E4%BB%80%E4%B9%88Integer-100-100-%E4%B8%BAtrue%EF%BC%8C%E8%80%8CInteger-1000-1000%E4%B8%BAfalse%EF%BC%9F/","excerpt":"","text":"在java的Integer包装类中为什么Integer a = 100, b = 100,c = 1000,d =1000，令a==b为true，而c==d为false呢？ 首先在上面的代码中，Integer a = 100会调用Integer的Integer.valueOf(int i)这个方法，而这个方法的源代码如下： 我们会发现在将int类型装箱时做了一个判断语句 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) 这句话是什么意思呢？通过注释可以知道，在将一个int类型装箱为Integer类型时，总会优先调用此方法。其存在一个-128到127范围的缓存，如果int类型时该范围内，则直接返回缓存中的值，不需要额外创建Integer类型，这样可以产生显著更好的空间和时间性能。而且其范围也是可以设置。 所有我们可以知道，在执行Integer a = 100，b = 100时，走了缓存，因此b的地址同a应该一样，而c = 1000, d = 1000并为走缓存，而是走的new Interger(i)，因此创建了两个对象。 而我们知道，==比较走的是比较对象的地址。因此才会有为什么Integer 100==100 为true，而Integer 1000==1000为false。 debug如下：","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://example.com/tags/Integer/"}],"author":"ATAO"},{"title":"快速选择","slug":"快速选择","date":"2022-01-08T06:04:00.000Z","updated":"2022-01-08T06:08:50.171Z","comments":true,"path":"2022/01/08/快速选择/","link":"","permalink":"http://example.com/2022/01/08/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/","excerpt":"","text":"快速选择，适用于寻找无序数组中第k大（小）或者前k大（小）这种情况，即TopK问题，是快速排序的一种变化。 class Solution &#123; public static int[] getLeastNumbers(int[] arr, int k) &#123; return quickSelect(arr,k,0,arr.length-1); &#125; private static int[] quickSelect(int[] arr,int k,int l, int r)&#123; if (arr.length &lt;= k)&#123; return arr; &#125; int index = quickSort(arr,l,r); if (index == k)&#123; return Arrays.copyOf(arr,index); &#125;else if (index &lt; k)&#123; return quickSelect(arr,k,index+1,r); &#125;else &#123; return quickSelect(arr,k,l,index-1); &#125; &#125; private static int quickSort(int[] arr, int l, int r) &#123; int mid = l ,i = l, j = r; while (i &lt; j)&#123; while (i&lt;j &amp;&amp; arr[j] &gt;= arr[mid])&#123; --j; &#125; if(i&lt;j &amp;&amp; arr[j] &lt; arr[mid])&#123; swap(arr,j,mid); mid = j; &#125; // p(arr); while (i&lt;j &amp;&amp; arr[i] &lt;= arr[mid])&#123; ++i; &#125; if(i&lt;j &amp;&amp; arr[i] &gt; arr[mid])&#123; swap(arr,i,mid); mid = i; &#125; // p(arr); &#125; swap(arr,i,mid); return mid; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; public static void p(int[] arr)&#123; for (int n:arr)&#123; System.out.print(n+&quot; &quot;); &#125; System.out.println(); &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速选择","slug":"快速选择","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"},{"name":"Top","slug":"Top","permalink":"http://example.com/tags/Top/"}],"author":"ATAO"},{"title":"快速排序","slug":"快速排序","date":"2022-01-08T05:41:00.000Z","updated":"2022-01-08T05:48:02.025Z","comments":true,"path":"2022/01/08/快速排序/","link":"","permalink":"http://example.com/2022/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"原理： 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换； 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换； 5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 代码： public class QuickSort &#123; public static void main(String[] args) &#123; int k = 3; int[] arr = &#123;5,3,7,6,4,1,0,2,9,10,8&#125;; quickSort(arr,0,arr.length-1); p(arr); &#125; private static int[] quickSort(int[] arr,int l, int r) &#123; if (l&gt;r) return null; int mid = l ,i = l, j = r; while (i &lt; j)&#123; while (i&lt;j &amp;&amp; arr[j] &gt;= arr[mid])&#123; --j; &#125; if(i&lt;j &amp;&amp; arr[j] &lt; arr[mid])&#123; swap(arr,j,mid); mid = j; &#125; p(arr); while (i&lt;j &amp;&amp; arr[i] &lt;= arr[mid])&#123; ++i; &#125; if(i&lt;j &amp;&amp; arr[i] &gt; arr[mid])&#123; swap(arr,i,mid); mid = i; &#125; p(arr); &#125; System.out.println(&quot;=========&quot;+i); swap(arr,i,mid); mid = i; quickSort(arr,mid+1,r); quickSort(arr,l,mid-1); return arr; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; public static void p(int[] arr)&#123; for (int n:arr)&#123; System.out.print(n+&quot; &quot;); &#125; System.out.println(); &#125; }","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速排序","slug":"快速排序","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"author":"John Doe"},{"title":"进程通信的方式","slug":"有了for循环，为什么还需要forEach？","date":"2022-01-07T12:48:00.000Z","updated":"2022-01-07T12:59:11.982Z","comments":true,"path":"2022/01/07/有了for循环，为什么还需要forEach？/","link":"","permalink":"http://example.com/2022/01/07/%E6%9C%89%E4%BA%86for%E5%BE%AA%E7%8E%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81forEach%EF%BC%9F/","excerpt":"","text":"在操作系统中，进程是资源分配的基本单位，进程间如果要实现通信，有共享存储、消息传递、管道以及socket这几种方式。 共享存储： 1、基于数据结构的共享：比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种低级通信方式。 2、基于存储区的共享：在内存中画出一块共享存 储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速 度更快，是一种高级通信方式。 管道通信： 1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置 两个管道。 2. 各进程要互斥地访问管道。 3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据 取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。 4. 如果没写满，就不允许读。如果没读空，就不允许写。 5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情 况。 消息传递： 1、直接传递：发送到接收方的接受缓冲队列上 2、间接传递：设置一个接受中转信箱，发送方发送的消息发送到信箱，接收方接受消息从信箱中取 socket：借助于网络通信，从一个主机的进程发送消息到另一个主机上的进程。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"ATAO"},{"title":"单例模式","slug":"单例模式","date":"2022-01-05T08:04:00.000Z","updated":"2022-01-05T08:05:34.618Z","comments":true,"path":"2022/01/05/单例模式/","link":"","permalink":"http://example.com/2022/01/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式，即java类不对外提供构造方法，在类加载的时候创建一个实例化的对象，或者提供一个方法，在方法中作出限制，保证例化对象的创建全局只有唯一一个。其好处在于可以节约系统资源，在资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。在控制资源的情况下，方便资源之间的互相通信。如线程池等。一般可以用于网站的计数器、web应用的日志、配置对象的读取、打印机、任务管理器、数据库连接池。其具体代码实现可以分为饿汉式和懒汉式。 /** 饿汉式 /public class Singleton01 { public static final Singleton01 instance = new Singleton01(); private Singleton01(){ }}/** 饿汉式 /public class Singleton02 { public static final Singleton02 instance; static { instance = new Singleton02(); } private Singleton02(){ } }/** 饿汉式 /public enum Singleton03 { INSTANCE}/** 懒汉式: 存在线程安全问题 /public class Singleton04 { private static Singleton04 instance; private Singleton04(){ } public static Singleton04 getInstance(){ if (instance == null)&#123; instance = new Singleton04(); &#125; return instance; }}/** 懒汉式: 解决线程安全问题 /public class Singleton05 { private volatile static Singleton05 instance; private Singleton05(){ } public static Singleton05 getInstance(){ if (instance == null)&#123; synchronized (Singleton05.class)&#123; instance = new Singleton05(); &#125; &#125; return instance; }}/** 懒汉式: 内部类 /public class Singleton06 { private Singleton06(){ } private static class Inner{ private static final Singleton06 instance = new Singleton06(); } public static Singleton06 getInstance(){ return Inner.instance; }}","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"http://example.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"Hello World","slug":"hello-world","date":"2022-01-05T06:09:04.194Z","updated":"2022-01-05T06:09:04.194Z","comments":true,"path":"2022/01/05/hello-world/","link":"","permalink":"http://example.com/2022/01/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"juc","slug":"juc","permalink":"http://example.com/categories/juc/"},{"name":"设计模式","slug":"juc/设计模式","permalink":"http://example.com/categories/juc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"},{"name":"jvm","slug":"jv-m/jvm","permalink":"http://example.com/categories/jv-m/jvm/"},{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"},{"name":"java","slug":"集合/java","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/java/"},{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"java/设计模式","permalink":"http://example.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"synchronized","slug":"synchronized","permalink":"http://example.com/tags/synchronized/"},{"name":"终止模式","slug":"终止模式","permalink":"http://example.com/tags/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"},{"name":"创建线程","slug":"创建线程","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"},{"name":"类初始化：主动使用与被动使用","slug":"类初始化：主动使用与被动使用","permalink":"http://example.com/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"},{"name":"类的加载过程","slug":"类的加载过程","permalink":"http://example.com/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},{"name":"ArrayList","slug":"ArrayList","permalink":"http://example.com/tags/ArrayList/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"},{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"},{"name":"接口","slug":"接口","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"重写","slug":"重写","permalink":"http://example.com/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"http://example.com/tags/%E9%87%8D%E8%BD%BD/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"final、finally、fi'nalize","slug":"final、finally、fi-nalize","permalink":"http://example.com/tags/final%E3%80%81finally%E3%80%81fi-nalize/"},{"name":"Integer","slug":"Integer","permalink":"http://example.com/tags/Integer/"},{"name":"快速选择","slug":"快速选择","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"},{"name":"Top","slug":"Top","permalink":"http://example.com/tags/Top/"},{"name":"快速排序","slug":"快速排序","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}