{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-01-05T06:15:01.841Z","updated":"2022-01-05T06:10:01.885Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-01-05T08:23:28.052Z","updated":"2022-01-05T06:10:01.886Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-01-05T08:55:42.212Z","updated":"2022-01-05T08:55:42.201Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-05T08:23:46.960Z","updated":"2022-01-05T06:10:01.887Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-01-05T08:22:49.166Z","updated":"2022-01-05T06:10:01.888Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-01-05T06:15:01.947Z","updated":"2022-01-05T06:10:01.888Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-05T08:24:21.310Z","updated":"2022-01-05T06:10:01.888Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"bean的scope的使用陷阱","slug":"bean的scope的使用陷阱","date":"2022-03-03T15:48:00.000Z","updated":"2022-03-03T16:01:27.658Z","comments":true,"path":"2022/03/03/bean的scope的使用陷阱/","link":"","permalink":"http://example.com/2022/03/03/bean%E7%9A%84scope%E7%9A%84%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1/","excerpt":"","text":"我们知道，拥有prototype类型scope的bean，在请求方每次向容器请求该类型对象的时候，容器都会返回一个全新的该对象实例。但是对于在类A中定义成员变量类B，并且通过setter注入类B，并getter返回类B时，会存在每次返回的对象都是同一个对象。 原因在于：虽然A拥有prototype类型的scope，但当容器将一个B的实例注入A之后，A就会一直持有这个FXNewsBean实例的引用。虽然每次输出都调用了getNewsBean()方法并返回了 FXNewsBean 的实例，但实际上每次返回的都是A持有的容器第一次注入的实例。这就是问题之所在。换句话说，第一个实例注入后，A再也没有重新向容器申请新的实例。所以，容器也不会重新为其注入新的B类型的实例。 解决的方案就在于保证get方法每次从容器中取得新的B实例，而不是每次都返回其持有的单一实例。 1、方法注入：Spring容器提出了一种叫做方法注入（Method Injection）的方式，可以帮助我们解决上述问题。我们所要做的很简单，只要让getNewsBean方法声明符合规定的格式，并在配置文件中通知容器，当该方法被调用的时候，每次返回指定类型的对象实例即可。也就是说，该方法必须能够被子类实现或者覆写，因为容器会为我们要进行方法注入的对象使用Cglib动态生成一个子类实现，从而替代当前对象。 2、使用BeanFactoryAware接口：我们知道，即使没有方法注入，只要在实现 get方法的时候，能够保证每次调用BeanFactory的getBean(“newsBean”)，就同样可以每次都取得新的FXNewsBean对象实例。Spring框架提供了一个BeanFactoryAware接口，容器在实例化实现了该接口的bean定义的过程中，会自动将容器本身注入该bean。这样，该bean就持有了它所处的BeanFactory的引用 3、 使用ObjectFactoryCreatingFactoryBean：ObjectFactoryCreatingFactoryBean是Spring提供的一个FactoryBean实现，它返回一个ObjectFactory实例。从ObjectFactoryCreatingFactoryBean返回的这个ObjectFactory实例可以为我们返回容器管理的相关对象。实际上， ObjectFactoryCreatingFactoryBean 实现了BeanFactoryAware接口，它返回的ObjectFactory实例只是特定于与Spring容器进行交互的一个实现而已。使用它的好处就是，隔离了客户端对象对BeanFactory的直接引用。 4、方法替换：与方法注入只是通过相应方法为主体对象注入依赖对象不同，方法替换更多体现在方法的实现层面上，它可以灵活替换或者说以新的方法实现覆盖掉原来某个方法的实现逻辑。基本上可以认为，方法替换可以帮助我们实现简单的方法拦截功能。 首先，我们需要给出org.springframework.beans.factory.support.MethodReplacer的实现类，在这个类中实现将要替换的方法逻辑。 有了要替换的逻辑之后，我们就可以把这个逻辑通过配置到FXNewsProv\u0002ider的bean定义中，使其生效。 最后需要强调的是，这种方式刚引入的时候执行效率不是很高。而且，当你充分了解并应用SpringAOP之后，我想你也不会再回头求助这个特色功能。不过，怎么说这也是一个选择，场景合适的话，为何不用呢？哦，如果要替换的方法存在参数，或者对象存在多个重载的方法，可以在内部通过明确指定将要替换的方法参数类型。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"scop","slug":"scop","permalink":"http://example.com/tags/scop/"}],"author":"John Doe"},{"title":"工厂方法与 FactoryBean","slug":"工厂方法与-FactoryBean","date":"2022-03-03T15:05:00.000Z","updated":"2022-03-03T15:31:28.499Z","comments":true,"path":"2022/03/03/工厂方法与-FactoryBean/","link":"","permalink":"http://example.com/2022/03/03/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%B8%8E-FactoryBean/","excerpt":"","text":"在强调“面向接口编程”的同时，有一点需要注意：虽然对象可以通过声明接口来避免对特定接口实现类的过度耦合，但总归需要一种方式将声明依赖接口的对象与接口实现类关联起来。否则，只依赖一个不做任何事情的接口是没有任何用处的。 如果该类是由我们设计并开发的，那么还好说，我们可以通过依赖注入，让容器帮助我们解除接口与实现类之间的耦合性。但是，有时，我们需要依赖第三方库，需要实例化并使用第三方库中的相关类，这时，接口与实现类的耦合性需要其他方式来避免。 通常的做法是通过使用工厂方法（Factory Method）模式，提供一个工厂类来实例化具体的接口实现类，这样，主体对象只需要依赖工厂类，具体使用的实现类有变更的话，只是变更工厂类，而主体对象不需要做任何变动。 针对使用工厂方法模式实例化对象的方式，Spring的IoC容器同样提供了对应的集成支持。我们所要做的，只是将工厂类所返回的具体的接口实现类注入给主体对象 1、 静态工厂方法（Static Factory Method） 2、非静态工厂方法（Instance Factory Method） 3、FactoryBean：FactoryBean是Spring容器提供的一种可以扩展容器对象实例化逻辑的接口，请不要将其与容器名称BeanFactory相混淆。FactoryBean，其主语是Bean，定语为Factory，也就是说，它本身与其他注册到容器的对象一样，只是一个Bean而已，只不过，这种类型的Bean本身就是生产对象的工厂（Factory）。 当某些对象的实例化过程过于烦琐，通过XML配置过于复杂，使我们宁愿使用Java代码来完成这个实例化过程的时候，或者，某些第三方库不能直接注册到Spring容器的时候，就可以实现org.spring.framework.beans.factory.FactoryBean接口，给出自己的对象实例化逻辑代码。当然，不使用Fac.toryBean，而像通常那样实现自定义的工厂方法类也是可以的。不过，FactoryBean可是Spring提供的对付这种情况的“制式装备”哦！ Spring容器内部许多地方了使用FactoryBean。下面是一些比较常见的FactoryBean实现，你可以参照FactoryBean的Javadoc以了解更多内容。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"FactoryBean","slug":"FactoryBean","permalink":"http://example.com/tags/FactoryBean/"}],"author":"John Doe"},{"title":"bean的scope","slug":"bean的scope","date":"2022-03-03T14:23:00.000Z","updated":"2022-03-03T15:05:21.116Z","comments":true,"path":"2022/03/03/bean的scope/","link":"","permalink":"http://example.com/2022/03/03/bean%E7%9A%84scope/","excerpt":"","text":"BeanFactory除了拥有作为IoC Service Provider的职责，作为一个轻量级容器，它还有着其他一些职责，其中就包括对象的生命周期管理。 Spring容器最初提供了两种bean的scope类型：singleton和prototype，但发布2.0之后，又引入了另外三种scope类型，即request、session和global session类型。不过这三种类型有所限制，只能在Web应用中使用。也就是说，只有在支持Web应用的ApplicationContext中使用这三个scope才是合理的。 1、singleton：标记为拥有singleton scope的对象定义，在Spring的IoC容器中只存在一个实例，所有对该对象的引用将共享这个实例。该实例从容器启动，并因为第一次被请求而初始化之后，将一直存活到容器退出，也就是说，它与IoC容器“几乎”拥有相同的“寿命”。 （注意：需要注意的一点是，不要因为名字的原因而与GoF所提出的Singleton模式相混淆，二者的语意是不同的：标记为singleton的bean是由容器来保证这种类型的bean在同一个容器中只存在一个共享实例；而Singleton模式则是保证在同一个Classloader中只存在一个这种类型的实例。） 2、 prototype：针对声明为拥有prototype scope的bean定义，容器在接到该类型对象的请求的时候，会每次都重新生成一个新的对象实例给请求方。虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工作，包括该对象的销毁。也就是说，容器每次返回给请求方一个新的对象实例之后，就任由这个对象实例“自生自灭”了。 3、 request：Spring容器，即XmlWebApplicationContext会为每个HTTP请求创建一个全新的Request\u0002Processor对象供当前请求使用，当请求结束后，该对象实例的生命周期即告结束。当同时有10个HTTP请求进来的时候，容器会分别针对这10个请求返回10个全新的RequestProcessor对象实例，且它们之间互不干扰。从不是很严格的意义上说，request可以看作prototype的一种特例，除了场景更加具体之外，语意上差不多。 4、session：对于Web应用来说，放到session中的最普遍的信息就是用户的登录信息，对于这种放到session中的信息，我们可使用如下形式指定其scope为session 5、global session：global session只有应用在基于portlet的Web应用程序中才有意义，它映射到portlet的global范围的 3session。如果在普通的基于servlet的Web应用中使用了这个类型的scope，容器会将其作为普通的session类型的scope对待。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"},{"name":"Spring ","slug":"Spring/Spring","permalink":"http://example.com/categories/Spring/Spring/"}],"tags":[{"name":"scope","slug":"scope","permalink":"http://example.com/tags/scope/"}],"author":"John Doe"},{"title":"Spring的IOC容器之BeanFactory","slug":"Spring的IOC容器之BeanFactory","date":"2022-03-03T13:21:00.000Z","updated":"2022-03-03T13:56:15.460Z","comments":true,"path":"2022/03/03/Spring的IOC容器之BeanFactory/","link":"","permalink":"http://example.com/2022/03/03/Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E4%B9%8BBeanFactory/","excerpt":"","text":"BeanFactory，顾名思义，就是生产Bean的工厂。当然，严格来说，这个“生产过程”可能不像说起来那么简单。既然Spring框架提倡使用POJO，那么把每个业务对象看作一个JavaBean对象，或许更容易理解为什么Spring的IoC基本容器会起这么一个名字。作为Spring提供的基本的IoC容器，BeanFactory可以完成作为IoC Service Provider的所有职责，包括业务对象的注册和对象间依赖关系的绑定。 BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。相似地，将应用所需的所有业务对象交给BeanFactory之后，剩下要做的，就是直接从BeanFactory取得最终组装完成并且可用的对象。至于这个最终业务对象如何组装，你不需要关心，BeanFactory会帮你搞定。 所以，对于客户端来说，与BeanFactory打交道其实很简单。最基本地，BeanFactory肯定会公开一个取得组装完成的对象的方法接口，就像代码清单4-1中真正的BeanFactory的定义所展示的那样。 BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。相似地，将应用所需的所有业务对象交给BeanFactory之后，剩下要做的，就是直接从BeanFactory取得最终组装完成并且可用的对象。至于这个最终业务对象如何组装，你不需要关心，BeanFactory会帮你搞定。 当BeanFactory说这些事情让它来做的时候，可能没有告诉你它会怎么来做这个事情。不过没关系，我们通常只需将“生产线图纸”交给BeanFactory就行了。通常情况下，它会通过常用的图纸（XML文件）来注册并管理各个业务对象之间的依赖关系。 当然BeanFactory只是一个接口，我们最终需要一个该接口的实现来进行实际的Bean的管理，DefaultListableBeanFactory就是这么一个比较通用的BeanFactory实现类。 DefaultListableBeanFactory除了间接地实现了BeanFactory接口，还实现了BeanDefinitionRegistry接口，该接口才是在BeanFactory的实现中担当Bean注册管理的角色。基本上，BeanFactory接口只定义如何访问容器内管理的Bean的方法，各个BeanFactory的具体实现类负责具体Bean的注册以及管理工作。BeanDefinitionRegistry接口定义抽象了Bean的注册逻辑。通常情况下，具体的BeanFactory实现类会实现这个接口来管理Bean的注册。 每一个受管的对象，在容器中都会有一个BeanDefinition的实例（instance）与之相对应，该BeanDefinition的实例负责保存对象的所有必要信息，包括其对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等。当客户端向BeanFactory请求相应对象的时候，BeanFactory会通过这些信息为客户端返回一个完备可用的对象实例。RootBeanDefinition和ChildBean\u0002Definition是BeanDefinition的两个主要实现类。 采用外部配置文件时，Spring的IoC容器有一个统一的处理方式。通常情况下，需要根据不同的外部配置文件格式，给出相应的BeanDefinitionReader实现类，由BeanDefinitionReader的相应实现类负责将相应的配置文件内容读取并映射到BeanDefinition，然后将映射后的BeanDefinition注册到一个BeanDefinitionRegistry，之后，BeanDefinitionRegistry即完成Bean的注册和加载。当然，大部分工作，包括解析文件格式、装配BeanDefinition之类的工作，都是由BeanDefinition\u0002Reader的相应实现类来做的，BeanDefinitionRegistry只不过负责保管而已。 与为 Properties配置文件格式提供PropertiesBeanDefinitionReader相对应，Spring同样为XML格式的配置文件提供了现成的BeanDefinitionReader实现，即XmlBeanDefinitionReader。XmlBeanDefinitionReader负责读取Spring指定格式的XML配置文件并解析，之后将解析后的文件内容映射到相应的BeanDefinition，并加载到相应的BeanDefinitionRegistry中（在这里是Default\u0002ListableBeanFactory）。这时，整个BeanFactory就可以放给客户端使用了。除了提供XmlBeanDefinitionReader用于XML格式配置文件的加载，Spring还在Default\u0002ListableBeanFactory的基础上构建了简化XML格式配置加载的XmlBeanFactory实现。 如果要通过注解标注的方式为类注入所需要的依赖，现在可以使用@Autowired以 及@Component等对相关类进行标记。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"BeanFactory","slug":"BeanFactory","permalink":"http://example.com/tags/BeanFactory/"}],"author":"John Doe"},{"title":"Spring的IOC容器","slug":"Spring的IOC容器","date":"2022-03-03T13:11:00.000Z","updated":"2022-03-03T13:20:31.109Z","comments":true,"path":"2022/03/03/Spring的IOC容器/","link":"","permalink":"http://example.com/2022/03/03/Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8/","excerpt":"","text":"Spring的IoC容器是一个IoC Service Provider，但是，这只是它被冠以IoC之名的部分原因，我们不能忽略的是“容器”。Spring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spring的IoC容器之上，Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring的IoC容器和IoCService Provider所提供的服务之间存在一定的交集。 Spring提供了两种容器类型：BeanFactoryApplicationContext  BeanFactory。基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。  ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"http://example.com/tags/IOC/"}],"author":"John Doe"},{"title":"—IoC Service Provider 如何管理对象间的 依赖关系","slug":"—IoC-Service-Provider-如何管理对象间的-依赖关系","date":"2022-03-03T10:30:00.000Z","updated":"2022-03-03T13:11:08.016Z","comments":true,"path":"2022/03/03/—IoC-Service-Provider-如何管理对象间的-依赖关系/","link":"","permalink":"http://example.com/2022/03/03/%E2%80%94IoC-Service-Provider-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/","excerpt":"","text":"IoC Service Provider不是人类，也就不能像酒吧服务生那样通过大脑来记忆和存储所有的相关信息。所以，它需要寻求其他方式来记录诸多对象之间的对应关系。比如：  它可以通过最基本的文本文件来记录被注入对象和其依赖对象之间的对应关系；  它也可以通过描述性较强的XML文件格式来记录对应信息；  它还可以通过编写代码的方式来注册这些对应信息；  甚至，如果愿意，它也可以通过语音方式来记录对象间的依赖注入关系（“嗨，它要一个这种类型的对象，拿这个给它”）。 那么，实际情况下，各种具体的IoC Service Provider实现又是通过哪些方式来记录“服务信息”的呢？我们可以归纳一下，当前流行的 IoC Service Provider产品使用的注册对象管理信息的方式主要有以下几种。 1、直接编码方式 2、配置文件方式 3、元数据方式","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"http://example.com/tags/IOC/"}],"author":"John Doe"},{"title":"IoC Service Provider 的职责","slug":"IoC-Service-Provider-的职责","date":"2022-03-03T10:27:00.000Z","updated":"2022-03-03T10:28:50.333Z","comments":true,"path":"2022/03/03/IoC-Service-Provider-的职责/","link":"","permalink":"http://example.com/2022/03/03/IoC-Service-Provider-%E7%9A%84%E8%81%8C%E8%B4%A3/","excerpt":"","text":"IoC Service Provider的职责相对来说比较简单，主要有两个：业务对象的构建管理和业务对象间的依赖绑定。  业务对象的构建管理。在IoC场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。所以，IoC Service Provider需要将对象的构建逻辑从客户端对象那里剥离出来，以免这部分逻辑污染业务对象的实现。  业务对象间的依赖绑定。对于IoC Service Provider来说，这个职责是最艰巨也是最重要的，这是它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不会得到依赖对象的任何响应（最常见的倒是会收到一个NullPointerException）。IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状态。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"IoC Service Provider","slug":"IoC-Service-Provider","permalink":"http://example.com/tags/IoC-Service-Provider/"}],"author":"John Doe"},{"title":"IOC的基本理念：让别人为你服务","slug":"IOC的基本理念：让别人为你服务","date":"2022-03-03T09:01:00.000Z","updated":"2022-03-03T10:25:33.400Z","comments":true,"path":"2022/03/03/IOC的基本理念：让别人为你服务/","link":"","permalink":"http://example.com/2022/03/03/IOC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E5%BF%B5%EF%BC%9A%E8%AE%A9%E5%88%AB%E4%BA%BA%E4%B8%BA%E4%BD%A0%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"IOC即控制反转，它还有一个别名叫做依赖注入（DependencyInjection）。 在我日常开发中，经常需要一个对象依赖于另一个对象的服务。最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。这就好比要装修新房，需要用家具，这个时候，根据通常解决对象依赖关系的做法，我们就会直接打造出需要的家具来。不过，通常都是分工明确的，所以，大多数情况下，我们可以去家具广场将家具买回来，然后根据需要装修布置即可。不管是直接打造家具（通过new构造对象），还是去家具广场买家具（通过工厂设计模式），有一个共同点需要我们关注，那就是我们都是自己主动地去获取依赖的对象！可是回头想想，我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。 实际上IOC就是为了帮助我们解决这种问题的，而提供了更加轻松简洁的方式。它的反转，就反转在让你从原来的事必躬亲，转变为现在的享受服务。 通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过IoC Service Provider来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。被注入对象需要什么，直接跟IoC Service Provider招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到IoC Service Provider为被注入对象服务的目的。IoC Service Provider在这里就是通常的IoC容器所充当的角色。从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转，控制也从被注入对象转到了IoC Service Provider那里。 （IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或者IoC容器实现。）","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"IOC的理解","slug":"IOC的理解","permalink":"http://example.com/tags/IOC%E7%9A%84%E7%90%86%E8%A7%A3/"}],"author":"John Doe"},{"title":"Spring三种注入方法比较","slug":"Spring三种注入方法比较","date":"2022-03-03T08:53:00.000Z","updated":"2022-03-03T08:54:49.415Z","comments":true,"path":"2022/03/03/Spring三种注入方法比较/","link":"","permalink":"http://example.com/2022/03/03/Spring%E4%B8%89%E7%A7%8D%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83/","excerpt":"","text":"接口注入。从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。 构造方法注入。这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以 马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。 setter方法注入。因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无法在构造完成后马上进入就绪状态。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"注入方式","slug":"注入方式","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"}],"author":"John Doe"},{"title":"MySQL怎么查看索引是否是高选择性？","slug":"MySQL怎么查看索引是否是高选择性？","date":"2022-03-02T11:33:00.000Z","updated":"2022-03-02T11:40:36.822Z","comments":true,"path":"2022/03/02/MySQL怎么查看索引是否是高选择性？/","link":"","permalink":"http://example.com/2022/03/02/MySQL%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E6%98%AF%E9%AB%98%E9%80%89%E6%8B%A9%E6%80%A7%EF%BC%9F/","excerpt":"","text":"通过show index查看结果列中的cardinality值（表示索引中不重复记录数量的预估值），在实际应用中cardinality/table.size应该尽可能接近1。 cardinality是在存储引擎层进行统计的。具体方式是通过采样的方法来完成。具体发生在insert和update操作中，策略为①表中1/16数据发生过变化②stat_modified_counter&gt;2 000 000 000（表中数据实际未增加，实际发生变化的还是这一行数据①就无法适用，则通过②的计数器stat_modirfied_counter表示发生变化次数）。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95/"}],"author":"John Doe"},{"title":"InnoDB行溢出（Redundant）","slug":"InnoDB行溢出","date":"2022-03-02T10:45:00.000Z","updated":"2022-03-02T10:53:16.247Z","comments":true,"path":"2022/03/02/InnoDB行溢出/","link":"","permalink":"http://example.com/2022/03/02/InnoDB%E8%A1%8C%E6%BA%A2%E5%87%BA/","excerpt":"","text":"3个列长度总和是66000，innoDB存储引擎的页为16kb，16384字节，会产生行溢出，因此对于这种情况，数据不会存放于b+tree的叶子节点中，而是存入页类型为uncompress blob页中。 每页中至少存放两条行记录（否则失去了B+tree的意义，变为了链表），因此如果一页中只能放一条记录，则会将数据放到溢出页。而对于Text或BLOB的数据类型亦然。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"行结构","slug":"行结构","permalink":"http://example.com/tags/%E8%A1%8C%E7%BB%93%E6%9E%84/"}],"author":"John Doe"},{"title":"MySQL中varchar中的N","slug":"MySQL中varchar中的N","date":"2022-03-02T10:42:00.000Z","updated":"2022-03-02T10:44:12.635Z","comments":true,"path":"2022/03/02/MySQL中varchar中的N/","link":"","permalink":"http://example.com/2022/03/02/MySQL%E4%B8%ADvarchar%E4%B8%AD%E7%9A%84N/","excerpt":"","text":"varchar(N)指的是字符长度，而官方文档中指的是最大支持65535是字节","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"行","slug":"行","permalink":"http://example.com/tags/%E8%A1%8C/"}],"author":"John Doe"},{"title":"如何在 Linux 系统中查看 TCP 状态？","slug":"如何在-Linux-系统中查看-TCP-状态？","date":"2022-02-25T01:56:00.000Z","updated":"2022-02-25T01:58:06.991Z","comments":true,"path":"2022/02/25/如何在-Linux-系统中查看-TCP-状态？/","link":"","permalink":"http://example.com/2022/02/25/%E5%A6%82%E4%BD%95%E5%9C%A8-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8B-TCP-%E7%8A%B6%E6%80%81%EF%BC%9F/","excerpt":"","text":"netstat-napt","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://example.com/tags/TCP/"}],"author":"John Doe"},{"title":"最左匹配原则","slug":"最左匹配原则","date":"2022-02-24T08:02:00.000Z","updated":"2022-02-24T08:04:16.906Z","comments":true,"path":"2022/02/24/最左匹配原则/","link":"","permalink":"http://example.com/2022/02/24/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/","excerpt":"","text":"MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下： select * from user where name=xx and city=xx ; ／／可以命中索引 select * from user where name=xx ; // 可以命中索引 select * from user where city=xx; // 无法命中索引 需要注意：查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDERBY子句也遵循此规则。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"最左匹配原则","slug":"最左匹配原则","permalink":"http://example.com/tags/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"}],"author":"John Doe"},{"title":"一条SQL语句执行得很慢的原因有哪些？","slug":"一条SQL语句执行得很慢的原因有哪些？","date":"2022-02-24T07:50:00.000Z","updated":"2022-02-24T07:59:49.798Z","comments":true,"path":"2022/02/24/一条SQL语句执行得很慢的原因有哪些？/","link":"","permalink":"http://example.com/2022/02/24/%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E5%BE%97%E5%BE%88%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/","excerpt":"","text":"一个 SQL 执行的很慢，我们要分两种情况讨论： 1、大多数情况下很正常，偶尔很慢，则有如下原因 (1)、数据库在刷新脏页，例如 redo log 页写满了需要同步到磁盘。 (2)、执行的时候，遇到锁，如表锁、行锁。 2、这条 SQL 语句一直执行的很慢，则有如下原因。 (1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。 (2)、数据库选错了索引。 转载：https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN%23rd","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"性能","slug":"性能","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD/"}],"author":"John Doe"},{"title":"分库分表之后的主键处理方式","slug":"分库分表之后的主键处理方式","date":"2022-02-24T04:56:00.000Z","updated":"2022-02-24T05:00:22.852Z","comments":true,"path":"2022/02/24/分库分表之后的主键处理方式/","link":"","permalink":"http://example.com/2022/02/24/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B9%8B%E5%90%8E%E7%9A%84%E4%B8%BB%E9%94%AE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1、UUID：不适合作为主键，其太长了而且无序，插入效率低 2、数据库自增id：两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。 3、利⽤ redis ⽣成 id : 性能⽐᫾好，灵活⽅便，不依赖于数据库。但是，引⼊了新的组件造成系统更加复杂，可⽤性降低，编码更加复杂，增加了系统成本。 4、Twitter的snowflake算法： 1.第一位 占用1bit，其值始终是0，没有实际作用。 2.时间戳 占用41bit，精确到毫秒，总共可以容纳约140年的时间。 3.工作机器id 占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。 4.序列号 占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。 SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法： 1024x4096 SnowFlake算法的优点： 1.生成ID时不依赖于DB，完全在内存生成，高性能高可用。 2.ID呈趋势递增，后续插入索引树的时候性能较好。 SnowFlake算法的缺点： 依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"主键","slug":"主键","permalink":"http://example.com/tags/%E4%B8%BB%E9%94%AE/"}],"author":"John Doe"},{"title":"http常见状态码","slug":"http常见状态码","date":"2022-02-23T07:48:00.000Z","updated":"2022-02-23T07:56:43.034Z","comments":true,"path":"2022/02/23/http常见状态码/","link":"","permalink":"http://example.com/2022/02/23/http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"1xx：表示一种提示信息，一般是服务器的中间状态，不常用 2xx：表示服务器已经成功处理了请求 200：成功204：成功（响应头没有body数据）206：用于http分块下载或者断点续传，表示响应的body里面的数据并不完整，只是一部分 3xx：客户端请求的资源发生了变动需要重定向 301：表示永久重定向，即访问的资源永久不存在 302：临时重定向，即访问的资源还在，需要换一个url访问 301和302会在响应头使用location字段表明重定向的url进行重定向 304：不具有跳转含义，表明请求的资源未修改，重定向缓存文件。 4xx：请求的报文有误，服务器无法处理 400：请求错误，具体不清楚 403：服务器禁止访问资源 404：访问的资源在服务器找不到 5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意思。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"}],"author":"John Doe"},{"title":"http","slug":"http","date":"2022-02-23T07:37:47.000Z","updated":"2022-02-23T07:38:21.504Z","comments":true,"path":"2022/02/23/http/","link":"","permalink":"http://example.com/2022/02/23/http/","excerpt":"","text":"http是计算机世界里面两点之间进行文字、图片、视频等超文本数据传输的协议","categories":[],"tags":[],"author":"John Doe"},{"title":"get和post的区别","slug":"get和post的区别","date":"2022-02-18T14:38:00.000Z","updated":"2022-02-18T14:39:22.715Z","comments":true,"path":"2022/02/18/get和post的区别/","link":"","permalink":"http://example.com/2022/02/18/get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"POST和GET都是向服务器提交数据，并且都会从服务器获取数据。 区别： 1、传送方式：get通过地址栏传输，post通过报文传输。 2、传送长度：get参数有长度限制（受限于url长度），而post无限制 3、GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包；POST产生两个TCP数据包 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 建议： 1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式； 2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式； 案例：一般情况下，登录的时候都是用的POST传输，涉及到密码传输，而页面查询的时候，如文章id查询文章，用get 地址栏的链接为：article.php?id=11，用post查询地址栏链接为：article.php， 不会将传输的数据展现出来。 拓展资料： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"get","slug":"get","permalink":"http://example.com/tags/get/"},{"name":"post","slug":"post","permalink":"http://example.com/tags/post/"}],"author":"John Doe"},{"title":"代理模式","slug":"代理模式","date":"2022-02-11T13:22:00.000Z","updated":"2022-02-11T13:38:00.109Z","comments":true,"path":"2022/02/11/代理模式/","link":"","permalink":"http://example.com/2022/02/11/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"代理模式是指，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户类和目标对象之间起到中介的作用。说直白一点就是在不修改目标对象的基础上，使用代理对象来增强目标对象的业务逻辑方法。 代理模式分为：静态代理和动态代理（jdk动态代理和cglib动态代理） 静态代理就是：代理类在程序运行前就确定好了和目标类的关系，在编译期就实现了。其中静态代理的缺点在于： 1、代码复杂，不便于管理：试想对于代理类，需要和目标类实现相同接口即每个代理类都要实现目标类的的方法，会出现代码重复，且考虑到如果接口增加一个方法，其所有实现类都要重写，维护也麻烦。 2、代理类依赖于目标类：当代理类考虑代理多个服务的时候，不便于实现 动态代理是在程序运行期间根据jvm反射机制动态生成的。 jdk动态代理：基于java反射机制实现的。具体通过使用java.lang.reflect 包提供三个类支持代理模式 Proxy, Method和 InovcationHandler。（要求：求目标对象必须实现接口） public interface UsbSell &#123; Object sell(float amount); &#125; public class UsbFactory implements UsbSell &#123; public Object sell(float amount) &#123; float price = 0; if (amount &gt; 100)&#123; price = (float) (amount * (1 + 0.2)); &#125;else &#123; price = (float) (amount * (1 + 0.5)); &#125; return price; &#125; &#125; public class ProxySeller &#123; private Object target; public ProxySeller() &#123; &#125; public ProxySeller(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; float res = (Float) method.invoke(target,args); System.out.println(&quot;==&quot;+res); return proxy; &#125; &#125;); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; UsbFactory factory = new UsbFactory(); ProxySeller seller = new ProxySeller(factory); UsbSell proxy = (UsbSell)seller.getProxy(); UsbSell s = (UsbSell)proxy.sell(50); s.sell(50); &#125; &#125; cglib动态代理：一个开源项目。对于无接口的类，要为其创建动态代理，就要使用 CGLIB 来实现。CGLIB 代理的生成原理是生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象。所以，使用CGLIB 生成动态代理，要求目标类必须能够被继承，即不能是 final 的类。 public class Saller &#123; public float sell(int amount)&#123; float price = 100; if (amount &gt; 100)&#123; price = (float) (price * (1 + 0.2)); &#125;else &#123; price = (float) (price * (1 + 0.5)); &#125; return price; &#125; &#125; public class ProxySaller implements MethodInterceptor &#123; private Object target; public ProxySaller() &#123; &#125; public ProxySaller(Object target) &#123; this.target = target; &#125; public Object getProxySaller()&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(this); Saller saller = (Saller) enhancer.create(); return saller; &#125; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; Float price = (Float) methodProxy.invoke(target,objects); System.out.println(&quot;===&quot;+price); return price; &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; Saller saller = new Saller(); ProxySaller proxySaller = new ProxySaller(saller); Saller proxy = (Saller) proxySaller.getProxySaller(); proxy.sell(100); &#125; &#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"innoDB中的锁","slug":"innoDB中的锁","date":"2022-02-10T05:38:00.000Z","updated":"2022-02-10T11:19:02.156Z","comments":true,"path":"2022/02/10/innoDB中的锁/","link":"","permalink":"http://example.com/2022/02/10/innoDB%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"innoDB实现了共享锁（读锁）和排他锁（写锁）两种行级锁。意向共享锁和意向排他锁两种表级别的锁。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"}],"author":"John Doe"},{"title":"lock与latch","slug":"lock与latch","date":"2022-02-10T05:36:00.000Z","updated":"2022-02-10T05:38:14.315Z","comments":true,"path":"2022/02/10/lock与latch/","link":"","permalink":"http://example.com/2022/02/10/lock%E4%B8%8Elatch/","excerpt":"","text":"","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"}],"author":"John Doe"},{"title":"MySQL分区","slug":"MySQL分区","date":"2022-02-09T12:14:49.000Z","updated":"2022-02-09T12:14:49.287Z","comments":true,"path":"2022/02/09/MySQL分区/","link":"","permalink":"http://example.com/2022/02/09/MySQL%E5%88%86%E5%8C%BA/","excerpt":"","text":"","categories":[],"tags":[],"author":"John Doe"},{"title":"MySQL表","slug":"MySQL表","date":"2022-02-09T10:47:00.000Z","updated":"2022-02-09T12:07:08.587Z","comments":true,"path":"2022/02/09/MySQL表/","link":"","permalink":"http://example.com/2022/02/09/MySQL%E8%A1%A8/","excerpt":"","text":"innoDB中，表根据主键顺序存放。每张表都有一个主键，在建表时没有显示定义主键，则innoDB会先判断表中是否有非空的唯一索引，如果有，则该索引即为主键（对于多个非空唯一索引，根据定义的顺序选择，而不是建表列的顺序选择），如果没有，则会自动创建一个6字节的指针。 innoDB中，数据被逻辑的放在一个表空间。表空间由段组成，段又由区组成，区又有页组成，页时最基本的单位。如下： innoDB默认情况下有一个共享表空间，如果用户开启参数innodb_file_per_table则每张表的数据单独放到一个表空间。（需要注意的是：单独的表空间只是存放数据、索引和插入缓冲bitmap页，对于其他数据，如回滚信息、插入缓冲索引页等仍是存放在共享表空间） 对于段由innoDB管理，数据段即为B+tree的叶子节点，索引段即为B+tree的非叶子节点，回滚段较为特殊。 区则是连续页（默认16kb/页）组成的空间（大小1mb）。一个区默认有64个连续的页。为了保证区中页的连续性，innoDB会一次从磁盘申请4-5个区。值得注意的是： innoDB常见页： 页又由行组成最多允许7992（16kb/2-200）行记录。innoDB提供了Compact和Redundant格式的行数据格式。需要注意：除了下图的信息外，还存在事务ID列（6字节）和回滚指针列（7字节），如果innoDB没有定义主键还会有一个6字节的rowid列 Compact行记录： Redundant行记录格式： 当然一般情况下innoDB的数据都是放在页类型为B+tree-node中，但是当发生行溢出，数据存放在Uncompress BLOB页中。 innoDB数据页结构：","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"表","slug":"表","permalink":"http://example.com/tags/%E8%A1%A8/"}],"author":"John Doe"},{"title":"MySQL文件","slug":"MySQL文件","date":"2022-02-09T08:05:00.000Z","updated":"2022-02-09T08:39:14.232Z","comments":true,"path":"2022/02/09/MySQL文件/","link":"","permalink":"http://example.com/2022/02/09/MySQL%E6%96%87%E4%BB%B6/","excerpt":"","text":"1、参数文件：MySQL实例启动时会读取参数文件来初始化。 2、日志文件： 错误日志（记录了MySQL执行期间的错误信息） 二进制日志（记录了对MySQL执行的写操作，默认未开启。 作用：1、恢复，可以通过binlog进行数据的恢复2、复制：通过复制和执行binlog对远程的MySQL进行实时数据同步（主从复制）3、审计：对binlog数据进行审计，看是否有对数据库进行注入的攻击 ） 慢查询日志（可以从中得到一些SQL优化信息，默认未开启） 查询日志（记录了所有对MySQL的请求信息） 3、套接字文件 4、pid文件 5、表结构定义文件（以frm为后缀名）：记录了该表的表结构定义。除此之外还用于存放视图的定义。 6、innoDB存储引擎文件： a）表空间文件（默认10mb，名为ibdata1）：可以设置基于innoDB存储的单独的。idb独立表空间文件（仅存储数据、索引等信息，其他信息还是存放于表空间文件）。 b）、redolog文件（默认会有两个名为ib_logfile0和ib_logfile1的文件）：每个innoDB至少有一个redolog组（每组至少有两个redolog文件），redolog冲缓冲区写入磁盘是按512字节，即一个扇区大小，可以保障写入必定成功（所有不需要doublewrite）","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"文件","slug":"文件","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6/"}],"author":"John Doe"},{"title":"innoDB存储引擎","slug":"innoDB存储引擎","date":"2022-02-09T03:04:00.000Z","updated":"2022-02-09T07:37:44.969Z","comments":true,"path":"2022/02/09/innoDB存储引擎/","link":"","permalink":"http://example.com/2022/02/09/innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","excerpt":"","text":"innoDB存储引擎是开源的第一个完整支持ACID事务的MySQL存储引擎（第一个支持事务的是BDB存储引擎），其特点是行锁设计、支持MVCC、支持外键、一致性非锁定读等。被广泛的应用。 innoDB存储引擎有多个内存块，组成了一个大的内存池，每个内存块有指定的后台线程来维护其运行。 1、main线程主要负责将缓冲区的数据异步刷新到磁盘，保证数据的一致性（包括脏页的刷新、合并插入缓冲、undo页的回收等） 2、IO线程主要是负责IO请求的回调，包括read、write、insert buffer、log等，其使用了AIO机制，保证了IO性能。 3、Purge线程主要用于回收提交事务之后，undo页可能不再需要，需要对其进行回收。（1.2版本支持多个Purge线程，目的是进一步加快undo页的回收，提升性能） 4、Page cleaner线程主要用于脏页的刷新操作，减轻main线程的压力。 innoDB是基于磁盘存储的，为了权衡磁盘速度和CPU速度的差异，提供了一块缓冲池技术来提升性能。（因此可以将缓冲池区域设置大一点来进行优化操作）innoDB1.0允许多个缓冲池实例，磁盘读取的页根据哈希值均匀分配到不同缓冲池中（目的：减少数据库资源竞争，增加数据库并发处理能力） 在数据的读取中，会先去缓冲池中查看是否存在于缓冲池，如果存在直接读取，不存在则去磁盘读取，在同步到缓冲池中。而对于写操作则是先写到缓冲池，然后根据Checkpoint机制将脏数据刷新到磁盘，保证磁盘和内存数据的一致性。 缓冲池具体的数据页有： 为了管理这些数据页，innoDB使用了一个freeLIst链表来管理空闲的页内存，LRUList来管理已经分配的页内存，flushList来管理脏页。（脏页及存在于LRUList，又存在于flushList，是两者共享的） 对于LRUList管理的页，采用了LRU（最近最少使用）算法来管理（缓冲池页大小默认16kb），在LRU列表中加入了一个midpoint位置（默认是5/8位置处），midpoint位置前面的是热点数据区域，后面的是冷数据区域（设置冷、热数据区域主要是为了保证一些经常被访问的数据存在于内存中，提示效率的一种考虑）。当一个新的页被分配到LRULIst上，会先加入到midpoint位置后面（这样做是为了防止当进行全表查询的时候，多个页会覆盖调热数据区域的页，而这些查的数据页又只使用一次，后续不再使用，当后面访问热区域的页时有会从磁盘中查找，浪费性能），同时也指定了一个从冷数据区域晋升到热数据区域的参数，当到了晋升时间后，冷数据区域的页就会晋升到热数据区域。 值得注意的是：空闲页的内存freeList+以分配的页内存LRUList并不等于缓冲池的内存，因为缓冲池中包含得其他部分页（自适应哈希索引、lock信息等）不需要LRU维护，不存在于LRUList中。 另外，页是支持压缩的，16kb的页可以压缩成1kb、2kb、4kb、8kb。页的大小发生变化，所有对于压缩的页，会使用zipLRUList进行管理。（注意：LRUList包含zipLRUList中的页） 对于zipLIRList的页的分配采用伙伴算法 例如压缩后的页为4kb 1、先检查4kb的zipLRUList是否有空闲页，存在即分配 2、否则，检查8kb的zipLRUList看是否存在空闲页，存在则将8kb分为两个4kb，将4kb的页放入4kbzipLRUList，然后为其分配 3、在否则，检查16kb的freeList看是否存在空闲页，存在则将16kb分为两个4kb，一个8kb，分别放入对应zipLRUList，然后为其分配 由上图可知，innoDB除了缓冲池，还存在redolog日志缓冲和额外内存池。 其中redolog日志缓冲（默认8mb大小）是redolog文件的缓冲区（redolog文件记录了写请求的指令，对页的写指令都会记录到这个文件中，后续数据库恢复会使用到这个文件）当满足以下条件就会将缓冲区的数据刷新到文件中。 1、每个事物提交会进行刷新 2、当缓冲区小于一半，会进行刷新 3、main线程每秒会进行一次刷新 而额外的内存池则是在对于一些数据结构本身进行进行内存分配时会从额外内存储进行申请。 前面提到进行写操作入时，一般会先写到缓冲区，然后在根据checkpoint机制将脏页刷新到内存，保持内存和磁盘数据的一致性。但考虑到如果频繁发生写操作，而对脏数据刷新到磁盘不加以控制，每来一个写操作，都会进行一次刷新，那就会产生大量的io，导致整体性能下降；除此之外，在刷新的时候如果出现了宕机，数据也会丢失。因此采用提交事物前，先写redolog日志，然后在修改内存中的页，即使将脏页刷新到磁盘时出现宕机，也能够根据redolog日志进行恢复。而chenckpoint技术就是为了解决 1、缩短数据库的恢复时间（因为chenckpoint前的脏页都已经刷新到磁盘了，只需对chenckpoint之后的进行恢复）2、缓冲池不够时将脏页刷新到磁盘。（当缓冲池不够用时，会根据LRU算法将最近最少用的页淘汰，而淘汰时会检测是否为脏页，如果是则执行checkpoint，将脏页刷新到磁盘）3、redolog日志不够用时，刷新脏页（即redolog的大小是有限制的，chenckpont前的是可重用的，而chenckpoint之后的是需要的，如果redolog文件里面全部都是需要使用的，则必须进行checkpoint） 在innoDB中，使用LSN（八字节）标记版本，每个页都有自己的LSN，redolog日志中和checkpoint中也有。 在innoDB中存在两种checkpoint，即sharp checkpoint（默认）和fuzzy checkpoint。 sharp checkpoint发生在数据库关闭时，此时会将所有脏页刷新到磁盘（会发生迟钝） fuzzy checkpoint则是每次只刷新部分脏页到磁盘。以下是几种发生fuzzy checkpoint的情况： 1、main线程会每秒或10秒的速度从fulshList中刷新页到磁盘。 2、当缓冲池没有多余空闲空间，会根据LRU算法冲LRUList淘汰页，对于淘汰的页会检测是否是脏页，是则会刷新到磁盘。 3、当redolog不可用时会强制flushList中的脏页进行刷新 4、当脏页太多，也会强制进行checkpoint刷新脏页到磁盘。 innoDB主要工作都是在main线程中完成的，其内部由多个循环组成（主循环、后台循环、刷新循环、暂停循环），在多个循环中切换进行工作。 innoDB1.0 主循环： 后台循环： innoDB1.2基于上述IO限制，加入了innoDB_io_capacitiy用于表示IO（默认200），对于刷新的页用百分比来控制 另外一个参数是innoDB_max_dirty_pct（默认75），当脏页小于innoDB_max_dirty_pct也会刷新一定量的脏页（之前是不会刷新的）。 接下来说一说innoDB的插入缓冲。insert buffer和数据页一样，是物理页的一部分。 在innoDB中，主键是唯一标识，插入记录一般按主键递增顺序插入。因此，聚集索引一般是顺序的（比如自增id这种），对于顺序的一般插入操作速度很快，但对于主键是uuid之类则和辅助索引一样，是随机的。因此对于这种情况，按顺序插入则相对要慢得多。因此insert buffer的作用就是对于非聚集索引的插入或者更新操作先判断是否存在缓冲池，若存在则直接插入，不存在则放到insert buffer中，在以一定频率进行inser buffer和辅助索引子节点的合并，提高对于非聚集索引的插入性能。当然使用insert buffer需要满足 insert buffer数据实现是一颗b+树， change buffer：在1.0.x版本引入了channge buffer，可以对增删改都进行缓冲 两次写：当innoDB刷新某个页到磁盘中，但只刷新了部分，数据库就宕机了（部分写失效）。double write就是为了解决这种情况产生的。 double write由两部分组成。一部分时内存double write buffer（大小2mb），一部分是磁盘上的共享表空间中连续的128页（即两个区，大小为2mb）。在对脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复杂到 doublewrite buffer，然后doubllewrite buffer再分两次顺序的写到共享表空间的物理磁盘上（每次写1mb）。完成之后，在将doublewrite buffer中的页写入各个表文件空间中。如果在写入表中磁盘时发生了宕机什么的。在恢复时，可以从共享表空间中找到一个备份页，将其复制到表空间。 自适应哈希：innoDB会对表上各索引页的查询监控。如果建立哈希索引会提升性能，则建立哈希索引。而条件就是：对这个页的连续访问模式要一样。 异步IO：innoDB采用AIO的方式处理磁盘操作，可以在发起一个IO请求后，立马发起另一个IO请求，当全部发送完后，等所有请求操作完。除此之外，还可以进行IO的合并操作。 刷新邻接页：即刷新一个脏页时，会检测该页周围的页是否是脏页，是则一并刷新。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"innoDB","slug":"innoDB","permalink":"http://example.com/tags/innoDB/"}],"author":"John Doe"},{"title":"jedis和redission","slug":"jedis和redission","date":"2022-02-08T12:45:00.000Z","updated":"2022-02-08T12:46:11.557Z","comments":true,"path":"2022/02/08/jedis和redission/","link":"","permalink":"http://example.com/2022/02/08/jedis%E5%92%8Credission/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"框架实现","slug":"框架实现","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"}],"author":"John Doe"},{"title":"一致性hash算法","slug":"一致性hash算法","date":"2022-02-08T12:33:00.000Z","updated":"2022-02-08T12:34:21.071Z","comments":true,"path":"2022/02/08/一致性hash算法/","link":"","permalink":"http://example.com/2022/02/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"Redis","slug":"算法/Redis","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Redis/"}],"tags":[{"name":"一致性哈希算法","slug":"一致性哈希算法","permalink":"http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"}],"author":"John Doe"},{"title":"Redis集群的主从复制模型","slug":"Redis集群的主从复制模型","date":"2022-02-08T12:27:00.000Z","updated":"2022-02-08T12:27:38.911Z","comments":true,"path":"2022/02/08/Redis集群的主从复制模型/","link":"","permalink":"http://example.com/2022/02/08/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"主从复制模型","slug":"主从复制模型","permalink":"http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"}],"author":"John Doe"},{"title":"Redis内存优化","slug":"Redis内存优化","date":"2022-02-08T12:09:00.000Z","updated":"2022-02-08T12:10:03.147Z","comments":true,"path":"2022/02/08/Redis内存优化/","link":"","permalink":"http://example.com/2022/02/08/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"内存优化","slug":"内存优化","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"}],"author":"John Doe"},{"title":"Redis的回收进程如何工作","slug":"Redis的回收进程如何工作","date":"2022-02-08T09:37:00.000Z","updated":"2022-02-08T11:59:38.055Z","comments":true,"path":"2022/02/08/Redis的回收进程如何工作/","link":"","permalink":"http://example.com/2022/02/08/Redis%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"回收进程","slug":"回收进程","permalink":"http://example.com/tags/%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B/"}],"author":"John Doe"},{"title":"一个Redis实例能存放多少key？","slug":"一个Redis实例能存放多少key？","date":"2022-02-08T09:27:00.000Z","updated":"2022-02-08T09:28:21.147Z","comments":true,"path":"2022/02/08/一个Redis实例能存放多少key？/","link":"","permalink":"http://example.com/2022/02/08/%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91key%EF%BC%9F/","excerpt":"","text":"理论上 Redis 可以处理多达 2^32 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、和 sorted set 都可以放 2^32 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[],"author":"John Doe"},{"title":"Redis异步队列","slug":"Redis异步队列","date":"2022-02-08T08:50:00.000Z","updated":"2022-02-08T09:02:41.782Z","comments":true,"path":"2022/02/08/Redis异步队列/","link":"","permalink":"http://example.com/2022/02/08/Redis%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"异步队列","slug":"异步队列","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"}],"author":"John Doe"},{"title":"Redis分布式锁","slug":"Redis分布式锁","date":"2022-02-08T08:29:00.000Z","updated":"2022-02-08T08:30:14.720Z","comments":true,"path":"2022/02/08/Redis分布式锁/","link":"","permalink":"http://example.com/2022/02/08/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"转载自：https://www.cnblogs.com/wangyingshuo/p/14510524.html","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}],"author":"John Doe"},{"title":"如何保证Redis数据都是热点数据？","slug":"如何保证Redis数据都是热点数据？","date":"2022-02-07T10:06:00.000Z","updated":"2022-02-07T10:11:22.310Z","comments":true,"path":"2022/02/07/如何保证Redis数据都是热点数据？/","link":"","permalink":"http://example.com/2022/02/07/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%9F/","excerpt":"","text":"1.限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，加载热数据到内存。所以，计算一下 20W 数据大约占用的内存，然后设置一下 Redis 内存限制即可。 2.问题是什么数据？ 比如用户数据。数据库有2000w条。活跃用户：redis sortSet里 放两天内(为方便取一天内活跃用户)登录过的用户，登录一次ZADD一次，如set已存在则覆盖其分数（登录时间）。键：login:users，值：分数 时间戳、value userid。设置一个周期任务，比如每天03:00:00点删除sort set中前一天3点前的数据（保证set不无序增长、留近一天内活跃用户）。 取时，拿到当前时间戳（int 10位），再减1天就可按分数范围取过去24h活跃用户。 3.看你的提问,应该只是把Redis当缓存来用.提供一种简单实现缓存失效的思路: LRU(最近少用的淘汰)即redis的缓存每命中一次,就给命中的缓存增加一定ttl(过期时间)(根据具体情况来设定, 比如10分钟).一段时间后, 热数据的ttl都会较大, 不会自动失效, 而冷数据基本上过了设定的ttl就马上失效了.","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"热点数据","slug":"热点数据","permalink":"http://example.com/tags/%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/"}],"author":"John Doe"},{"title":"Redis共享整数字符串","slug":"Redis共享整数字符串","date":"2022-02-07T01:55:00.000Z","updated":"2022-02-07T01:55:23.165Z","comments":true,"path":"2022/02/07/Redis共享整数字符串/","link":"","permalink":"http://example.com/2022/02/07/Redis%E5%85%B1%E4%BA%AB%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"共享","slug":"共享","permalink":"http://example.com/tags/%E5%85%B1%E4%BA%AB/"}],"author":"John Doe"},{"title":"Redis对象内存回收","slug":"Redis对象内存回收","date":"2022-02-07T01:53:00.000Z","updated":"2022-02-07T01:53:31.910Z","comments":true,"path":"2022/02/07/Redis对象内存回收/","link":"","permalink":"http://example.com/2022/02/07/Redis%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/","excerpt":"","text":"","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"内存回收","slug":"内存回收","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"}],"author":"John Doe"},{"title":"Redis底层数据结构之对象","slug":"Redis底层数据结构之对象","date":"2022-02-07T00:49:00.000Z","updated":"2022-02-07T01:52:21.525Z","comments":true,"path":"2022/02/07/Redis底层数据结构之对象/","link":"","permalink":"http://example.com/2022/02/07/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Redis对外提供了五种数据类型，分别是String、List、HashMap、HashSet以及ZSeT，其中String作为key-value键值映射的key，以及五种value之一，而其他四种则只能作为value。并且这五种数据类型在底层实现上都至少有两种数据结构实现。 在底层上，由一个type类型表明当前数据对象属于哪个类型，由encodeing表明底层具体的数据结构实现，然后由一个指针指向底层的数据结构实现。这样的好处的话主要就是在不同的应用场景选择不同的底层数据结构实现，会大大提高redis的存储性能。 1、具体的话，String类型底层实现有：int、raw、embstr三种数据结构的实现。其中int类型的底层数据结构实现主要是用于存放整数值，当我们的value是一个整数值，就可以选择用int类型的底层实现。而raw类型的底层实现则是一个动态字符串数据结构，一般当字符串大于32字节就会使用到。embstr则是当字符串小于32字节会使用到。两者的不同在于，embstr只会进行一次内存分配和释放，而raw则会进行两次内存分配和释放；而且embstr的内存时连续的，而raw不是。 需要注意的是：double这种浮点型的数据作为value存储的时候，底层使用的是str类型的数据结构实现。另外上述三种底层数据结构实现是可以相互转换的。 2、list类型底层编码可以使ziplist和linkedlist两种类型，当list满足每个节点小于64字节并且节点数小于512个就可以采用ziplist作为底层实现，否则采用linkedlist 3、hash对象底层编码可以使ziplist和hashtable两种类型 4、set集合的编码实现可以使整数集合和hashtable 5、有序集合zset的编码实现：ziplist和skiplist。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"对象","slug":"对象","permalink":"http://example.com/tags/%E5%AF%B9%E8%B1%A1/"}],"author":"John Doe"},{"title":"Redis底层数据结构之整数集合","slug":"Redis底层数据结构之整数集合","date":"2022-02-06T13:40:00.000Z","updated":"2022-02-06T13:49:01.981Z","comments":true,"path":"2022/02/06/Redis底层数据结构之整数集合/","link":"","permalink":"http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/","excerpt":"","text":"整数集合是Redis用于保存整数值得集合数据结构，可以保存int16、int32、int64de整数值，并且有序不会重复，具体由encoding决定保存是int16、32还是64. 当将一个新元素加入整数集合时，而且这个元素类型长于当前集合类型，就会先对集合升级，然后在加入新元素。 升级： 1、根据新元素类型，开辟新的数组 2、将原数组的元素转移到新数组的正确位置上，且转化为与新数组相同的类型 3、将新元素加到新数组指定的位置 好处： 1、提升灵活性，C语言是静态类型语言，为了避免错误，不会将两种类型放在一个数据结构里面，通过底层数组升级操作，不必担心不同类型的整数出现类型错误 2、节约内存，整数集合的升级操作，确保了只在需要的时候进行，尽量节约内存。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"整数集合","slug":"整数集合","permalink":"http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"}],"author":"John Doe"},{"title":"Redis底层数据结构之跳表","slug":"Redis底层数据结构实现之跳表","date":"2022-02-06T13:13:00.000Z","updated":"2022-02-06T13:24:50.758Z","comments":true,"path":"2022/02/06/Redis底层数据结构实现之跳表/","link":"","permalink":"http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%B9%8B%E8%B7%B3%E8%A1%A8/","excerpt":"","text":"跳表支持平均o（logN）、最坏O（n）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"跳表","slug":"跳表","permalink":"http://example.com/tags/%E8%B7%B3%E8%A1%A8/"}],"author":"John Doe"},{"title":"Redis底层数据结构之字典","slug":"Redis底层实现之字典","date":"2022-02-06T12:37:00.000Z","updated":"2022-02-06T13:24:45.912Z","comments":true,"path":"2022/02/06/Redis底层实现之字典/","link":"","permalink":"http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%AD%97%E5%85%B8/","excerpt":"","text":"字典即符号表，Redis的数据库就是通过字典作为底层实现的。而字典的底层实现主要是使用hash表。 1、hash表底层实现是通过数组加链表实现的，对于一个key值，通过计算其hashcode，然后与上hash表的掩码（数组-1），得到在数组中的下标，然后同该下标上的链表进行比较（没有链表则直接加上去），看是否是同一个值，如果是，则覆盖，不是则加到链表尾。 2、字典则是一个包含两个hash表的结构体，一般情况只使用下标为0的hash表，当对0下标的hash表进行扩容时，会使用到1下标处的hash表。即当0下标处的hash表 a）满足服务器没有执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于1 b）或者满足服务器执bgsave或者bgrewriteaof命令，并且hash表负载因子大于等于5 （因为在执bgsave或者bgrewriteaof命令时，服务器在执行备份操作，为了尽可能提高其效率，避免在此期间进行hash表扩容操作） c）负载因子小于0.1会收缩 就会发生扩容，此时会渐进的将0下标的hash表的数据转移到扩容后的1下标处。（这里之所以采取渐进式的转移，主要是考虑到当hash表里面存的数据量很大时，一次性转移会很消耗时间）","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"John Doe"},{"title":"Redis底层数据结构之链表","slug":"Redis底层数据结构之链表","date":"2022-02-06T12:28:00.000Z","updated":"2022-02-06T12:35:31.761Z","comments":true,"path":"2022/02/06/Redis底层数据结构之链表/","link":"","permalink":"http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表作为一种常用数据结构，Redis也对其进行了实现。链表键、发布与订阅、慢查询、监视器等方面都用到了链表。其底层由node节点和list结构构成，node节点包含前驱和后继指针以及value值，而list结构则包含了指向投节点、尾结点的指针以及链表节点数、节点复制函数、释放函数等。即最终是一个双端无环链表。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}],"author":"John Doe"},{"title":"Redis底层数据结构之SDS","slug":"Redis底层数据结构之SDS","date":"2022-02-06T12:13:00.000Z","updated":"2022-02-06T12:36:06.134Z","comments":true,"path":"2022/02/06/Redis底层数据结构之SDS/","link":"","permalink":"http://example.com/2022/02/06/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BSDS/","excerpt":"","text":"Redis是用C语言写的，底层实现了众多数据结构，其中字符串是最常用的一种，其底层实现并不是用的C语言的char[]数组，而是进行了简单的封装sds结构体，定义了一个int的len、free和char[]来实现字符串。其相较于原生的C语言字符串有如下优点： 1、可以通过len-free以常数阶获取字符串长度 2、可以通过free字段避免缓冲区出现溢出的情况 3、同时也减少字符串修改时，内存重新分配的次数，其具体实现是通过预先分配内存（即当追加字符串之后，字符串小于1MB，会多分配一倍的空间）和懒惰回收（即当字符串变短之后，不会立即回收那一部分空间，而是作为临时空间供后续字符串扩增做优化） 4、可以保存二进制安全的数据","categories":[{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"John Doe"},{"title":"枚举单例模式如何防止反射和反序列化","slug":"枚举单例模式如何防止反射和反序列化","date":"2022-01-27T11:08:00.000Z","updated":"2022-01-27T11:16:11.794Z","comments":true,"path":"2022/01/27/枚举单例模式如何防止反射和反序列化/","link":"","permalink":"http://example.com/2022/01/27/%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"1、 2、枚举单例在创建时不存在并发问题： 枚举类里的各个枚举项是是通过static代码块来定义和初始化的，它们会在类被加载时完成初始化，而java类的加载由JVM保证线程安全，所以，创建一个Enum类型的枚举是线程安全的 2、反序列化： Java对枚举的序列化作了规定，在序列化时，仅将枚举对象的name属性输出到结果中，在反序列化时，就是通过java.lang.Enum的valueOf来根据名字查找对象，而不是新建一个新的对象。枚举在序列化和反序列化时，并不会调用构造方法，这就防止了反序列化导致的单例破坏的问题。 3、反射： 反射在通过newInstance创建对象时，会检查这个类是否是枚举类，如果是，会抛出异常java.lang.IllegalArgumentException: Cannot reflectively create enum objects，表示反射创建对象失败。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"单利模式防止反射创建新的实例","slug":"单利模式防止反射创建新的实例","date":"2022-01-27T09:47:00.000Z","updated":"2022-01-27T09:49:12.324Z","comments":true,"path":"2022/01/27/单利模式防止反射创建新的实例/","link":"","permalink":"http://example.com/2022/01/27/%E5%8D%95%E5%88%A9%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"方法一（饿汉式）：在私有的构造器里面增加判断，如果不为空，抛出异常之类 方法二（懒汉式）：可以增加一个静态变量，然后在类初始化的时候将静态变量修改值，然后在构造器内判断静态变量的值来做相应的操作","categories":[],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"如果实现了序列化接口, 还要做什么来防止反序列化破坏单例","slug":"：如果实现了序列化接口-还要做什么来防止反序列化破坏单例","date":"2022-01-27T09:40:00.000Z","updated":"2022-01-27T09:47:09.071Z","comments":true,"path":"2022/01/27/：如果实现了序列化接口-还要做什么来防止反序列化破坏单例/","link":"","permalink":"http://example.com/2022/01/27/%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3-%E8%BF%98%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/","excerpt":"","text":"在类中添加如下方法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[],"author":"John Doe"},{"title":"Redis开发运维实践指南笔记","slug":"Redis开发运维实践指南笔记","date":"2022-01-26T14:10:01.000Z","updated":"2022-01-26T14:25:32.547Z","comments":true,"path":"2022/01/26/Redis开发运维实践指南笔记/","link":"","permalink":"http://example.com/2022/01/26/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1、Redis为一个运行在内存中的数据结构服务器（data structures server）。Redis使用的是单进程（除持久化时），所以在配置时，一个实例只会用到一个CPU。 2、 3、列出key： 渐进的遍历整个数据库：keys命令会一次性遍历整个数据库获取与之匹配的键，当数据库包含得键值越来越多，这个命令会愈来愈慢，因此，可以用scan命令渐进的，分多次遍历整个数据库 4、 5、","categories":[],"tags":[],"author":"John Doe"},{"title":"交替打印输出","slug":"交替打印输出","date":"2022-01-26T12:59:00.000Z","updated":"2022-01-26T13:00:45.447Z","comments":true,"path":"2022/01/26/交替打印输出/","link":"","permalink":"http://example.com/2022/01/26/%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA/","excerpt":"","text":"三个线程交替打印输出 public class AlternateOutput &#123; public static void main(String[] args) &#123; // Test1 test1 = new Test1(); // new Thread(()-&gt;&#123; // try &#123; // test1.print(1); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;).start(); // new Thread(()-&gt;&#123; // try &#123; // test1.print(2); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;).start(); // new Thread(()-&gt;&#123; // try &#123; // test1.print(3); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;).start(); // Test2 test2 = new Test2(); // Thread t1 = new Thread(()-&gt;&#123; // try &#123; // test2.print(&quot;a&quot;); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;); // Thread t2 = new Thread(()-&gt;&#123; // try &#123; // test2.print(&quot;b&quot;); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;); // Thread t3 = new Thread(()-&gt;&#123; // try &#123; // test2.print(&quot;c&quot;); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125; // &#125;); // test2.setThreads(t1,t2,t3); // test2.start(); Test3 test3 = new Test3(); Condition condition1 = test3.newCondition(); Condition condition2 = test3.newCondition(); Condition condition3 = test3.newCondition(); new Thread(()-&gt;&#123; test3.print(&quot;a&quot;,condition1,condition2); &#125;).start(); new Thread(()-&gt;&#123; test3.print(&quot;b&quot;,condition2,condition3); &#125;).start(); new Thread(()-&gt;&#123; test3.print(&quot;c&quot;,condition3,condition1); &#125;).start(); test3.start(condition1); &#125; &#125; class Test1&#123; private Integer flag = 1; private Integer num = 10; public void print(int curFlag) throws InterruptedException &#123; for (int i=0; i&lt;num; ++i)&#123; synchronized (this)&#123; while (this.flag != curFlag)&#123; this.wait(); &#125; System.out.println(curFlag); this.flag = curFlag % 3 + 1; this.notifyAll(); &#125; &#125; &#125; &#125; class Test2&#123; private Thread[] threads; private Integer num = 10; public Test2(Thread... threads) &#123; this.threads = threads; &#125; public void setThreads(Thread... threads) &#123; this.threads = threads; &#125; public void print(String s) throws InterruptedException &#123; for (int i=0;i&lt;num;++i)&#123; LockSupport.park(); System.out.println(s); LockSupport.unpark(getNextThread()); &#125; &#125; public Thread getNextThread()&#123; int size = threads.length; Thread cur = Thread.currentThread(); for (int i=0;i&lt;size;++i)&#123; if (cur == threads[i])&#123; return threads[(i + 1) % size]; &#125; &#125; return null; &#125; public void start() &#123; for (Thread thread: threads)&#123; thread.start(); &#125; LockSupport.unpark(threads[0]); &#125; &#125; class Test3 extends ReentrantLock&#123; private int num = 10; public void start(Condition condition)&#123; this.lock(); try &#123; condition.signal(); &#125;finally &#123; this.unlock(); &#125; &#125; public void print(String s, Condition cur,Condition next)&#123; for (int i=0;i&lt;num;++i)&#123; this.lock(); try&#123; cur.await(); System.out.println(s); next.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; this.unlock(); &#125; &#125; &#125; &#125;","categories":[],"tags":[],"author":"John Doe"},{"title":"synchronized锁静态变量Integer","slug":"synchronized锁静态变量Integer","date":"2022-01-25T02:18:00.000Z","updated":"2022-01-25T02:22:28.673Z","comments":true,"path":"2022/01/25/synchronized锁静态变量Integer/","link":"","permalink":"http://example.com/2022/01/25/synchronized%E9%94%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8FInteger/","excerpt":"","text":"当我尝试用synchronized去锁一个Integer的静态变量时，在多线程下发生了线程不安全问题，原因是synchronized锁住的Integer静态变量在不断发生变化，即i++会不断创建新的Integer，然后致使多线程下锁的不是一个对象，锁无效（以下代码在-128~127之间是有效的，因为存在Integer缓存问题）。 public class Main &#123; private static Integer i = 0; public static void main(String[] args) throws InterruptedException &#123; List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 2; j++) &#123; Thread thread = new Thread(() -&gt; &#123; for (int k = 0; k &lt; 127; k++) &#123; synchronized (i) &#123; i++; &#125; &#125; &#125;, &quot;&quot; + j); list.add(thread); &#125; list.stream().forEach(t -&gt; t.start()); list.stream().forEach(t -&gt; &#123; try &#123; t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(i); &#125; &#125;","categories":[{"name":"juc","slug":"juc","permalink":"http://example.com/categories/juc/"}],"tags":[{"name":"synchronized","slug":"synchronized","permalink":"http://example.com/tags/synchronized/"}],"author":"John Doe"},{"title":"终止模式之两阶段终止模式（Interrupt）","slug":"终止模式之两阶段终止模式","date":"2022-01-24T11:10:00.000Z","updated":"2022-01-24T11:20:45.418Z","comments":true,"path":"2022/01/24/终止模式之两阶段终止模式/","link":"","permalink":"http://example.com/2022/01/24/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"Thread类中的stop（）方法可以用于终止一个线程，但这个方法要求立即终止，被终止的线程没有机会料理后事。因此，这里采用终止模式中的两阶段终止模式来优雅的结束一个线程，给被终止的线程一个料理后事的机会。（如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛InterruptedException，并清除 打断标记如果打断的正在运行的线程，则会设置打断标记 ；park的线程被打断，也会设置 打断标记） public class TPTInterrupt &#123; public static void main(String[] args) throws InterruptedException &#123; TPTInterrupt tptInterrupt = new TPTInterrupt(); tptInterrupt.start(); Thread.sleep(2000); tptInterrupt.stop(); &#125; private Thread thread; public void start()&#123; thread = new Thread(()-&gt;&#123; while (true)&#123; Thread thread = Thread.currentThread(); if (thread.isInterrupted())&#123; System.out.println(&quot;料理后事...&quot;); break; &#125; try &#123; Thread.sleep(1000); System.out.println(&quot;运行中...&quot;); &#125; catch (InterruptedException e) &#123; // 标记打断 e.printStackTrace(); thread.interrupt(); &#125; &#125; &#125;); thread.start(); &#125; public void stop()&#123; thread.interrupt(); &#125; &#125;","categories":[{"name":"juc","slug":"juc","permalink":"http://example.com/categories/juc/"},{"name":"设计模式","slug":"juc/设计模式","permalink":"http://example.com/categories/juc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"终止模式","slug":"终止模式","permalink":"http://example.com/tags/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"创建线程的方式","slug":"创建线程的方式","date":"2022-01-24T11:02:00.000Z","updated":"2022-01-24T11:06:46.136Z","comments":true,"path":"2022/01/24/创建线程的方式/","link":"","permalink":"http://example.com/2022/01/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1、创建Thread对象 2、使用Runnable配合Thread使用 3、FutureTask配合Callable和Thread使用","categories":[],"tags":[{"name":"创建线程","slug":"创建线程","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"}],"author":"John Doe"},{"title":"为什么要自定义类型加载器？","slug":"为什么要自定义类型加载器？","date":"2022-01-23T11:19:00.000Z","updated":"2022-01-23T11:20:52.309Z","comments":true,"path":"2022/01/23/为什么要自定义类型加载器？/","link":"","permalink":"http://example.com/2022/01/23/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F/","excerpt":"","text":"1、隔离加载类：在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。(类的仲裁 –&gt; 类冲突) 2、修改类加载的方式：类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点按需进行动态加载 3、扩展加载源：比如从数据库、网络、甚至是电视机机顶盒进行加载 4、防止源码泄露：Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[],"author":"John Doe"},{"title":"沙箱安全机制","slug":"沙箱安全机制","date":"2022-01-23T11:16:00.000Z","updated":"2022-01-23T11:19:08.964Z","comments":true,"path":"2022/01/23/沙箱安全机制/","link":"","permalink":"http://example.com/2022/01/23/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/","excerpt":"","text":"沙箱安全机制就是将java代码限定在jvm特定的运行范围，并且严格限制代码对本地资源的访问，本地系统造成破坏。","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[],"author":"John Doe"},{"title":"判定一个类型是否属于\"不再被使用的类\"的条件","slug":"判定一个类型是否属于-不再被使用的类-的条件","date":"2022-01-23T09:49:00.000Z","updated":"2022-01-23T09:50:58.551Z","comments":true,"path":"2022/01/23/判定一个类型是否属于-不再被使用的类-的条件/","link":"","permalink":"http://example.com/2022/01/23/%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E-%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB-%E7%9A%84%E6%9D%A1%E4%BB%B6/","excerpt":"","text":"1、该类所有的实例都被回收，即java堆中不存在该类的实例或其子类实例对象 2、加载该类的类加载器被回收 3、该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"},{"name":"jvm","slug":"jv-m/jvm","permalink":"http://example.com/categories/jv-m/jvm/"}],"tags":[],"author":"John Doe"},{"title":"类的初始化情况：主动使用vs被动使用","slug":"类的初始化情况：主动使用vs被动使用","date":"2022-01-23T09:31:00.000Z","updated":"2022-01-23T09:43:56.451Z","comments":true,"path":"2022/01/23/类的初始化情况：主动使用vs被动使用/","link":"","permalink":"http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8vs%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/","excerpt":"","text":"主动使用：类只有在首次主动使用时才会被加载，而在首次使用被加载时，必须进行初始化。 以下使用被认为是主动使用：1、当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化 2、当调用类的静态方法时，即当使用了字节码 invokestatic 指令 3、当使用类、接口的静态字段时(final 修饰特殊考虑)，比如，使用 getstatic 或者 putsttic 指令。(对应访问变量、赋值变量操作) 4、当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forname(“com.atguigu.java.Test”) 5、当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 6、如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化 7、当虚拟机启动时，用户需要指定一个要执行的主类(包含 main() 方法的那个类)，虚拟机会先初始化这个主类 8、当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。(涉及解析 REF_getStatic、REF_putStatic、REF_invokeStatic 方法句柄对应的类) 注意：1、当Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口在初始化一个类时，并不会先初始化它所实现的接口在初始化一个接口时，并不会先初始化它的父接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化2、JVM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[]) 方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载、链接和初始化 被动使用：除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。 1、当访问一个静态字段时，只有真正声明这个字段的类才会被初始化 2、当通过子类引用父类的静态变量，不会导致子类初始化 3、通过数组定义类引用，不会触发此类的初始化 4、引用变量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了 5、调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[{"name":"类初始化：主动使用与被动使用","slug":"类初始化：主动使用与被动使用","permalink":"http://example.com/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"}],"author":"John Doe"},{"title":"类的加载过程","slug":"类的加载过程","date":"2022-01-23T07:55:00.000Z","updated":"2022-01-23T08:54:30.085Z","comments":true,"path":"2022/01/23/类的加载过程/","link":"","permalink":"http://example.com/2022/01/23/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类的加载，我的理解就是将类的二进制字节码文件加载到内存中，并通过解析字节码中的常量池、类字段、类方法等信息，在jvm方法区中构建出该类的模板，并在堆区创建一个对象实例作为方法区这个类的各种数据访问入口，在jvm运行期间能够通过这个类的模板信息来调用类的静态变量、方法等。其加载过程的话，主要分为加载、链接（验证、准备、解析）、初始化三个步骤。 1、首先加载，就是查找类的全限定类名，将类的二进制字节码文件加载到jvm的内存中，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，并为之在堆区创建一个实例对象，作为方法区这个类的数据访问入口。当然，在加载前还需要进行验证操作，即检查字节码文件格式，看是否遵循jvm的规范。比如是否以魔数开头等。验证通过后，该类的二进制信息便会被加载到内存。 2、加载到方法区后需要验证，即检查类的语义、字节码验证、符号引用验证，看是否符合规范。 3、当验证完毕之后，就开始准备阶段，这一步主要是对类的静态变量分配内存并附上默认值。（注意：final修饰的静态变量在编译阶段就会分配，准备阶段是显示赋值，并且此阶段也不会为实例变量分配初始化） 4、然后便是解析阶段，即将符号引用转变为直接引用，得到类、字段、方法等在内存中的指针或者偏移量。 5、最后便是初始化，这个阶段主要是为类的静态变量进行显示赋值。即执行类构造器cinit方法。即执行类变量的赋值动作和静态语句块(static{}块)，虚期机会保证在子类的()方法执行之前, 父类的()方法已经执行完毕。如果一个类中没有静态语句块,也没有对变量的赋值操作, 那么编译器可以不为这个类生成()方法。 需要注意的是：接口与类不同的是, 执行接口的()方法不需要先执行父接口的()方法。只有当父接口中定义的变量被使用时, 父接口才会被初始化。 另外, 接口的实现类在初始化时也一样不会执行接口的()方法。另外，虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()法,其他线程部需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作, 那就可能造成多个进程阻塞, 在实际应用中这种阻塞往往是隐蔽的。","categories":[{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"}],"tags":[{"name":"类的加载过程","slug":"类的加载过程","permalink":"http://example.com/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"}],"author":"John Doe"},{"title":"关于集合类中的modCount++","slug":"关于集合类中的modCount","date":"2022-01-21T06:45:00.000Z","updated":"2022-01-21T07:17:15.741Z","comments":true,"path":"2022/01/21/关于集合类中的modCount/","link":"","permalink":"http://example.com/2022/01/21/%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%AD%E7%9A%84modCount/","excerpt":"","text":"话不多说，直接看源码注释讲解 由上图可知，该字段目的在于记录集合结构被修改的次数（增、删、改），该字段被迭代器所使用，当对集合进行迭代遍历时，防止数据发生改变引起错误。因此，当我们使用迭代器时，如果该值被改了，就会触发fast-fail机制，抛出异常ConcurrentModificationExceptions。","categories":[{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"},{"name":"java","slug":"集合/java","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/java/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"http://example.com/tags/ArrayList/"}],"author":"John Doe"},{"title":"HashMap1.7","slug":"HashMap","date":"2022-01-18T11:27:00.000Z","updated":"2022-01-18T11:53:34.793Z","comments":true,"path":"2022/01/18/HashMap/","link":"","permalink":"http://example.com/2022/01/18/HashMap/","excerpt":"","text":"HashMap1.7底层由数组+链表实现，提供的无参构造方法默认数组容量是16，加载因子是0.75，临界值为16 * 0.75 = 12，当到了临界值则进行扩容。 你也可以通过有参构造方法指定容量和加载因子。 注意，不管有参无参此时都还未初始化数组，只是定义了数组容量。当我们第一次put往hashmap的放数据的时候才会初始化 而此时初始化会根据我们最初的容量大小进行初始化，大小为大于等于当前容量的2的幂。 然后便是计算hash值，根据hash值得到数组下标，根据下标到指定位置，如果发送hash冲突则通过拉链法，将冲突元素头插进链表","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"}],"author":"John Doe"},{"title":"ArrayList","slug":"ArrayList","date":"2022-01-17T12:13:00.000Z","updated":"2022-01-17T12:20:04.535Z","comments":true,"path":"2022/01/17/ArrayList/","link":"","permalink":"http://example.com/2022/01/17/ArrayList/","excerpt":"","text":"ArrayList 1、ArrayList底层默认是用object数组实现的，因此在增删元素上需要移动元素，效率较低，但支持随机访问元素 2、ArrayList是线层不安全的，并发环境下，多个线程同时操作 ArrayList，会引发不可预知的异常或错误。 3、ArrayList的默认的大小是10。一开始是空数组，当第一次add的时候才会扩容到10，后续容器满了之后会按1.5倍进行扩容。如果一开始指定容器大小，后续则直接按1.5倍进行扩容。最大扩容不超过Integer.MAX_VALUE","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"}],"author":"John Doe"},{"title":"成员变量与局部变量","slug":"成员变量与局部变量","date":"2022-01-16T11:20:00.000Z","updated":"2022-01-16T11:22:59.161Z","comments":true,"path":"2022/01/16/成员变量与局部变量/","link":"","permalink":"http://example.com/2022/01/16/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F/","excerpt":"","text":"从语法形式上看:成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。2. 从变量在内存中的存储⽅式来看:如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。3. 从变量在内存中的⽣存时间上看:成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。4. 成员变量如果没有被赋初值:则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[],"author":"John Doe"},{"title":"接口和抽象类的区别","slug":"接口和抽象类的区别","date":"2022-01-16T10:39:00.000Z","updated":"2022-01-16T11:17:43.700Z","comments":true,"path":"2022/01/16/接口和抽象类的区别/","link":"","permalink":"http://example.com/2022/01/16/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"接⼝的⽅法默认是 public ，所有⽅法在接⼝中不能有实现(Java 8 开始接⼝⽅法可以有默认实现），⽽抽象类可以有⾮抽象的⽅法。 接⼝中除了 static 、 final 变量，不能有其他变量，⽽抽象类中则不⼀定。 ⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 extends 关键字扩展多个接⼝。 接⼝⽅法默认修饰符是 public ，抽象⽅法可以有 public 、 protected 和 default 这些修饰符（抽象⽅法就是为了被重写所以不能使⽤ private 关键字修饰！）。 从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的规范。备注： 在 JDK8 中，接⼝也可以定义静态⽅法，可以直接⽤接⼝名调⽤。实现类和实现是不可以调⽤的。如果同时实现两个接⼝，接⼝中定义了⼀样的默认⽅法，则必须重写，不然会报错。 jdk9 的接⼝被允许定义私有⽅法 。总结⼀下 jdk7~jdk9 Java 中接⼝概念的变化： 在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实现接⼝的类实现。 jdk 8 的时候接⼝可以有默认⽅法和静态⽅法功能。 Jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"接口","slug":"接口","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3/"}],"author":"John Doe"},{"title":"在 Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤","slug":"在-Java-中定义⼀个不做事且没有参数的构造⽅法的作⽤","date":"2022-01-16T10:34:00.000Z","updated":"2022-01-16T10:34:43.521Z","comments":true,"path":"2022/01/16/在-Java-中定义⼀个不做事且没有参数的构造⽅法的作⽤/","link":"","permalink":"http://example.com/2022/01/16/%E5%9C%A8-Java-%E4%B8%AD%E5%AE%9A%E4%B9%89%E2%BC%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E7%9A%84%E4%BD%9C%E2%BD%A4/","excerpt":"","text":"Java 程序在执⾏⼦类的构造⽅法之前，如果没有⽤ super() 来调⽤⽗类特定的构造⽅法，则会调⽤⽗类中“没有参数的构造⽅法”。因此，如果⽗类中只定义了有参数的构造⽅法，⽽在⼦类的构造⽅法中⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为 Java 程序在⽗类中找不到没有参数的构造⽅法可供执⾏。解决办法是在⽗类⾥加上⼀个不做事且没有参数的构造⽅法。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[],"author":"John Doe"},{"title":"重载和重写的区别","slug":"重载和重写的区别","date":"2022-01-16T10:05:00.000Z","updated":"2022-01-16T10:25:19.715Z","comments":true,"path":"2022/01/16/重载和重写的区别/","link":"","permalink":"http://example.com/2022/01/16/%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"重载：在一个java类中，有多个方法同名，签名不同（即不同的参数数量、顺序以及类型）的函数，就发生了重载。 重写：子类继承了父类然后重写了父类中的方法（保持和父类方法的返回值类型、函数名、签名等都不变，只是在函数体中的代码实现逻辑改变了） 注意：重写时，子类抛出的异常范围应小于等于父类，访问修饰变量范围应大于等于父类。如果父类方法被final、static、private修饰则子类不能重写父类方法，但被static修饰的方法可以再次声明。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"重写","slug":"重写","permalink":"http://example.com/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"http://example.com/tags/%E9%87%8D%E8%BD%BD/"}],"author":"ATAO"},{"title":"Java中的基本数据类型","slug":"Java中的基本数据类型","date":"2022-01-15T10:31:00.000Z","updated":"2022-01-15T10:35:39.104Z","comments":true,"path":"2022/01/15/Java中的基本数据类型/","link":"","permalink":"http://example.com/2022/01/15/Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"java中的基本数据类型有byte（1字节）、short（2字节）、int（四字节）、long（8字节）、float（4字节）、double（8字节）、boolean（1位）、char（2字节）","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}],"author":"ATAO"},{"title":"final、finalize()、finally","slug":"final、finalize-、finally","date":"2022-01-11T01:48:00.000Z","updated":"2022-01-11T02:27:34.968Z","comments":true,"path":"2022/01/11/final、finalize-、finally/","link":"","permalink":"http://example.com/2022/01/11/final%E3%80%81finalize-%E3%80%81finally/","excerpt":"","text":"1、final：在java中，final主要用于修饰类、方法和变量。 1.1 修饰类：用final修饰类时，表明这个类不能被其他类所继承。 注意：当用final对类进行修饰的时候，类中所有成员方法默认是final方法。 1.2 修饰方法：用fianl修饰方法时，表明这个方法不能被其子类重写。 1.3 修饰变量：用final修饰变量的话表明这个变量是一个常量，只能被赋值一次，赋值后其值不能够修改。 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化（）；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。 final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。 扩展：在java中，String被设计成final类，那为什么平时使用时，String的值可以被改变呢？ 字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。当我们对String对象值改变的时候，例如 String a=&quot;A&quot;; a=&quot;B&quot; 。a是String对象的一个引用（我们这里所说的String对象其实是指字符串常量），当a=“B”执行时，并不是原本String对象(&quot;A&quot;)发生改变，而是创建一个新的对象(&quot;B&quot;)，令a引用它。 2、finally：finally作为异常处理的一部分，它用在try/catch语句中，经常被用在需要释放资源的情况下。 注意： 1、只有与finally对应的try语句块得到执行的情况下，finally语句块才会执行。 2、在 try 语句块中执行了 System.exit (0) 语句，终止了 Java 虚拟机的运行或者在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed）等情况finally也可能不会执行。 易错点： 答案：4 4 4 原因：finally语句在return之前执行。 3、finalize：finalize()是在java.lang.Object里定义的，每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。 注意：一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。 所以，推荐不要使用finalize()方法，它跟析构函数不一样。","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"final、finally、fi'nalize","slug":"final、finally、fi-nalize","permalink":"http://example.com/tags/final%E3%80%81finally%E3%80%81fi-nalize/"}],"author":"ATAo"},{"title":"为什么Integer 100==100 为true，而Integer 1000==1000为false？","slug":"为什么Integer-100-100-为true，而Integer-1000-1000为false？","date":"2022-01-08T13:39:00.000Z","updated":"2022-01-08T14:19:54.922Z","comments":true,"path":"2022/01/08/为什么Integer-100-100-为true，而Integer-1000-1000为false？/","link":"","permalink":"http://example.com/2022/01/08/%E4%B8%BA%E4%BB%80%E4%B9%88Integer-100-100-%E4%B8%BAtrue%EF%BC%8C%E8%80%8CInteger-1000-1000%E4%B8%BAfalse%EF%BC%9F/","excerpt":"","text":"在java的Integer包装类中为什么Integer a = 100, b = 100,c = 1000,d =1000，令a==b为true，而c==d为false呢？ 首先在上面的代码中，Integer a = 100会调用Integer的Integer.valueOf(int i)这个方法，而这个方法的源代码如下： 我们会发现在将int类型装箱时做了一个判断语句 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) 这句话是什么意思呢？通过注释可以知道，在将一个int类型装箱为Integer类型时，总会优先调用此方法。其存在一个-128到127范围的缓存，如果int类型时该范围内，则直接返回缓存中的值，不需要额外创建Integer类型，这样可以产生显著更好的空间和时间性能。而且其范围也是可以设置。 所有我们可以知道，在执行Integer a = 100，b = 100时，走了缓存，因此b的地址同a应该一样，而c = 1000, d = 1000并为走缓存，而是走的new Interger(i)，因此创建了两个对象。 而我们知道，==比较走的是比较对象的地址。因此才会有为什么Integer 100==100 为true，而Integer 1000==1000为false。 debug如下：","categories":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://example.com/tags/Integer/"}],"author":"ATAO"},{"title":"快速选择","slug":"快速选择","date":"2022-01-08T06:04:00.000Z","updated":"2022-01-08T06:08:50.171Z","comments":true,"path":"2022/01/08/快速选择/","link":"","permalink":"http://example.com/2022/01/08/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/","excerpt":"","text":"快速选择，适用于寻找无序数组中第k大（小）或者前k大（小）这种情况，即TopK问题，是快速排序的一种变化。 class Solution &#123; public static int[] getLeastNumbers(int[] arr, int k) &#123; return quickSelect(arr,k,0,arr.length-1); &#125; private static int[] quickSelect(int[] arr,int k,int l, int r)&#123; if (arr.length &lt;= k)&#123; return arr; &#125; int index = quickSort(arr,l,r); if (index == k)&#123; return Arrays.copyOf(arr,index); &#125;else if (index &lt; k)&#123; return quickSelect(arr,k,index+1,r); &#125;else &#123; return quickSelect(arr,k,l,index-1); &#125; &#125; private static int quickSort(int[] arr, int l, int r) &#123; int mid = l ,i = l, j = r; while (i &lt; j)&#123; while (i&lt;j &amp;&amp; arr[j] &gt;= arr[mid])&#123; --j; &#125; if(i&lt;j &amp;&amp; arr[j] &lt; arr[mid])&#123; swap(arr,j,mid); mid = j; &#125; // p(arr); while (i&lt;j &amp;&amp; arr[i] &lt;= arr[mid])&#123; ++i; &#125; if(i&lt;j &amp;&amp; arr[i] &gt; arr[mid])&#123; swap(arr,i,mid); mid = i; &#125; // p(arr); &#125; swap(arr,i,mid); return mid; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; public static void p(int[] arr)&#123; for (int n:arr)&#123; System.out.print(n+&quot; &quot;); &#125; System.out.println(); &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速选择","slug":"快速选择","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"},{"name":"Top","slug":"Top","permalink":"http://example.com/tags/Top/"}],"author":"ATAO"},{"title":"快速排序","slug":"快速排序","date":"2022-01-08T05:41:00.000Z","updated":"2022-01-08T05:48:02.025Z","comments":true,"path":"2022/01/08/快速排序/","link":"","permalink":"http://example.com/2022/01/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"原理： 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它左边，所有比它大的数都放到它右边，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]的值交换； 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]的值交换； 5）重复第3、4步，直到i==j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 代码： public class QuickSort &#123; public static void main(String[] args) &#123; int k = 3; int[] arr = &#123;5,3,7,6,4,1,0,2,9,10,8&#125;; quickSort(arr,0,arr.length-1); p(arr); &#125; private static int[] quickSort(int[] arr,int l, int r) &#123; if (l&gt;r) return null; int mid = l ,i = l, j = r; while (i &lt; j)&#123; while (i&lt;j &amp;&amp; arr[j] &gt;= arr[mid])&#123; --j; &#125; if(i&lt;j &amp;&amp; arr[j] &lt; arr[mid])&#123; swap(arr,j,mid); mid = j; &#125; p(arr); while (i&lt;j &amp;&amp; arr[i] &lt;= arr[mid])&#123; ++i; &#125; if(i&lt;j &amp;&amp; arr[i] &gt; arr[mid])&#123; swap(arr,i,mid); mid = i; &#125; p(arr); &#125; System.out.println(&quot;=========&quot;+i); swap(arr,i,mid); mid = i; quickSort(arr,mid+1,r); quickSort(arr,l,mid-1); return arr; &#125; private static void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; public static void p(int[] arr)&#123; for (int n:arr)&#123; System.out.print(n+&quot; &quot;); &#125; System.out.println(); &#125; }","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快速排序","slug":"快速排序","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"}],"author":"John Doe"},{"title":"进程通信的方式","slug":"有了for循环，为什么还需要forEach？","date":"2022-01-07T12:48:00.000Z","updated":"2022-01-07T12:59:11.982Z","comments":true,"path":"2022/01/07/有了for循环，为什么还需要forEach？/","link":"","permalink":"http://example.com/2022/01/07/%E6%9C%89%E4%BA%86for%E5%BE%AA%E7%8E%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81forEach%EF%BC%9F/","excerpt":"","text":"在操作系统中，进程是资源分配的基本单位，进程间如果要实现通信，有共享存储、消息传递、管道以及socket这几种方式。 共享存储： 1、基于数据结构的共享：比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种低级通信方式。 2、基于存储区的共享：在内存中画出一块共享存 储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速 度更快，是一种高级通信方式。 管道通信： 1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置 两个管道。 2. 各进程要互斥地访问管道。 3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据 取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。 4. 如果没写满，就不允许读。如果没读空，就不允许写。 5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情 况。 消息传递： 1、直接传递：发送到接收方的接受缓冲队列上 2、间接传递：设置一个接受中转信箱，发送方发送的消息发送到信箱，接收方接受消息从信箱中取 socket：借助于网络通信，从一个主机的进程发送消息到另一个主机上的进程。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"ATAO"},{"title":"单例模式","slug":"单例模式","date":"2022-01-05T08:04:00.000Z","updated":"2022-01-05T08:05:34.618Z","comments":true,"path":"2022/01/05/单例模式/","link":"","permalink":"http://example.com/2022/01/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例模式，即java类不对外提供构造方法，在类加载的时候创建一个实例化的对象，或者提供一个方法，在方法中作出限制，保证例化对象的创建全局只有唯一一个。其好处在于可以节约系统资源，在资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。在控制资源的情况下，方便资源之间的互相通信。如线程池等。一般可以用于网站的计数器、web应用的日志、配置对象的读取、打印机、任务管理器、数据库连接池。其具体代码实现可以分为饿汉式和懒汉式。 /** 饿汉式 /public class Singleton01 { public static final Singleton01 instance = new Singleton01(); private Singleton01(){ }}/** 饿汉式 /public class Singleton02 { public static final Singleton02 instance; static { instance = new Singleton02(); } private Singleton02(){ } }/** 饿汉式 /public enum Singleton03 { INSTANCE}/** 懒汉式: 存在线程安全问题 /public class Singleton04 { private static Singleton04 instance; private Singleton04(){ } public static Singleton04 getInstance(){ if (instance == null)&#123; instance = new Singleton04(); &#125; return instance; }}/** 懒汉式: 解决线程安全问题 /public class Singleton05 { private volatile static Singleton05 instance; private Singleton05(){ } public static Singleton05 getInstance(){ if (instance == null)&#123; synchronized (Singleton05.class)&#123; instance = new Singleton05(); &#125; &#125; return instance; }}/** 懒汉式: 内部类 /public class Singleton06 { private Singleton06(){ } private static class Inner{ private static final Singleton06 instance = new Singleton06(); } public static Singleton06 getInstance(){ return Inner.instance; }}","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"http://example.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"John Doe"},{"title":"Hello World","slug":"hello-world","date":"2022-01-05T06:09:04.194Z","updated":"2022-01-05T06:09:04.194Z","comments":true,"path":"2022/01/05/hello-world/","link":"","permalink":"http://example.com/2022/01/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"},{"name":"Spring ","slug":"Spring/Spring","permalink":"http://example.com/categories/Spring/Spring/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Redis","slug":"Redis","permalink":"http://example.com/categories/Redis/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"Redis","slug":"算法/Redis","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/Redis/"},{"name":"juc","slug":"juc","permalink":"http://example.com/categories/juc/"},{"name":"设计模式","slug":"juc/设计模式","permalink":"http://example.com/categories/juc/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"jv'm","slug":"jv-m","permalink":"http://example.com/categories/jv-m/"},{"name":"jvm","slug":"jv-m/jvm","permalink":"http://example.com/categories/jv-m/jvm/"},{"name":"集合","slug":"集合","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/"},{"name":"java","slug":"集合/java","permalink":"http://example.com/categories/%E9%9B%86%E5%90%88/java/"},{"name":"java基础","slug":"java基础","permalink":"http://example.com/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"java/设计模式","permalink":"http://example.com/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"scop","slug":"scop","permalink":"http://example.com/tags/scop/"},{"name":"FactoryBean","slug":"FactoryBean","permalink":"http://example.com/tags/FactoryBean/"},{"name":"scope","slug":"scope","permalink":"http://example.com/tags/scope/"},{"name":"BeanFactory","slug":"BeanFactory","permalink":"http://example.com/tags/BeanFactory/"},{"name":"IOC","slug":"IOC","permalink":"http://example.com/tags/IOC/"},{"name":"IoC Service Provider","slug":"IoC-Service-Provider","permalink":"http://example.com/tags/IoC-Service-Provider/"},{"name":"IOC的理解","slug":"IOC的理解","permalink":"http://example.com/tags/IOC%E7%9A%84%E7%90%86%E8%A7%A3/"},{"name":"注入方式","slug":"注入方式","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"},{"name":"索引","slug":"索引","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95/"},{"name":"行结构","slug":"行结构","permalink":"http://example.com/tags/%E8%A1%8C%E7%BB%93%E6%9E%84/"},{"name":"行","slug":"行","permalink":"http://example.com/tags/%E8%A1%8C/"},{"name":"TCP","slug":"TCP","permalink":"http://example.com/tags/TCP/"},{"name":"最左匹配原则","slug":"最左匹配原则","permalink":"http://example.com/tags/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"},{"name":"性能","slug":"性能","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD/"},{"name":"主键","slug":"主键","permalink":"http://example.com/tags/%E4%B8%BB%E9%94%AE/"},{"name":"http","slug":"http","permalink":"http://example.com/tags/http/"},{"name":"get","slug":"get","permalink":"http://example.com/tags/get/"},{"name":"post","slug":"post","permalink":"http://example.com/tags/post/"},{"name":"代理模式","slug":"代理模式","permalink":"http://example.com/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"锁","slug":"锁","permalink":"http://example.com/tags/%E9%94%81/"},{"name":"表","slug":"表","permalink":"http://example.com/tags/%E8%A1%A8/"},{"name":"文件","slug":"文件","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6/"},{"name":"innoDB","slug":"innoDB","permalink":"http://example.com/tags/innoDB/"},{"name":"框架实现","slug":"框架实现","permalink":"http://example.com/tags/%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/"},{"name":"一致性哈希算法","slug":"一致性哈希算法","permalink":"http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"name":"主从复制模型","slug":"主从复制模型","permalink":"http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B/"},{"name":"内存优化","slug":"内存优化","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"},{"name":"回收进程","slug":"回收进程","permalink":"http://example.com/tags/%E5%9B%9E%E6%94%B6%E8%BF%9B%E7%A8%8B/"},{"name":"异步队列","slug":"异步队列","permalink":"http://example.com/tags/%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"热点数据","slug":"热点数据","permalink":"http://example.com/tags/%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/"},{"name":"共享","slug":"共享","permalink":"http://example.com/tags/%E5%85%B1%E4%BA%AB/"},{"name":"内存回收","slug":"内存回收","permalink":"http://example.com/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"},{"name":"对象","slug":"对象","permalink":"http://example.com/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"整数集合","slug":"整数集合","permalink":"http://example.com/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"},{"name":"跳表","slug":"跳表","permalink":"http://example.com/tags/%E8%B7%B3%E8%A1%A8/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"单例模式","slug":"单例模式","permalink":"http://example.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"synchronized","slug":"synchronized","permalink":"http://example.com/tags/synchronized/"},{"name":"终止模式","slug":"终止模式","permalink":"http://example.com/tags/%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F/"},{"name":"创建线程","slug":"创建线程","permalink":"http://example.com/tags/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"},{"name":"类初始化：主动使用与被动使用","slug":"类初始化：主动使用与被动使用","permalink":"http://example.com/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8/"},{"name":"类的加载过程","slug":"类的加载过程","permalink":"http://example.com/tags/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},{"name":"ArrayList","slug":"ArrayList","permalink":"http://example.com/tags/ArrayList/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"HashMap","slug":"HashMap","permalink":"http://example.com/tags/HashMap/"},{"name":"List","slug":"List","permalink":"http://example.com/tags/List/"},{"name":"接口","slug":"接口","permalink":"http://example.com/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"重写","slug":"重写","permalink":"http://example.com/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"http://example.com/tags/%E9%87%8D%E8%BD%BD/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"final、finally、fi'nalize","slug":"final、finally、fi-nalize","permalink":"http://example.com/tags/final%E3%80%81finally%E3%80%81fi-nalize/"},{"name":"Integer","slug":"Integer","permalink":"http://example.com/tags/Integer/"},{"name":"快速选择","slug":"快速选择","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"},{"name":"Top","slug":"Top","permalink":"http://example.com/tags/Top/"},{"name":"快速排序","slug":"快速排序","permalink":"http://example.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}